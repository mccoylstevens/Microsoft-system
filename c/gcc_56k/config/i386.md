# i386

;; GCC machine description for Intel 80386.\
;; Copyright (C) 1988 Free Software Foundation, Inc.\
;; Mostly by William Schelter.

;; This file is part of GNU CC.

;; GNU CC is free software; you can redistribute it and/or modify\
;; it under the terms of the GNU General Public License as published by\
;; the Free Software Foundation; either version 1, or (at your option)\
;; any later version.

;; GNU CC is distributed in the hope that it will be useful,\
;; but WITHOUT ANY WARRANTY; without even the implied warranty of\
;; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\
;; GNU General Public License for more details.

;; You should have received a copy of the GNU General Public License\
;; along with GNU CC; see the file COPYING. If not, write to\
;; the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.

;;- instruction definitions

;;- @@The original PO technology requires these to be ordered by speed,\
;;- @@ so that assigner will pick the fastest.

;;- See file "rtl.def" for documentation on define\_insn, match\_\*, et. al.

;;- When naming insn's (operand 0 of define\_insn) be careful about using\
;;- names from other targets machine descriptions.

;;- cpp macro #define NOTICE\_UPDATE\_CC in file tm.h handles condition code\
;;- updates for most instructions.

;;- Operand classes for the register allocator:\
;;- 'a' for eax\
;;- 'd' for edx\
;;- 'c' for ecx\
;;- 'b' for ebx\
;;- 'f' for anything in FLOAT\_REGS\
;;- 'r' any (non-floating-point) register\
;;- 'q' regs that allow byte operations (A, B, C and D)\
;;- 'A' A and D registers

;; the special asm out single letter directives following a '%' are:\
;; 'z' mov%z1 would be movl, movw, or movb depending on the mode of operands\[1]\
;; 's' output a '\*'\
;; 'w' If the operand is a REG, it uses the mode size to determine the\
;; printing of the reg

\
;; Put tstsi first among test insns so it matches a CONST\_INT operand.

(define\_insn "tstsi"\
\[(set (cc0)\
(match\_operand:SI 0 "general\_operand" "rm"))]\
""\
"\*\
{\
operands\[1] = const0\_rtx;\
if (REG\_P (operands\[0]))\
return AS2 (test%L0,%0,%0);\
return AS2 (cmp%L0,%1,%0);\
}")

(define\_insn "tsthi"\
\[(set (cc0)\
(match\_operand:HI 0 "general\_operand" "rm"))]\
""\
"\*\
{\
operands\[1] = const0\_rtx;\
if (REG\_P (operands\[0]))\
return AS2 (test%W0,%0,%0);\
return AS2 (cmp%W0,%1,%0);\
}")

(define\_insn "tstqi"\
\[(set (cc0)\
(match\_operand:QI 0 "general\_operand" "qm"))]\
""\
"\*\
{\
operands\[1] = const0\_rtx;\
if (REG\_P (operands\[0]))\
return AS2 (test%B0,%0,%0);\
return AS2 (cmp%B0,%1,%0);\
}")

(define\_insn "tstsf"\
\[(set (cc0)\
(match\_operand:SF 0 "general\_operand" "rm,f"))\
(clobber (reg:HI 0))]\
"TARGET\_80387"\
"\*\
{\
rtx xops\[1];\
if (!FP\_REG\_P (operands\[0]))\
fp\_push\_sf (operands\[0]);\
/\* fp\_pop\_level--; \*/\
xops\[0] = FP\_TOP;\
cc\_status.flags |= CC\_IN\_80387;\
if (FP\_REG\_P (operands\[0]) && ! top\_dead\_p (insn))\
output\_asm\_insn ("ftst;fnstsw %R0ax;sahf", xops);\
else\
output\_asm\_insn ("ftst;fstp %0(0);fnstsw %R0ax;sahf", xops);\
RETCOM (testsf);\
}")

(define\_insn "tstdf"\
\[(set (cc0)\
(match\_operand:DF 0 "general\_operand" "rm,f"))\
(clobber (reg:HI 0))\
]\
"TARGET\_80387"\
"\*\
{\
rtx xops\[1];\
if (!FP\_REG\_P (operands\[0]))\
fp\_push\_df (operands\[0]);\
/\* fp\_pop\_level--; \*/\
xops\[0] = FP\_TOP;\
cc\_status.flags |= CC\_IN\_80387;\
if (FP\_REG\_P (operands\[0]) && ! top\_dead\_p (insn))\
output\_asm\_insn ("ftst;fnstsw %R0ax;sahf", xops);\
else\
output\_asm\_insn ("ftst;fstp %0(0);fnstsw %R0ax;sahf", xops);\
RETCOM (testdf);\
}")\
;;- compare instructions

;; Put cmpsi first among compare insns so it matches two CONST\_INT operands.

(define\_insn "cmpsi"\
\[(set (cc0)\
(compare (match\_operand:SI 0 "general\_operand" "mr,ri")\
(match\_operand:SI 1 "general\_operand" "ri,mr")))]\
""\
"\*\
{\
if (REG\_P (operands\[1])\
|| (!REG\_P (operands\[0]) && GET\_CODE (operands\[0]) != MEM))\
{\
cc\_status.flags |= CC\_REVERSED;\
return AS2 (cmp%L0,%0,%1);\
}\
return AS2 (cmp%L0,%1,%0);\
}")

(define\_insn "cmphi"\
\[(set (cc0)\
(compare (match\_operand:HI 0 "general\_operand" "mr,ri")\
(match\_operand:HI 1 "general\_operand" "ri,mr")))]\
""\
"\*\
{\
if (REG\_P (operands\[1])\
|| (!REG\_P (operands\[0]) && GET\_CODE (operands\[0]) != MEM))\
{\
cc\_status.flags |= CC\_REVERSED;\
return AS2 (cmp%W0,%0,%1);\
}\
return AS2 (cmp%W0,%1,%0);\
}")

(define\_insn "cmpqi"\
\[(set (cc0)\
(compare (match\_operand:QI 0 "general\_operand" "qn,mq")\
(match\_operand:QI 1 "general\_operand" "qm,nq")))]\
""\
"\*\
{\
if (REG\_P (operands\[1])\
|| (!REG\_P (operands\[0]) && GET\_CODE (operands\[0]) != MEM))\
{\
cc\_status.flags |= CC\_REVERSED;\
return AS2 (cmp%B0,%0,%1);\
}\
return AS2 (cmp%B0,%1,%0);\
}")

(define\_insn "cmpdf"\
\[(set (cc0)\
(compare (match\_operand:DF 0 "general\_operand" "m,&#x66;_&#x72;,m,f,r,!r")_\
_(match\_operand:DF 1 "general\_operand" "m,m,fr,r,f,r")))_\
_(clobber (reg:SI 0))]_\
_"TARGET\_80387"_\
_"_\
_{_\
_if (FP\_REG\_P (operands\[0]))_\
_{_\
_rtx tem = operands\[1];_\
_operands\[1] = operands\[0];_\
_operands\[0] = tem;_\
_cc\_status.flags |= CC\_REVERSED;_\
_}_\
_if (! FP\_REG\_P (operands\[1]))_\
_output\_movdf (FP\_TOP, operands\[1]);_\
_output\_movdf (FP\_TOP, operands\[0]);_\
_/_ fp\_pop\_level--;\
fp\_pop\_level--; \*/\
cc\_status.flags |= CC\_IN\_80387;\
return "fcompp;fnstsw %R0ax;sahf";\
}")

(define\_insn "cmpsf"\
\[(set (cc0)\
(compare (match\_operand:SF 0 "general\_operand" "m,&#x66;_&#x72;,m,f,r,!r")_\
_(match\_operand:SF 1 "general\_operand" "m,m,fr,r,f,r")))_\
_(clobber (reg:SI 0))]_\
_"TARGET\_80387"_\
_"_\
_{_\
_if (FP\_REG\_P (operands\[0]))_\
_{_\
_rtx tem = operands\[1];_\
_operands\[1] = operands\[0];_\
_operands\[0] = tem;_\
_cc\_status.flags |= CC\_REVERSED;_\
_}_\
_if (! FP\_REG\_P (operands\[1]))_\
_output\_movsf (FP\_TOP, operands\[1]);_\
_output\_movsf (FP\_TOP, operands\[0]);_\
_/_ fp\_pop\_level--;\
fp\_pop\_level--; \*/\
cc\_status.flags |= CC\_IN\_80387;\
return "fcompp;fnstsw %R0ax;sahf";\
}")

;; logical compare\
(define\_insn ""\
\[(set (cc0)\
(and:SI (match\_operand:SI 0 "general\_operand" "rm,ri")\
(match\_operand:SI 1 "general\_operand" "ri,rm")))]\
""\
"\*\
{\
if (GET\_CODE (operands\[1]) == CONST\_INT || GET\_CODE (operands\[0]) == MEM)\
return AS2 (test%L0,%1,%0);\
return AS2 (test%L0,%0,%1);\
}")

(define\_insn ""\
\[(set (cc0)\
(and:HI (match\_operand:HI 0 "general\_operand" "rm,ri")\
(match\_operand:HI 1 "general\_operand" "ri,rm")))]\
""\
"\*\
{\
if (GET\_CODE (operands\[1]) == CONST\_INT || GET\_CODE (operands\[0]) == MEM)\
return AS2 (test%W0,%1,%0);\
return AS2 (test%W0,%0,%1);\
}")

(define\_insn ""\
\[(set (cc0)\
(and:QI (match\_operand:QI 0 "general\_operand" "qm,qi")\
(match\_operand:QI 1 "general\_operand" "qi,qm")))]\
""\
"\*\
{\
if (GET\_CODE (operands\[1]) == CONST\_INT || GET\_CODE (operands\[0]) == MEM)\
return AS2 (test%B0,%1,%0);\
return AS2 (test%B0,%0,%1);\
}")\
;; move instructions.\
;; There is one for each machine mode,\
;; and each is preceded by a corresponding push-insn pattern\
;; (since pushes are not general\_operands on the 386).

(define\_insn ""\
\[(set (match\_operand:SI 0 "push\_operand" "=<")\
(match\_operand:SI 1 "general\_operand" "g"))]\
""\
"push%L0 %1")

;; General case of fullword move.\
(define\_insn "movsi"\
\[(set (match\_operand:SI 0 "general\_operand" "=g,r")\
(match\_operand:SI 1 "general\_operand" "ri,m"))]\
""\
"\*\
{\
rtx link;\
if (operands\[1] == const0\_rtx && REG\_P (operands\[0]))\
return "xor%L0 %0,%0";\
if (operands\[1] == const1\_rtx\
&& (link = find\_reg\_note (insn, REG\_WAS\_0, 0))\
/\* Make sure the insn that stored the 0 is still present. _/_\
_&& ! XEXP (link, 0)->volatil_\
_&& GET\_CODE (XEXP (link, 0)) != NOTE_\
_/_ Make sure cross jumping didn't happen here. _/_\
_&& no\_labels\_between\_p (XEXP (link, 0), insn))_\
_/_ Fastest way to change a 0 to a 1. \*/\
return "inc%L0 %0";\
return "mov%L0 %1,%0";\
}")

(define\_insn ""\
\[(set (match\_operand:HI 0 "push\_operand" "=<")\
(match\_operand:HI 1 "general\_operand" "g"))]\
""\
"push%W0 %1")

(define\_insn "movhi"\
\[(set (match\_operand:HI 0 "general\_operand" "=g,r")\
(match\_operand:HI 1 "general\_operand" "ri,m"))]\
""\
"\*\
{\
rtx link;\
if (operands\[1] == const0\_rtx && REG\_P (operands\[0]))\
return "xor%W0 %0,%0";\
if (operands\[1] == const1\_rtx\
&& (link = find\_reg\_note (insn, REG\_WAS\_0, 0))\
/\* Make sure the insn that stored the 0 is still present. _/_\
_&& ! XEXP (link, 0)->volatil_\
_&& GET\_CODE (XEXP (link, 0)) != NOTE_\
_/_ Make sure cross jumping didn't happen here. _/_\
_&& no\_labels\_between\_p (XEXP (link, 0), insn))_\
_/_ Fastest way to change a 0 to a 1. \*/\
return "inc%W0 %0";\
return "mov%W0 %1,%0";\
}")

;; emit\_push\_insn when it calls move\_by\_pieces\
;; requires an insn to "push a byte".\
;; But actually we use pushw, which has the effect of rounding\
;; the amount pushed up to a halfword.\
(define\_insn ""\
\[(set (match\_operand:QI 0 "push\_operand" "=<")\
(match\_operand:QI 1 "general\_operand" "q"))]\
""\
"\*\
{\
operands\[1] = gen\_rtx (REG, HImode, REGNO (operands\[1]));\
return "push%W0 %1";\
}")

(define\_insn "movqi"\
\[(set (match\_operand:QI 0 "general\_operand" "=q,_r,m")_\
_(match\_operand:QI 1 "general\_operand" "g,q,qi"))]_\
_""_\
_"_\
_{_\
_rtx link;_\
_if (operands\[1] == const0\_rtx && REG\_P (operands\[0]))_\
_return "xor%B0 %0,%0";_\
_if (operands\[1] == const1\_rtx_\
_&& (link = find\_reg\_note (insn, REG\_WAS\_0, 0))_\
_/_ Make sure the insn that stored the 0 is still present. _/_\
_&& ! XEXP (link, 0)->volatil_\
_&& GET\_CODE (XEXP (link, 0)) != NOTE_\
_/_ Make sure cross jumping didn't happen here. _/_\
_&& no\_labels\_between\_p (XEXP (link, 0), insn))_\
_/_ Fastest way to change a 0 to a 1. _/_\
_return "inc%B0 %0";_\
_/_ If mov%B0 isn't allowed for one of these regs, use mov%W0. \*/\
if (NON\_QI\_REG\_P (operands\[0]) || NON\_QI\_REG\_P (operands\[1]))\
return (AS2 (mov%W0,%w1,%w0));\
return (AS2 (mov%B0,%1,%0));\
}")

; I suspect nothing can ever match this ???\
;(define\_insn ""\
; \[(set (match\_operand:SF 0 "general\_operand" "rm")\
; (match\_operand:SF 1 "general\_operand" "f"))\
; (clobber (reg:SF 8))]\
; ""\
; "\*\
;{\
; output\_asm\_insn ("???", operands);\
; fpop\_sf (operands\[0]);\
; RETCOM (movsf\_clobber);\
;}")

(define\_insn ""\
\[(set (match\_operand:SF 0 "push\_operand" "=<,<")\
(match\_operand:SF 1 "general\_operand" "gF,f"))]\
""\
"\*\
{\
if (FP\_REG\_P (operands\[1]))\
{\
rtx xops\[3];\
xops\[0] = AT\_SP (SFmode);\
xops\[1] = gen\_rtx (CONST\_INT, VOIDmode, 4);\
xops\[2] = stack\_pointer\_rtx;\
/\* fp\_pop\_level--; \*/\
output\_asm\_insn (AS2 (sub%L0,%1,%2), xops);\
if (top\_dead\_p (insn))\
output\_asm\_insn ("fstp%S0 %0", xops);\
else\
output\_asm\_insn ("fst%S0", xops);\
RET;\
}\
return "push%L0 %1";\
}")

(define\_insn "movsf"\
\[(set (match\_operand:SF 0 "general\_operand" "=rf,rmf,!rm")\
(match\_operand:SF 1 "general\_operand" "m,rf,F"))]\
""\
"\*\
{\
if (FP\_REG\_P (operands\[1])\
&& !FP\_REG\_P (operands\[0])\
&& !top\_dead\_p (insn))\
fp\_store\_sf (operands\[0]);\
else\
output\_movsf (operands\[0], operands\[1]);\
RETCOM (movsf);\
}")

;;should change to handle the memory operands\[1] without doing df push..\
(define\_insn ""\
\[(set (match\_operand:DF 0 "push\_operand" "=<,<")\
(match\_operand:DF 1 "general\_operand" "gF,f"))]\
""\
"\*\
{\
if (FP\_REG\_P (operands\[1]))\
{\
rtx xops\[3];\
xops\[0] = AT\_SP (DFmode);\
xops\[1] = gen\_rtx (CONST\_INT, VOIDmode, 8);\
xops\[2] = stack\_pointer\_rtx;\
/\* fp\_pop\_level--; \*/\
output\_asm\_insn (AS2 (sub%L0,%1,%2), xops);\
if (top\_dead\_p(insn))\
output\_asm\_insn ("fstp%Q0 %0", xops);\
else\
output\_asm\_insn ("fst%Q0 %0", xops);\
RETCOM (pushdf);\
}\
else\
return output\_move\_double (operands);\
}")

(define\_insn "movdf"\
\[(set (match\_operand:DF 0 "general\_operand" "=\&rf,rmf,!rm")\
(match\_operand:DF 1 "general\_operand" "m,fr,F"))]\
""\
"\*\
{\
if (FP\_REG\_P (operands\[1])\
&& ! FP\_REG\_P (operands\[0])\
&& ! top\_dead\_p (insn))\
fp\_store\_df (operands\[0]);\
else\
output\_movdf (operands\[0], operands\[1]);\
RETCOM (movdf);\
}")

(define\_insn ""\
\[(set (match\_operand:DI 0 "push\_operand" "=<")\
(match\_operand:DI 1 "general\_operand" "roiF"))]\
""\
"\*\
{\
return output\_move\_double (operands);\
}")

(define\_insn "movdi"\
\[(set (match\_operand:DI 0 "general\_operand" "=\&r,rm")\
(match\_operand:DI 1 "general\_operand" "m,riF"))]\
""\
"\*\
{\
return output\_move\_double (operands);\
}")\
;; These go after the move instructions\
;; because the move instructions are better (require no spilling)\
;; when they can apply. But these go before the add and subtract insns\
;; because it is often shorter to use these when both apply.

;Lennart Augustsson [augustss@cs.chalmers.se](mailto:augustss@cs.chalmers.se)\
;says this pattern just makes slower code:\
; pushl %ebp\
; addl $-80,(%esp)\
;instead of\
; leal -80(%ebp),%eax\
; pushl %eax\
;\
;(define\_insn ""\
; \[(set (match\_operand:SI 0 "push\_operand" "=<")\
; (plus:SI (match\_operand:SI 1 "general\_operand" "%r")\
; (match\_operand:SI 2 "general\_operand" "ri")))]\
; ""\
; "\*\
;{\
; rtx xops\[4];\
; xops\[0] = operands\[0];\
; xops\[1] = operands\[1];\
; xops\[2] = operands\[2];\
; xops\[3] = gen\_rtx (MEM, SImode, stack\_pointer\_rtx);\
; output\_asm\_insn ("push%z1 %1", xops);\
; output\_asm\_insn (AS2 (add%z3,%2,%3), xops);\
; RET;\
;}")

(define\_insn ""\
\[(set (match\_operand:SI 0 "general\_operand" "=g")\
(plus:SI (match\_operand:SI 1 "general\_operand" "0")\
(const\_int 1)))]\
""\
"inc%L0 %0")

(define\_insn ""\
\[(set (match\_operand:SI 0 "general\_operand" "=g")\
(plus:SI (match\_operand:SI 1 "general\_operand" "0")\
(const\_int -1)))]\
""\
"dec%L0 %0")

(define\_insn ""\
\[(set (match\_operand:SI 0 "general\_operand" "=g")\
(minus:SI (match\_operand:SI 1 "general\_operand" "0")\
(const\_int 1)))]\
""\
"dec%L0 %0")

(define\_insn ""\
\[(set (match\_operand:SI 0 "register\_operand" "=r")\
(match\_operand:QI 1 "address\_operand" "p"))]\
""\
"\*\
{\
CC\_STATUS\_INIT;\
/\* Adding a constant to a register is faster with an add. \*/\
if (GET\_CODE (operands\[1]) == PLUS\
&& GET\_CODE (XEXP (operands\[1], 1)) == CONST\_INT\
&& rtx\_equal\_p (operands\[0], XEXP (operands\[1], 0)))\
{\
operands\[1] = XEXP (operands\[1], 1);\
return AS2 (add%L0,%1,%0);\
}\
return "lea%L0 %a1,%0";\
}")\
;;- conversion instructions\
;;- NONE

;;- truncation instructions\
(define\_insn "truncsiqi2"\
\[(set (match\_operand:QI 0 "general\_operand" "=qm,q")\
(truncate:QI\
(match\_operand:SI 1 "general\_operand" "qi,m")))]\
""\
"mov%B0 %b1,%0")

(define\_insn "trunchiqi2"\
\[(set (match\_operand:QI 0 "general\_operand" "=qm,q")\
(truncate:QI\
(match\_operand:HI 1 "general\_operand" "qi,m")))]\
""\
"mov%B0 %b1,%0")

(define\_insn "truncsihi2"\
\[(set (match\_operand:HI 0 "general\_operand" "=rm,r")\
(truncate:HI\
(match\_operand:SI 1 "general\_operand" "ri,m")))]\
""\
"mov%W0 %w1,%0")\
;;- zero extension instructions\
;; Note that the one starting from HImode comes before those for QImode\
;; so that a constant operand will match HImode, not QImode.

(define\_insn "zero\_extendhisi2"\
\[(set (match\_operand:SI 0 "general\_operand" "=r")\
(zero\_extend:SI\
(match\_operand:HI 1 "general\_operand" "rm")))]\
""\
"movz%W0%L0 %1,%0")

(define\_insn "zero\_extendqihi2"\
\[(set (match\_operand:HI 0 "general\_operand" "=r")\
(zero\_extend:HI\
(match\_operand:QI 1 "general\_operand" "qm")))]\
""\
"movz%B0%W0 %1,%0")

(define\_insn "zero\_extendqisi2"\
\[(set (match\_operand:SI 0 "general\_operand" "=r")\
(zero\_extend:SI\
(match\_operand:QI 1 "general\_operand" "qm")))]\
""\
"movz%B0%L0 %1,%0")\
;;- sign extension instructions\
;; Note that the one starting from HImode comes before those for QImode\
;; so that a constant operand will match HImode, not QImode.

/\*\
(define\_insn "extendsidi2"\
\[(set (match\_operand:DI 0 "general\_operand" "=a")\
(sign\_extend:DI\
(match\_operand:SI 1 "general\_operand" "a")))]\
""\
"clq")\
\*/

(define\_insn "extendhisi2"\
\[(set (match\_operand:SI 0 "general\_operand" "=r")\
(sign\_extend:SI\
(match\_operand:HI 1 "general\_operand" "rm")))]\
""\
"movs%W0%L0 %1,%0")

(define\_insn "extendqihi2"\
\[(set (match\_operand:HI 0 "general\_operand" "=r")\
(sign\_extend:HI\
(match\_operand:QI 1 "general\_operand" "qm")))]\
""\
"movs%B0%W0 %1,%0")

(define\_insn "extendqisi2"\
\[(set (match\_operand:SI 0 "general\_operand" "=r")\
(sign\_extend:SI\
(match\_operand:QI 1 "general\_operand" "qm")))]\
""\
"movs%B0%L0 %1,%0"\
)\
;; Conversions between float and double.

(define\_insn "extendsfdf2"\
\[(set (match\_operand:DF 0 "general\_operand" "=fm,f,fm,fm")\
(float\_extend:DF\
(match\_operand:SF 1 "general\_operand" "m,0,f,!_r")))]_\
_"TARGET\_80387"_\
_"_\
{\
if (FP\_REG\_P (operands\[0]))\
{\
output\_movsf (operands\[0], operands\[1]);\
RET;\
}\
if (FP\_REG\_P (operands\[1]))\
{\
if (top\_dead\_p (insn))\
fp\_pop\_df (operands\[0]);\
else\
fp\_store\_df (operands\[0]);\
RET;\
}\
output\_movsf (FP\_TOP, operands\[1]);\
fp\_pop\_df (operands\[0]);\
RETCOM (extendsfdf2);\
}")

;; This cannot output into an f-reg because there is no way to be\
;; sure of truncating in that case.\
(define\_insn "truncdfsf2"\
\[(set (match\_operand:SF 0 "general\_operand" "=m,!_r")_\
_(float\_truncate:SF_\
_(match\_operand:DF 1 "general\_operand" "f,f")))]_\
_"TARGET\_80387"_\
_"_\
{\
if (top\_dead\_p (insn))\
fp\_pop\_sf (operands\[0]);\
else\
fp\_store\_sf (operands\[0]);\
RETCOM (truncdfsf2);\
}")\
;; Conversion between fixed point and floating point.\
;; Note that among the fix-to-float insns\
;; the ones that start with SImode come first.\
;; That is so that an operand that is a CONST\_INT\
;; (and therefore lacks a specific machine mode).\
;; will be recognized as SImode (which is always valid)\
;; rather than as QImode or HImode. The 80387 would not know\
;; what to do with the smaller sizes anyway. (I think).

(define\_insn "floatsisf2"\
\[(set (match\_operand:SF 0 "general\_operand" "=fm,fm")\
(float:SF (match\_operand:SI 1 "general\_operand" "m,!_r")))]_\
_"TARGET\_80387"_\
_"_\
{\
/\* fp\_pop\_level++; \*/

if (GET\_CODE (operands\[1]) != MEM)\
{\
rtx xops\[2];\
output\_asm\_insn ("push%L0 %1", operands);\
operands\[1] = AT\_SP (SImode);\
output\_asm\_insn ("fild%L0 %1", operands);\
xops\[0] = stack\_pointer\_rtx;\
xops\[1] = gen\_rtx (CONST\_INT, VOIDmode, 4);\
output\_asm\_insn (AS2 (add%L0,%1,%0), xops);\
}\
else\
output\_asm\_insn ("fild%L0 %1", operands);

if (! FP\_REG\_P (operands\[0]))\
{\
/\* fp\_pop\_level--; \*/\
return "fstp%S0 %0";\
}\
RET;\
}")

(define\_insn "floatsidf2"\
\[(set (match\_operand:DF 0 "general\_operand" "=fm,fm")\
(float:DF (match\_operand:SI 1 "general\_operand" "m,!_r")))]_\
_"TARGET\_80387"_\
_"_\
{\
/\* fp\_pop\_level++; _/_\
_if (GET\_CODE (operands\[1]) != MEM)_\
_{_\
_rtx xops\[2];_\
_output\_asm\_insn ("push%L0 %1", operands);_\
_operands\[1] = AT\_SP (SImode);_\
_output\_asm\_insn ("fild%L0 %1", operands);_\
_xops\[0] = stack\_pointer\_rtx;_\
_xops\[1] = gen\_rtx (CONST\_INT, VOIDmode, 4);_\
_output\_asm\_insn (AS2 (add%L0,%1,%0), xops);_\
_}_\
_else_\
_output\_asm\_insn ("fild%L0 %1", operands);_\
_if (! FP\_REG\_P (operands\[0]))_\
_{_\
_/_ fp\_pop\_level--; \*/\
return "fstp%Q0 %0";\
}\
RET;\
}")\
;; Convert a float to a float whose value is an integer.\
;; This is the first stage of converting it to an integer type.

;; On the 387 truncating doub to an short integer shor can be performed:

; fstcw -4(%esp) ;save cw\
; movw -4(%esp),%ax\
; orw $0x0c00,%ax ;set rounding to chop towards zero\
; movw %ax,-2(%esp) ;\
; fldcw -2(%esp) ;\
; fldl doubl\
; fistpl -12(%esp) ;store the round value\
; fldcw -4(%esp) ;restore cw\
; movl -12(%esp),%eax\
; movw %ax,shor ; move the result into shor.

;; but it is probably better to have a call, rather than waste this\
;; space. The last instruction would have been a movl if were\
;; going to an int instead of a short.\
;; For the moment we will go with the soft float for these.

/\* These are incorrect since they don't set the rounding bits of CW flag.\
The proper way to do that is to make the function prologue save the CW\
and also construct the alternate CW value needed for these insns.\
Then these insns can output two fldcw's, referring to fixed places in\
the stack frame.

;; Convert a float whose value is an integer\
;; to an actual integer. Second stage of converting float to integer type.

(define\_insn "fix\_truncsfqi2"\
\[(set (match\_operand:QI 0 "general\_operand" "=m,?_q")_\
_(fix:QI (fix:SF (match\_operand:SF 1 "general\_operand" "f,f"))))]_\
_"TARGET\_80387"_\
_"_\
{\
fp\_pop\_int (operands\[0]);\
RET;\
}")

(define\_insn "fix\_truncsfhi2"\
\[(set (match\_operand:HI 0 "general\_operand" "=m,?_r")_\
_(fix:HI (fix:SF (match\_operand:SF 1 "general\_operand" "f,f"))))]_\
_"TARGET\_80387"_\
_"_\
{\
fp\_pop\_int (operands\[0]);\
RET;\
}")

(define\_insn "fix\_truncsfsi2"\
\[(set (match\_operand:SI 0 "general\_operand" "=m,?_r")_\
_(fix:SI (fix:SF (match\_operand:SF 1 "general\_operand" "f,f"))))]_\
_"TARGET\_80387"_\
_"_\
{\
fp\_pop\_int (operands\[0]);\
RET;\
}")

(define\_insn "fix\_truncdfqi2"\
\[(set (match\_operand:QI 0 "general\_operand" "=m,?\*q")\
(fix:QI (fix:DF (match\_operand:DF 1 "general\_operand" "f,f"))))]

"TARGET\_80387"\
"\*\
{\
fp\_pop\_int (operands\[0]);\
RET;\
}")

(define\_insn "fix\_truncdfhi2"\
\[(set (match\_operand:HI 0 "general\_operand" "=m,?_r")_\
_(fix:HI (fix:DF (match\_operand:DF 1 "general\_operand" "f,f"))))]_\
_"TARGET\_80387"_\
_"_\
{\
fp\_pop\_int (operands\[0]);\
RET;\
}")

(define\_insn "fix\_truncdfsi2"\
\[(set (match\_operand:SI 0 "general\_operand" "=m,?_r")_\
_(fix:SI (fix:DF (match\_operand:DF 1 "general\_operand" "f,f"))))]_\
_"TARGET\_80387"_\
_"_\
{\
fp\_pop\_int (operands\[0]);\
RET;\
}")\
\*/

\
;;- add instructions\
;;moved incl to above leal

(define\_insn "addsi3"\
\[(set (match\_operand:SI 0 "general\_operand" "=rm,r")\
(plus:SI (match\_operand:SI 1 "general\_operand" "%0,0")\
(match\_operand:SI 2 "general\_operand" "ri,rm")))]\
""\
"add%L0 %2,%0")

(define\_insn ""\
\[(set (match\_operand:HI 0 "general\_operand" "=g")\
(plus:HI (match\_operand:HI 1 "general\_operand" "0")\
(const\_int 1)))]\
""\
"inc%W0 %0")

(define\_insn "addhi3"\
\[(set (match\_operand:HI 0 "general\_operand" "=rm,r")\
(plus:HI (match\_operand:HI 1 "general\_operand" "%0,0")\
(match\_operand:HI 2 "general\_operand" "ri,rm")))]\
""\
"add%W0 %2,%0")

(define\_insn ""\
\[(set (match\_operand:QI 0 "general\_operand" "=qm")\
(plus:QI (match\_operand:QI 1 "general\_operand" "0")\
(const\_int 1)))]\
""\
"inc%B0 %0")

(define\_insn "addqi3"\
\[(set (match\_operand:QI 0 "general\_operand" "=m,q")\
(plus:QI (match\_operand:QI 1 "general\_operand" "%0,0")\
(match\_operand:QI 2 "general\_operand" "qn,qmn")))]\
""\
"add%B0 %2,%0")

;;had "fmF,m"

(define\_insn "adddf3"\
\[(set (match\_operand:DF 0 "general\_operand" "=f,m,f")\
(plus:DF (match\_operand:DF 1 "general\_operand" "%0,0,0")\
(match\_operand:DF 2 "general\_operand" "m,!f,!\*r")))]\
"TARGET\_80387"\
"\*FP\_CALL ("fadd%z0 %0", "fadd%z0 %0", 2)")

(define\_insn "addsf3"\
\[(set (match\_operand:SF 0 "general\_operand" "=f,m,f")\
(plus:SF (match\_operand:SF 1 "general\_operand" "%0,0,0")\
(match\_operand:SF 2 "general\_operand" "m,!f,!\*r")))]\
"TARGET\_80387"\
"\*FP\_CALL ("fadd%z0 %0", "fadd%z0 %0", 2)")\
;;- subtract instructions

;;moved decl above leal

(define\_insn "subsi3"\
\[(set (match\_operand:SI 0 "general\_operand" "=rm,r")\
(minus:SI (match\_operand:SI 1 "general\_operand" "0,0")\
(match\_operand:SI 2 "general\_operand" "ri,rm")))]\
""\
"sub%L0 %2,%0")

(define\_insn ""\
\[(set (match\_operand:HI 0 "general\_operand" "=g")\
(minus:HI (match\_operand:HI 1 "general\_operand" "0")\
(const\_int 1)))]\
""\
"dec%W0 %0")

(define\_insn "subhi3"\
\[(set (match\_operand:HI 0 "general\_operand" "=rm,r")\
(minus:HI (match\_operand:HI 1 "general\_operand" "0,0")\
(match\_operand:HI 2 "general\_operand" "ri,rm")))]\
""\
"sub%W0 %2,%0")

(define\_insn ""\
\[(set (match\_operand:QI 0 "general\_operand" "=qm")\
(minus:QI (match\_operand:QI 1 "general\_operand" "0")\
(const\_int 1)))]\
""\
"dec%B0 %0")

(define\_insn "subqi3"\
\[(set (match\_operand:QI 0 "general\_operand" "=m,q")\
(minus:QI (match\_operand:QI 1 "general\_operand" "0,0")\
(match\_operand:QI 2 "general\_operand" "qn,qmn")))]\
""\
"sub%B0 %2,%0")

(define\_insn "subdf3"\
\[(set (match\_operand:DF 0 "general\_operand" "=f,m,f,f")\
(minus:DF (match\_operand:DF 1 "general\_operand" "0,0,0,m")\
(match\_operand:DF 2 "general\_operand" "m,!f,!\*r,\*0")))]\
"TARGET\_80387"\
"\*FP\_CALL ("fsub%z0 %0", "fsubr%z0 %0", 2)")

(define\_insn "subsf3"\
\[(set (match\_operand:SF 0 "general\_operand" "=f,m,f,f")\
(minus:SF (match\_operand:SF 1 "general\_operand" "0,0,0,m")\
(match\_operand:SF 2 "general\_operand" "m,!f,!\*r,\*0")))]\
"TARGET\_80387"\
"\*FP\_CALL ("fsub%z0 %0", "fsubr%z0 %0", 2)")\
;;- multiply instructions

;(define\_insn "mulqi3"\
; \[(set (match\_operand:QI 0 "general\_operand" "=a")\
; (mult:QI (match\_operand:QI 1 "general\_operand" "%0")\
; (match\_operand:QI 2 "general\_operand" "qm")))]\
; ""\
; "mul%B0 %2,%0")

(define\_insn "mulhi3"\
\[(set (match\_operand:HI 0 "general\_operand" "=r,r")\
(mult:SI (match\_operand:HI 1 "general\_operand" "%0,rm")\
(match\_operand:HI 2 "general\_operand" "g,i")))]\
""\
"\*\
{\
if (GET\_CODE (operands\[1]) == REG\
&& REGNO (operands\[1]) == REGNO (operands\[0])\
&& (GET\_CODE (operands\[2]) == MEM\
|| GET\_CODE (operands\[2]) == REG))\
/\* Assembler has weird restrictions. \*/\
return AS2 (imul%W0,%2,%0);\
return AS3 (imul%W0,%2,%1,%0);\
}")

(define\_insn "mulsi3"\
\[(set (match\_operand:SI 0 "general\_operand" "=r,r")\
(mult:SI (match\_operand:SI 1 "general\_operand" "%0,rm")\
(match\_operand:SI 2 "general\_operand" "g,i")))]\
""\
"\*\
{\
if (GET\_CODE (operands\[1]) == REG\
&& REGNO (operands\[1]) == REGNO (operands\[0])\
&& (GET\_CODE (operands\[2]) == MEM\
|| GET\_CODE (operands\[2]) == REG))\
/\* Assembler has weird restrictions. \*/\
return AS2 (imul%L0,%2,%0);\
return AS3 (imul%L0,%2,%1,%0);\
}")

;; Turned off due to possible assembler bug.\
;(define\_insn "umulqi3"\
; \[(set (match\_operand:QI 0 "general\_operand" "=a")\
; (umult:QI (match\_operand:QI 1 "general\_operand" "%0")\
; (match\_operand:QI 2 "general\_operand" "qm")))]\
; ""\
; "mul%B0 %2,%0")

;(define\_insn "umulqihi3"\
; \[(set (match\_operand:HI 0 "general\_operand" "=a")\
; (umult:HI (match\_operand:QI 1 "general\_operand" "%0")\
; (match\_operand:QI 2 "general\_operand" "qm")))]\
; ""\
; "mul%B0 %2,%0")

(define\_insn "umulhi3"\
\[(set (match\_operand:HI 0 "general\_operand" "=a")\
(umult:SI (match\_operand:HI 1 "general\_operand" "%0")\
(match\_operand:HI 2 "general\_operand" "rm")))\
(clobber (reg:HI 1))]\
""\
"mul%W0 %2,%0")

(define\_insn "umulsi3"\
\[(set (match\_operand:SI 0 "general\_operand" "=a")\
(umult:SI (match\_operand:SI 1 "general\_operand" "%0")\
(match\_operand:SI 2 "general\_operand" "rm")))\
(clobber (reg:SI 1))]\
""\
"mul%L0 %2,%0")

(define\_insn "muldf3"\
\[(set (match\_operand:DF 0 "general\_operand" "=f,m,f")\
(mult:DF (match\_operand:DF 1 "general\_operand" "%0,0,0")\
(match\_operand:DF 2 "general\_operand" "m,!f,!\*r")))]\
"TARGET\_80387"\
"\*FP\_CALL ("fmul%z0 %0", "fmul%z0 %0", 2)\
")

(define\_insn "mulsf3"\
\[(set (match\_operand:SF 0 "general\_operand" "=f,m,f")\
(mult:SF (match\_operand:SF 1 "general\_operand" "%0,0,0")\
(match\_operand:SF 2 "general\_operand" "m,!f,!\*r")))]\
"TARGET\_80387"\
"\*FP\_CALL ("fmul%z0 %0", "fmul%z0 %0", 2)\
")\
;;- divide instructions\
(define\_insn "divdf3"\
\[(set (match\_operand:DF 0 "general\_operand" "=f,m,f,f")\
(div:DF (match\_operand:DF 1 "general\_operand" "0,0,0,m")\
(match\_operand:DF 2 "general\_operand" "m,!f,!\*r,\*0")))]\
"TARGET\_80387"\
"\*FP\_CALL ("fdiv%z0 %0", "fdivr%z0 %0", 2)\
")

(define\_insn "divsf3"\
\[(set (match\_operand:SF 0 "general\_operand" "=f,m,f,f")\
(div:SF (match\_operand:SF 1 "general\_operand" "0,0,0,m")\
(match\_operand:SF 2 "general\_operand" "m,!f,!\*r,\*0")))]\
"TARGET\_80387"\
"\*FP\_CALL ("fdiv%z0 %0", "fdivr%z0 %0", 2)\
")\
;; Remainder instructions.

(define\_insn "divmodsi4"\
\[(set (match\_operand:SI 0 "general\_operand" "=a")\
(div:SI (match\_operand:SI 1 "general\_operand" "0")\
(match\_operand:SI 2 "general\_operand" "rm")))\
(set (match\_operand:SI 3 "general\_operand" "=\&d")\
(mod:SI (match\_dup 1) (match\_dup 2)))]\
""\
"cltd;idiv%L0 %2")

(define\_insn "udivmodsi4"\
\[(set (match\_operand:SI 0 "general\_operand" "=a")\
(udiv:SI (match\_operand:SI 1 "general\_operand" "0")\
(match\_operand:SI 2 "general\_operand" "rm")))\
(set (match\_operand:SI 3 "general\_operand" "=\&d")\
(umod:SI (match\_dup 1) (match\_dup 2)))]\
""\
"xor%L0 %3,%3;div%L0 %2")

/\*\
;;this should be a valid double division which we may want to add

(define\_insn ""\
\[(set (match\_operand:SI 0 "general\_operand" "=a")\
(udiv:DI (match\_operand:DI 1 "general\_operand" "a")\
(match\_operand:SI 2 "general\_operand" "rm")))\
(set (match\_operand:SI 3 "general\_operand" "=d")\
(umod:SI (match\_dup 1) (match\_dup 2)))]\
""\
"div%L0 %2,%0")\
\*/\
;;- and instructions

;; The `r' in` rm' for operand 3 looks redundant, but it causes\
;; optional reloads to be generated if op 3 is a pseudo in a stack slot.

(define\_insn "andsi3"\
\[(set (match\_operand:SI 0 "general\_operand" "=rm,r")\
(and:SI (match\_operand:SI 1 "general\_operand" "%0,0")\
(match\_operand:SI 2 "general\_operand" "ri,rm")))]\
""\
"and%L0 %2,%0")

(define\_insn "andhi3"\
\[(set (match\_operand:HI 0 "general\_operand" "=rm,r")\
(and:HI (match\_operand:HI 1 "general\_operand" "%0,0")\
(match\_operand:HI 2 "general\_operand" "ri,rm")))]\
""\
"and%W0 %2,%0")

(define\_insn "andqi3"\
\[(set (match\_operand:QI 0 "general\_operand" "=m,q")\
(and:QI (match\_operand:QI 1 "general\_operand" "%0,0")\
(match\_operand:QI 2 "general\_operand" "qn,qmn")))]\
""\
"and%B0 %2,%0")

/\* I am nervous about these two.. add them later..\
;I presume this means that we have something in say op0= eax which is small\
;and we want to and it with memory so we can do this by just an\
;andb m,%al and have success.\
(define\_insn ""\
\[(set (match\_operand:SI 0 "general\_operand" "=r")\
(and:SI (zero\_extend:SI (match\_operand:HI 1 "general\_operand" "rm"))\
(match\_operand:SI 2 "general\_operand" "0")))]\
"GET\_CODE (operands\[2]) == CONST\_INT\
&& (unsigned int) INTVAL (operands\[2]) < (1 << GET\_MODE\_BITSIZE (HImode))"\
"and%W0 %1,%0")

(define\_insn ""\
\[(set (match\_operand:SI 0 "general\_operand" "=q")\
(and:SI (zero\_extend:SI (match\_operand:QI 1 "general\_operand" "qm"))\
(match\_operand:SI 2 "general\_operand" "0")))]\
"GET\_CODE (operands\[2]) == CONST\_INT\
&& (unsigned int) INTVAL (operands\[2]) < (1 << GET\_MODE\_BITSIZE (QImode))"\
"and%L0 %1,%0")

\*/

\
;;- Bit set (inclusive or) instructions

(define\_insn "iorsi3"\
\[(set (match\_operand:SI 0 "general\_operand" "=rm,r")\
(ior:SI (match\_operand:SI 1 "general\_operand" "%0,0")\
(match\_operand:SI 2 "general\_operand" "ri,rm")))]\
""\
"or%L0 %2,%0")

(define\_insn "iorhi3"\
\[(set (match\_operand:HI 0 "general\_operand" "=rm,r")\
(ior:HI (match\_operand:HI 1 "general\_operand" "%0,0")\
(match\_operand:HI 2 "general\_operand" "ri,rm")))]\
""\
"or%W0 %2,%0")

(define\_insn "iorqi3"\
\[(set (match\_operand:QI 0 "general\_operand" "=m,q")\
(ior:QI (match\_operand:QI 1 "general\_operand" "%0,0")\
(match\_operand:QI 2 "general\_operand" "qn,qmn")))]\
""\
"or%B0 %2,%0")\
;;- xor instructions

(define\_insn "xorsi3"\
\[(set (match\_operand:SI 0 "general\_operand" "=rm,r")\
(xor:SI (match\_operand:SI 1 "general\_operand" "%0,0")\
(match\_operand:SI 2 "general\_operand" "ri,rm")))]\
""\
"xor%L0 %2,%0")

(define\_insn "xorhi3"\
\[(set (match\_operand:HI 0 "general\_operand" "=rm,r")\
(xor:HI (match\_operand:HI 1 "general\_operand" "%0,0")\
(match\_operand:HI 2 "general\_operand" "ri,rm")))]\
""\
"xor%W0 %2,%0")

(define\_insn "xorqi3"\
\[(set (match\_operand:QI 0 "general\_operand" "=qm")\
(xor:QI (match\_operand:QI 1 "general\_operand" "%0")\
(match\_operand:QI 2 "general\_operand" "qn")))]\
""\
"xor%B0 %2,%0")\
;;- negation instructions\
(define\_insn "negsi2"\
\[(set (match\_operand:SI 0 "general\_operand" "=rm")\
(neg:SI (match\_operand:SI 1 "general\_operand" "0")))]\
""\
"neg%L0 %0")

(define\_insn "neghi2"\
\[(set (match\_operand:HI 0 "general\_operand" "=rm")\
(neg:HI (match\_operand:HI 1 "general\_operand" "0")))]\
""\
"neg%W0 %0")

(define\_insn "negqi2"\
\[(set (match\_operand:QI 0 "general\_operand" "=qm")\
(neg:QI (match\_operand:QI 1 "general\_operand" "0")))]\
""\
"neg%B0 %0")

(define\_insn "negsf2"\
\[(set (match\_operand:SF 0 "general\_operand" "=f,!m")\
(neg:SF (match\_operand:SF 1 "general\_operand" "0,0")))]\
"TARGET\_80387"\
"\*FP\_CALL1 ("fchs")")

(define\_insn "negdf2"\
\[(set (match\_operand:DF 0 "general\_operand" "=f,!m")\
(neg:DF (match\_operand:DF 1 "general\_operand" "0,0")))]\
"TARGET\_80387"\
"\*FP\_CALL1 ("fchs")")\
;; Absolute value instructions

(define\_insn "abssf2"\
\[(set (match\_operand:SF 0 "general\_operand" "=f,!m")\
(abs:SF (match\_operand:SF 1 "general\_operand" "0,0")))]\
"TARGET\_80387"\
"\*FP\_CALL1 ("fabs")")

(define\_insn "absdf2"\
\[(set (match\_operand:DF 0 "general\_operand" "=f,!m")\
(abs:DF (match\_operand:DF 1 "general\_operand" "0,0")))]\
"TARGET\_80387"\
"\*FP\_CALL1 ("fabs")")\
;;- one complement instructions\
(define\_insn "one\_cmplsi2"\
\[(set (match\_operand:SI 0 "general\_operand" "=rm")\
(not:SI (match\_operand:SI 1 "general\_operand" "0")))]\
""\
"not%L0 %0")

(define\_insn "one\_cmplhi2"\
\[(set (match\_operand:HI 0 "general\_operand" "=rm")\
(not:HI (match\_operand:HI 1 "general\_operand" "0")))]\
""\
"not%W0 %0")

(define\_insn "one\_cmplqi2"\
\[(set (match\_operand:QI 0 "general\_operand" "=qm")\
(not:QI (match\_operand:QI 1 "general\_operand" "0")))]\
""\
"not%B0 %0")\
;;- arithmetic shift instructions

(define\_insn "ashlsi3"\
\[(set (match\_operand:SI 0 "general\_operand" "=rm")\
(ashift:SI (match\_operand:SI 1 "general\_operand" "0")\
(match\_operand:SI 2 "general\_operand" "cI")))]\
""\
"\*\
{\
if (REG\_P (operands\[2]))\
return AS2 (sal%L0,%R0cl,%0);\
else if (REG\_P (operands\[1]) && GET\_CODE (operands\[2]) == CONST\_INT\
&& INTVAL (operands\[2]) == 1)\
return AS2 (add%L0,%1,%1);\
return AS2 (sal%L0,%2,%1);\
}")

(define\_insn "ashlhi3"\
\[(set (match\_operand:HI 0 "general\_operand" "=rm")\
(ashift:HI (match\_operand:HI 1 "general\_operand" "0")\
(match\_operand:HI 2 "general\_operand" "cI")))]\
""\
"\*\
{\
if (REG\_P (operands\[2]))\
return AS2 (sal%W0,%R0cl,%0);\
else\
return AS2 (sal%W0,%2,%1);\
}")

(define\_insn "ashlqi3"\
\[(set (match\_operand:QI 0 "general\_operand" "=qm")\
(ashift:QI (match\_operand:QI 1 "general\_operand" "0")\
(match\_operand:QI 2 "general\_operand" "cI")))]\
""\
"\*\
{\
if (REG\_P (operands\[2]))\
return AS2 (sal%B0,%R0cl,%0);\
else\
return AS2 (sal%B0,%2,%1);\
}")

(define\_insn "ashrsi3"\
\[(set (match\_operand:SI 0 "general\_operand" "=rm")\
(ashiftrt:SI (match\_operand:SI 1 "general\_operand" "0")\
(match\_operand:SI 2 "general\_operand" "cI")))]\
""\
"\*\
{\
if (REG\_P (operands\[2]))\
return AS2 (sar%L0,%R0cl,%0);\
else\
return AS2 (sar%L0,%2,%0);\
}")

(define\_insn "ashrhi3"\
\[(set (match\_operand:HI 0 "general\_operand" "=rm")\
(ashiftrt:HI (match\_operand:HI 1 "general\_operand" "0")\
(match\_operand:HI 2 "general\_operand" "cI")))]\
""\
"\*\
{\
if (REG\_P (operands\[2]))\
return AS2 (sar%W0,%R0cl,%0);\
else\
return AS2 (sar%W0,%2,%0);\
}")

(define\_insn "ashrqi3"\
\[(set (match\_operand:QI 0 "general\_operand" "=qm")\
(ashiftrt:QI (match\_operand:QI 1 "general\_operand" "0")\
(match\_operand:QI 2 "general\_operand" "cI")))]\
""\
"\*\
{\
if (REG\_P (operands\[2]))\
return AS2 (sar%B0,%R0cl,%0);\
return\
AS2 (sar%B0,%2,%1);\
}")\
;;- logical shift instructions

(define\_insn "lshlsi3"\
\[(set (match\_operand:SI 0 "general\_operand" "=rm")\
(lshift:SI (match\_operand:SI 1 "general\_operand" "0")\
(match\_operand:SI 2 "general\_operand" "cI")))]\
""\
"\*\
{\
if (REG\_P (operands\[2]))\
return AS2 (shl%L0,%R0cl,%0);\
else\
return AS2 (shl%L0,%2,%1);\
}")

(define\_insn "lshlhi3"\
\[(set (match\_operand:HI 0 "general\_operand" "=rm")\
(lshift:HI (match\_operand:HI 1 "general\_operand" "0")\
(match\_operand:HI 2 "general\_operand" "cI")))]\
""\
"\*\
{\
if (REG\_P (operands\[2]))\
return AS2 (shl%W0,%R0cl,%0);\
else\
return AS2 (shl%W0,%2,%1);\
}")

(define\_insn "lshlqi3"\
\[(set (match\_operand:QI 0 "general\_operand" "=qm")\
(lshift:QI (match\_operand:QI 1 "general\_operand" "0")\
(match\_operand:QI 2 "general\_operand" "cI")))]\
""\
"\*\
{\
if (REG\_P (operands\[2]))\
return AS2 (shl%B0,%R0cl,%0);\
else\
return AS2 (shl%B0,%2,%1);\
}")

(define\_insn "lshrsi3"\
\[(set (match\_operand:SI 0 "general\_operand" "=rm")\
(lshiftrt:SI (match\_operand:SI 1 "general\_operand" "0")\
(match\_operand:SI 2 "general\_operand" "cI")))]\
""\
"\*\
{\
if (REG\_P (operands\[2]))\
return AS2 (shr%L0,%R0cl,%0);\
else\
return AS2 (shr%L0,%2,%1);\
}")

(define\_insn "lshrhi3"\
\[(set (match\_operand:HI 0 "general\_operand" "=rm")\
(lshiftrt:HI (match\_operand:HI 1 "general\_operand" "0")\
(match\_operand:HI 2 "general\_operand" "cI")))]\
""\
"\*\
{\
if (REG\_P (operands\[2]))\
return AS2 (shr%W0,%%cl,%0);\
else\
return AS2 (shr%W0,%2,%1);\
}")

(define\_insn "lshrqi3"\
\[(set (match\_operand:QI 0 "general\_operand" "=qm")\
(lshiftrt:QI (match\_operand:QI 1 "general\_operand" "0")\
(match\_operand:QI 2 "general\_operand" "cI")))]\
""\
"\*\
{\
if (REG\_P (operands\[2]))\
return AS2 (shr%B0,%%cl,%0);\
else\
return AS2 (shr%B0,%2,%1);\
}")\
;;- rotate instructions

(define\_insn "rotlsi3"\
\[(set (match\_operand:SI 0 "general\_operand" "=rm")\
(rotate:SI (match\_operand:SI 1 "general\_operand" "0")\
(match\_operand:SI 2 "general\_operand" "cI")))]\
""\
"\*\
{\
if (REG\_P (operands\[2]))\
return AS2 (rol%L0,%%cl,%0);\
else\
return AS2 (rol%L0,%2,%1);\
}")

(define\_insn "rotlhi3"\
\[(set (match\_operand:HI 0 "general\_operand" "=rm")\
(rotate:HI (match\_operand:HI 1 "general\_operand" "0")\
(match\_operand:HI 2 "general\_operand" "cI")))]\
""\
"\*\
{\
if (REG\_P (operands\[2]))\
return AS2 (rol%W0,%%cl,%0);\
else\
return AS2 (rol%W0,%2,%1);\
}")

(define\_insn "rotlqi3"\
\[(set (match\_operand:QI 0 "general\_operand" "=qm")\
(rotate:QI (match\_operand:QI 1 "general\_operand" "0")\
(match\_operand:QI 2 "general\_operand" "cI")))]\
""\
"\*\
{\
if (REG\_P (operands\[2]))\
return AS2 (rol%B0,%%cl,%0);\
else\
return AS2 (rol%B0,%2,%1);\
}")

(define\_insn "rotrsi3"\
\[(set (match\_operand:SI 0 "general\_operand" "=rm")\
(rotatert:SI (match\_operand:SI 1 "general\_operand" "0")\
(match\_operand:SI 2 "general\_operand" "cI")))]\
""\
"\*\
{\
if (REG\_P (operands\[2]))\
return AS2 (ror%L0,%%cl,%0);\
else\
return AS2 (ror%L0,%2,%1);\
}")

(define\_insn "rotrhi3"\
\[(set (match\_operand:HI 0 "general\_operand" "=rm")\
(rotatert:HI (match\_operand:HI 1 "general\_operand" "0")\
(match\_operand:HI 2 "general\_operand" "cI")))]\
""\
"\*\
{\
if (REG\_P (operands\[2]))\
return AS2 (ror%W0,%%cl,%0);\
else\
return AS2 (ror%W0,%2,%1);\
}")

(define\_insn "rotrqi3"\
\[(set (match\_operand:QI 0 "general\_operand" "=qm")\
(rotatert:QI (match\_operand:QI 1 "general\_operand" "0")\
(match\_operand:QI 2 "general\_operand" "cI")))]\
""\
"\*\
{\
if (REG\_P (operands\[2]))\
return AS2 (ror%B0,%%cl,%0);\
else\
return AS2 (ror%B0,%2,%1);\
}")\
;; Store-flag instructions.

(define\_insn "seq"\
\[(set (match\_operand:QI 0 "general\_operand" "=q")\
(eq (cc0) (const\_int 0)))]\
""\
"\*\
cc\_status = cc\_prev\_status;\
return "sete %0";\
")

(define\_insn "sne"\
\[(set (match\_operand:QI 0 "general\_operand" "=q")\
(ne (cc0) (const\_int 0)))]\
""\
"\*\
cc\_status = cc\_prev\_status;\
return "setne %0";\
")

(define\_insn "sgt"\
\[(set (match\_operand:QI 0 "general\_operand" "=q")\
(gt (cc0) (const\_int 0)))]\
""\
"\*\
cc\_status = cc\_prev\_status;\
OUTPUT\_JUMP ("setg %0", "seta %0", 0);\
")

(define\_insn "sgtu"\
\[(set (match\_operand:QI 0 "general\_operand" "=q")\
(gtu (cc0) (const\_int 0)))]\
""\
"\* cc\_status = cc\_prev\_status;\
return "seta %0"; ")

(define\_insn "slt"\
\[(set (match\_operand:QI 0 "general\_operand" "=q")\
(lt (cc0) (const\_int 0)))]\
""\
"\* cc\_status = cc\_prev\_status;\
OUTPUT\_JUMP ("setl %0", "setb %0", "sets %0"); ")

(define\_insn "sltu"\
\[(set (match\_operand:QI 0 "general\_operand" "=q")\
(ltu (cc0) (const\_int 0)))]\
""\
"\* cc\_status = cc\_prev\_status;\
return "setb %0"; ")

(define\_insn "sge"\
\[(set (match\_operand:QI 0 "general\_operand" "=q")\
(ge (cc0) (const\_int 0)))]\
""\
"\* cc\_status = cc\_prev\_status;\
OUTPUT\_JUMP ("setge %0", "setae %0", "setns %0"); ")

(define\_insn "sgeu"\
\[(set (match\_operand:QI 0 "general\_operand" "=q")\
(geu (cc0) (const\_int 0)))]\
""\
"\* cc\_status = cc\_prev\_status;\
return "setae %0"; ")

(define\_insn "sle"\
\[(set (match\_operand:QI 0 "general\_operand" "=q")\
(le (cc0) (const\_int 0)))]\
""\
"\*\
cc\_status = cc\_prev\_status;\
OUTPUT\_JUMP ("setle %0", "setbe %0", 0);\
")

(define\_insn "sleu"\
\[(set (match\_operand:QI 0 "general\_operand" "=q")\
(leu (cc0) (const\_int 0)))]\
""\
"\* cc\_status = cc\_prev\_status;\
return "setbe %0"; ")\
;; Basic conditional jump instructions.\
;; We ignore the overflow flag for signed branch instructions.

(define\_insn "beq"\
\[(set (pc)\
(if\_then\_else (eq (cc0)\
(const\_int 0))\
(label\_ref (match\_operand 0 "" ""))\
(pc)))]\
""\
"je %l0")

(define\_insn "bne"\
\[(set (pc)\
(if\_then\_else (ne (cc0)\
(const\_int 0))\
(label\_ref (match\_operand 0 "" ""))\
(pc)))]\
""\
"jne %l0")

(define\_insn "bgt"\
\[(set (pc)\
(if\_then\_else (gt (cc0)\
(const\_int 0))\
(label\_ref (match\_operand 0 "" ""))\
(pc)))]\
""\
"\*OUTPUT\_JUMP ("jg %l0", "ja %l0", 0)")

(define\_insn "bgtu"\
\[(set (pc)\
(if\_then\_else (gtu (cc0)\
(const\_int 0))\
(label\_ref (match\_operand 0 "" ""))\
(pc)))]\
""\
"ja %l0")

(define\_insn "blt"\
\[(set (pc)\
(if\_then\_else (lt (cc0)\
(const\_int 0))\
(label\_ref (match\_operand 0 "" ""))\
(pc)))]\
""\
"\*OUTPUT\_JUMP ("jl %l0", "jb %l0", "js %l0")")

(define\_insn "bltu"\
\[(set (pc)\
(if\_then\_else (ltu (cc0)\
(const\_int 0))\
(label\_ref (match\_operand 0 "" ""))\
(pc)))]\
""\
"jb %l0")

(define\_insn "bge"\
\[(set (pc)\
(if\_then\_else (ge (cc0)\
(const\_int 0))\
(label\_ref (match\_operand 0 "" ""))\
(pc)))]\
""\
"\*OUTPUT\_JUMP ("jge %l0", "jae %l0", "jns %l0")")

(define\_insn "bgeu"\
\[(set (pc)\
(if\_then\_else (geu (cc0)\
(const\_int 0))\
(label\_ref (match\_operand 0 "" ""))\
(pc)))]\
""\
"jae %l0")

(define\_insn "ble"\
\[(set (pc)\
(if\_then\_else (le (cc0)\
(const\_int 0))\
(label\_ref (match\_operand 0 "" ""))\
(pc)))]\
""\
"\*OUTPUT\_JUMP ("jle %l0", "jbe %l0", 0) ")

(define\_insn "bleu"\
\[(set (pc)\
(if\_then\_else (leu (cc0)\
(const\_int 0))\
(label\_ref (match\_operand 0 "" ""))\
(pc)))]\
""\
"jbe %l0")\
;; Negated conditional jump instructions.

(define\_insn ""\
\[(set (pc)\
(if\_then\_else (eq (cc0)\
(const\_int 0))\
(pc)\
(label\_ref (match\_operand 0 "" ""))))]\
""\
"jne %l0")

(define\_insn ""\
\[(set (pc)\
(if\_then\_else (ne (cc0)\
(const\_int 0))\
(pc)\
(label\_ref (match\_operand 0 "" ""))))]\
""\
"je %l0")

(define\_insn ""\
\[(set (pc)\
(if\_then\_else (gt (cc0)\
(const\_int 0))\
(pc)\
(label\_ref (match\_operand 0 "" ""))))]\
""\
"\*OUTPUT\_JUMP ("jle %l0", "jbe %l0", 0) ")

(define\_insn ""\
\[(set (pc)\
(if\_then\_else (gtu (cc0)\
(const\_int 0))\
(pc)\
(label\_ref (match\_operand 0 "" ""))))]\
""\
"jbe %l0")

(define\_insn ""\
\[(set (pc)\
(if\_then\_else (lt (cc0)\
(const\_int 0))\
(pc)\
(label\_ref (match\_operand 0 "" ""))))]\
""\
"\*OUTPUT\_JUMP ("jge %l0", "jae %l0", "jns %l0")\
")

(define\_insn ""\
\[(set (pc)\
(if\_then\_else (ltu (cc0)\
(const\_int 0))\
(pc)\
(label\_ref (match\_operand 0 "" ""))))]\
""\
"jae %l0")

(define\_insn ""\
\[(set (pc)\
(if\_then\_else (ge (cc0)\
(const\_int 0))\
(pc)\
(label\_ref (match\_operand 0 "" ""))))]\
""\
"\*OUTPUT\_JUMP ("jl %l0", "jb %l0", "js %l0")")

(define\_insn ""\
\[(set (pc)\
(if\_then\_else (geu (cc0)\
(const\_int 0))\
(pc)\
(label\_ref (match\_operand 0 "" ""))))]\
""\
"jb %l0")

(define\_insn ""\
\[(set (pc)\
(if\_then\_else (le (cc0)\
(const\_int 0))\
(pc)\
(label\_ref (match\_operand 0 "" ""))))]\
""\
"\*OUTPUT\_JUMP ("jg %l0", "ja %l0", 0)")

(define\_insn ""\
\[(set (pc)\
(if\_then\_else (leu (cc0)\
(const\_int 0))\
(pc)\
(label\_ref (match\_operand 0 "" ""))))]\
""\
"ja %l0")\
;; Unconditional and other jump instructions\
(define\_insn "jump"\
\[(set (pc)\
(label\_ref (match\_operand 0 "" "")))]\
""\
"jmp %l0")

(define\_insn "tablejump"\
\[(set (pc) (match\_operand:SI 0 "general\_operand" "rm"))\
(use (label\_ref (match\_operand 1 "" "")))]\
""\
"\*\
{\
CC\_STATUS\_INIT;

return "jmp %\*%0";\
}")

/\*\
(define\_insn ""\
\[(set (pc)\
(if\_then\_else\
(ne (compare (minus:HI (match\_operand:HI 0 "general\_operand" "c")\
(const\_int 1))\
(const\_int -1))\
(const\_int 0))\
(label\_ref (match\_operand 1 "" "g"))\
(pc)))\
(set (match\_dup 0)\
(minus:HI (match\_dup 0)\
(const\_int 1)))]\
""\
"loop %l1")

(define\_insn ""\
\[(set (pc)\
(if\_then\_else\
(ne (compare (const\_int -1)\
(minus:SI (match\_operand:SI 0 "general\_operand" "c")\
(const\_int 1)))\
(const\_int 0))\
(label\_ref (match\_operand 1 "" "g"))\
(pc)))\
(set (match\_dup 0)\
(minus:SI (match\_dup 0)\
(const\_int 1)))]\
""\
"loop %l1")\
\*/

;; Call subroutine returning no value.\
(define\_insn "call"\
\[(call (match\_operand:QI 0 "indirect\_operand" "m")\
(match\_operand:SI 1 "general\_operand" "g"))]\
;; Operand 1 not really used on the m68000.\
""\
"\*\
{\
if (GET\_CODE (operands\[0]) == MEM\
&& ! CONSTANT\_ADDRESS\_P (XEXP (operands\[0], 0)))\
{\
operands\[0] = XEXP (operands\[0], 0);\
return "call %\*%0";\
}\
else\
return "call %0";\
}")

;; Call subroutine, returning value in operand 0\
;; (which must be a hard register).\
(define\_insn "call\_value"\
\[(set (match\_operand 0 "" "=rf")\
(call (match\_operand:QI 1 "indirect\_operand" "m")\
(match\_operand:SI 2 "general\_operand" "g")))]\
;; Operand 2 not really used on the m68000.\
""\
"\*\
{\
if (GET\_CODE (operands\[1]) == MEM\
&& ! CONSTANT\_ADDRESS\_P (XEXP (operands\[1], 0)))\
{\
operands\[1] = XEXP (operands\[1], 0);\
output\_asm\_insn ("call %\*%1", operands);\
}\
else\
output\_asm\_insn ("call %1", operands);

if (GET\_MODE (operands\[0]) == DFmode\
|| GET\_MODE (operands\[0]) == SFmode)\
{\
/\* fp\_pop\_level++; _/_\
_/_ pop if reg dead \*/\
if (!FP\_REG\_P (operands\[0]))\
abort ();\
if (top\_dead\_p (insn))\
{\
POP\_ONE\_FP;\
}\
}\
RET;\
}")

(define\_insn "nop"\
\[(const\_int 0)]\
""\
"nop")\
;;- Local variables:\
;;- mode:emacs-lisp\
;;- comment-start: ";;- "\
;;- eval: (set-syntax-table (copy-sequence (syntax-table)))\
;;- eval: (modify-syntax-entry ?\[ "(]")\
;;- eval: (modify-syntax-entry ?] ")\[")\
;;- eval: (modify-syntax-entry ?{ "(}")\
;;- eval: (modify-syntax-entry ?} "){")\
;;- End:
