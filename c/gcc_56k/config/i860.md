# i860

;;- Machine description for Intel 860 chip for GNU C compiler\
;; Copyright (C) 1989 Free Software Foundation, Inc.

;; This file is part of GNU CC.

;; GNU CC is free software; you can redistribute it and/or modify\
;; it under the terms of the GNU General Public License as published by\
;; the Free Software Foundation; either version 1, or (at your option)\
;; any later version.

;; GNU CC is distributed in the hope that it will be useful,\
;; but WITHOUT ANY WARRANTY; without even the implied warranty of\
;; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\
;; GNU General Public License for more details.

;; You should have received a copy of the GNU General Public License\
;; along with GNU CC; see the file COPYING. If not, write to\
;; the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.

;;- See file "rtl.def" for documentation on define\_insn, match\_\*, et. al.

;;- cpp macro #define NOTICE\_UPDATE\_CC in file tm.h handles condition code\
;;- updates for most instructions.

;;- Operand classes for the register allocator:\
/\* Bit-test instructions. \*/

(define\_insn ""\
\[(set (cc0) (eq (and:SI (match\_operand:SI 0 "register\_operand" "r")\
(match\_operand:SI 1 "logic\_operand" "rL"))\
(const\_int 0)))]\
""\
"\*\
{\
cc\_status.flags |= CC\_ONLY\_EQ;\
return "and %1,%0,r0";\
}")

(define\_insn ""\
\[(set (cc0) (ne (and:SI (match\_operand:SI 0 "register\_operand" "r")\
(match\_operand:SI 1 "logic\_operand" "rL"))\
(const\_int 0)))]\
""\
"\*\
{\
cc\_status.flags |= CC\_NEGATED;\
cc\_status.flags |= CC\_ONLY\_EQ;\
return "and %1,%0,r0";\
}")

(define\_insn ""\
\[(set (cc0) (eq (and:SI (match\_operand:SI 0 "register\_operand" "r")\
(match\_operand:SI 1 "immediate\_operand" "i"))\
(const\_int 0)))]\
"GET\_CODE (operands\[1]) == CONST\_INT && (INTVAL (operands\[1]) & 0xffff) == 0"\
"\*\
{\
cc\_status.flags |= CC\_ONLY\_EQ;\
return "andh h%%%1,%0,r0";\
}")

(define\_insn ""\
\[(set (cc0) (ne (and:SI (match\_operand:SI 0 "register\_operand" "r")\
(match\_operand:SI 1 "immediate\_operand" "i"))\
(const\_int 0)))]\
"GET\_CODE (operands\[1]) == CONST\_INT && (INTVAL (operands\[1]) & 0xffff) == 0"\
"\*\
{\
cc\_status.flags |= CC\_NEGATED;\
cc\_status.flags |= CC\_ONLY\_EQ;\
return "andh h%%%1,%0,r0";\
}")

(define\_insn ""\
\[(set (cc0) (eq (ashiftrt:SI\
(sign\_extend:SI\
(ashift:QI (match\_operand:QI 0 "register\_operand" "r")\
(match\_operand:QI 1 "logic\_int" "n")))\
(match\_operand:SI 2 "logic\_int" "n"))\
(const\_int 0)))]\
""\
"\*\
{\
int width = 8 - INTVAL (operands\[2]);\
int pos = 8 - width - INTVAL (operands\[1]);\
operands\[2] = gen\_rtx (CONST\_INT, VOIDmode,\
\~((-1) << width) << pos);\
return "and %2,%0,r0";\
}")\
;; Compare instructions.\
;; This controls RTL generation and register allocation.

;; Put cmpsi first among compare insns so it matches two CONST\_INT operands.

(define\_insn "cmpeqsi"\
\[(set (cc0) (eq (match\_operand:SI 0 "logic\_operand" "r,rL")\
(match\_operand:SI 1 "logic\_operand" "L,r")))]\
""\
"\*\
{\
cc\_status.flags &= \~ CC\_CONDITION\_MASK;\
cc\_status.flags |= CC\_ONLY\_EQ;\
if (REG\_P (operands\[0]))\
return "xor %1,%0,r0";\
return "xor %0,%1,r0";\
}")

(define\_insn "cmpltsi"\
\[(set (cc0) (lt (match\_operand:SI 0 "arith\_operand" "r,rI")\
(match\_operand:SI 1 "arith\_operand" "I,r")))]\
""\
"\*\
{\
cc\_status.flags &= \~ CC\_CONDITION\_MASK;\
cc\_status.flags |= CC\_ONLY\_LT;\
if (REG\_P (operands\[1]))\
return "subs %0,%1,r0";\
cc\_status.flags |= CC\_REVERSED;\
operands\[1] = gen\_rtx (CONST\_INT, VOIDmode, - INTVAL (operands\[1]));\
return "adds %1,%0,r0";\
}")

(define\_insn "cmpgtsi"\
\[(set (cc0) (gt (match\_operand:SI 0 "arith\_operand" "r,rI")\
(match\_operand:SI 1 "arith\_operand" "I,r")))]\
""\
"\*\
{\
cc\_status.flags &= \~ CC\_CONDITION\_MASK;\
cc\_status.flags |= CC\_ONLY\_LT;\
if (REG\_P (operands\[0]))\
return "subs %1,%0,r0";\
cc\_status.flags |= CC\_REVERSED;\
operands\[0] = gen\_rtx (CONST\_INT, VOIDmode, - INTVAL (operands\[0]));\
return "adds %0,%1,r0";\
}")

(define\_insn "cmpgeusi"\
\[(set (cc0) (geu (match\_operand:SI 0 "arith\_operand" "r,rI")\
(match\_operand:SI 1 "arith\_operand" "I,r")))]\
""\
"\*\
{\
cc\_status.flags &= \~ CC\_CONDITION\_MASK;\
cc\_status.flags |= CC\_ONLY\_LEU;\
if (REG\_P (operands\[1]))\
return "subu %0,%1,r0";\
cc\_status.flags |= CC\_REVERSED;\
operands\[1] = gen\_rtx (CONST\_INT, VOIDmode, - INTVAL (operands\[1]));\
return "addu %1,%0,r0";\
}")

(define\_insn "cmpleusi"\
\[(set (cc0) (leu (match\_operand:SI 0 "arith\_operand" "r,rI")\
(match\_operand:SI 1 "arith\_operand" "I,r")))]\
""\
"\*\
{\
cc\_status.flags &= \~ CC\_CONDITION\_MASK;\
cc\_status.flags |= CC\_ONLY\_LEU;\
if (REG\_P (operands\[0]))\
return "subu %1,%0,r0";\
cc\_status.flags |= CC\_REVERSED;\
operands\[0] = gen\_rtx (CONST\_INT, VOIDmode, - INTVAL (operands\[0]));\
return "addu %0,%1,r0";\
}")

(define\_insn "cmpeqsf"\
\[(set (cc0) (eq (match\_operand:SF 0 "reg\_or\_0\_operand" "fG")\
(match\_operand:SF 1 "reg\_or\_0\_operand" "fG")))]\
""\
"\*\
{\
cc\_status.flags &= \~ CC\_CONDITION\_MASK;\
cc\_status.flags |= CC\_ONLY\_EQ;\
return "pfeq.s %r1,%r0,f0";\
}")

(define\_insn "cmpltsf"\
\[(set (cc0) (lt (match\_operand:SF 0 "reg\_or\_0\_operand" "fG")\
(match\_operand:SF 1 "reg\_or\_0\_operand" "fG")))]\
""\
"\*\
{\
cc\_status.flags &= \~ CC\_CONDITION\_MASK;\
cc\_status.flags |= CC\_ONLY\_LT;\
return "pfgt.s %r1,%r0,f0";\
}")

(define\_insn "cmpgtsf"\
\[(set (cc0) (gt (match\_operand:SF 0 "reg\_or\_0\_operand" "fG")\
(match\_operand:SF 1 "reg\_or\_0\_operand" "fG")))]\
""\
"\*\
{\
cc\_status.flags &= \~ CC\_CONDITION\_MASK;\
cc\_status.flags |= CC\_ONLY\_LT;\
return "pfgt.s %r0,%r1,f0";\
}")

(define\_insn "cmplesf"\
\[(set (cc0) (le (match\_operand:SF 0 "reg\_or\_0\_operand" "fG")\
(match\_operand:SF 1 "reg\_or\_0\_operand" "fG")))]\
""\
"\*\
{\
cc\_status.flags &= \~ CC\_CONDITION\_MASK;\
cc\_status.flags |= CC\_ONLY\_LE;\
return "pfle.s %r1,%r0,f0";\
}")

(define\_insn "cmpgesf"\
\[(set (cc0) (ge (match\_operand:SF 0 "reg\_or\_0\_operand" "fG")\
(match\_operand:SF 1 "reg\_or\_0\_operand" "fG")))]\
""\
"\*\
{\
cc\_status.flags &= \~ CC\_CONDITION\_MASK;\
cc\_status.flags |= CC\_ONLY\_LE;\
return "pfle.s %r0,%r1,f0";\
}")

(define\_insn "cmpeqdf"\
\[(set (cc0) (eq (match\_operand:DF 0 "reg\_or\_0\_operand" "fG")\
(match\_operand:DF 1 "reg\_or\_0\_operand" "fG")))]\
""\
"\*\
{\
cc\_status.flags &= \~ CC\_CONDITION\_MASK;\
cc\_status.flags |= CC\_ONLY\_EQ;\
return "pfeq.d %r1,%r0,f0";\
}")

(define\_insn "cmpltdf"\
\[(set (cc0) (lt (match\_operand:DF 0 "reg\_or\_0\_operand" "fG")\
(match\_operand:DF 1 "reg\_or\_0\_operand" "fG")))]\
""\
"\*\
{\
cc\_status.flags &= \~ CC\_CONDITION\_MASK;\
cc\_status.flags |= CC\_ONLY\_LT;\
return "pfgt.d %r1,%r0,f0";\
}")

(define\_insn "cmpgtdf"\
\[(set (cc0) (gt (match\_operand:DF 0 "reg\_or\_0\_operand" "fG")\
(match\_operand:DF 1 "reg\_or\_0\_operand" "fG")))]\
""\
"\*\
{\
cc\_status.flags &= \~ CC\_CONDITION\_MASK;\
cc\_status.flags |= CC\_ONLY\_LT;\
return "pfgt.d %r0,%r1,f0";\
}")

(define\_insn "cmpledf"\
\[(set (cc0) (le (match\_operand:DF 0 "reg\_or\_0\_operand" "fG")\
(match\_operand:DF 1 "reg\_or\_0\_operand" "fG")))]\
""\
"\*\
{\
cc\_status.flags &= \~ CC\_CONDITION\_MASK;\
cc\_status.flags |= CC\_ONLY\_LE;\
return "pfle.d %r1,%r0,f0";\
}")

(define\_insn "cmpgedf"\
\[(set (cc0) (ge (match\_operand:DF 0 "reg\_or\_0\_operand" "fG")\
(match\_operand:DF 1 "reg\_or\_0\_operand" "fG")))]\
""\
"\*\
{\
cc\_status.flags &= \~ CC\_CONDITION\_MASK;\
cc\_status.flags |= CC\_ONLY\_LE;\
return "pfle.d %r0,%r1,f0";\
}")

(define\_insn ""\
\[(set (cc0) (eq (zero\_extend:SI (match\_operand:HI 0 "load\_operand" "m"))\
(match\_operand:SI 1 "small\_int" "I")))]\
"INTVAL (operands\[1]) >= 0"\
"ld.s %0,r31;xor %1,r31,r0")

(define\_insn ""\
\[(set (cc0) (eq (match\_operand:SI 0 "small\_int" "I")\
(zero\_extend:SI (match\_operand:HI 1 "load\_operand" "m"))))]\
"INTVAL (operands\[0]) >= 0"\
"ld.s %1,r31;xor %0,r31,r0")\
;; Define the real conditional branch instructions.

(define\_insn "cbranch"\
\[(set (pc) (if\_then\_else (cc0) (label\_ref (match\_operand 0 "" "")) (pc)))]\
""\
"\*\
{\
if (cc\_prev\_status.flags & CC\_NEGATED)\
return "bnc %l0";\
else\
return "bc %l0";\
}")

(define\_insn "inverse\_cbranch"\
\[(set (pc) (if\_then\_else (cc0) (pc) (label\_ref (match\_operand 0 "" ""))))]\
""\
"\*\
{\
if (cc\_prev\_status.flags & CC\_NEGATED)\
return "bc %l0";\
else\
return "bnc %l0";\
}")

;; Other conditional branches, made by combining.

(define\_insn ""\
\[(set (pc) (if\_then\_else (eq (match\_operand:SI 0 "bte\_operand" "%rK")\
(match\_operand:SI 1 "bte\_operand" "rJ"))\
(label\_ref (match\_operand 2 "" ""))\
(pc)))]\
"GET\_CODE (operands\[0]) == REG || GET\_CODE (operands\[1]) == REG"\
"bte %0,%r1,%2")

(define\_insn ""\
\[(set (pc) (if\_then\_else (eq (match\_operand:SI 0 "bte\_operand" "%rK")\
(match\_operand:SI 1 "bte\_operand" "rJ"))\
(pc)\
(label\_ref (match\_operand 2 "" ""))))]\
"GET\_CODE (operands\[0]) == REG || GET\_CODE (operands\[1]) == REG"\
"btne %0,%r1,%2")

;; Optimize fetching an unsigned half word and comparing against constant.\
;; No need to zero-extend.

(define\_insn ""\
\[(set (pc) (if\_then\_else (eq (zero\_extend:SI (match\_operand:HI 0 "load\_operand" "m"))\
(match\_operand:SI 1 "immediate\_operand" "K"))\
(label\_ref (match\_operand 2 "" ""))\
(pc)))]\
"GET\_CODE (operands\[1]) == CONST\_INT\
&& INTVAL (operands\[1]) < 0x10 && INTVAL (operands\[1]) >= 0"\
"ld.s %0,r31;bte %1,r31,%2")

(define\_insn ""\
\[(set (pc) (if\_then\_else (eq (match\_operand:SI 0 "immediate\_operand" "K")\
(zero\_extend:SI (match\_operand:HI 1 "load\_operand" "m")))\
(label\_ref (match\_operand 2 "" ""))\
(pc)))]\
"GET\_CODE (operands\[0]) == CONST\_INT\
&& INTVAL (operands\[0]) < 0x10 && INTVAL (operands\[0]) >= 0"\
"ld.s %1,r31;bte %0,r31,%2")

(define\_insn ""\
\[(set (pc) (if\_then\_else (eq (zero\_extend:SI (match\_operand:HI 0 "load\_operand" "m"))\
(match\_operand:SI 1 "immediate\_operand" "K"))\
(pc)\
(label\_ref (match\_operand 2 "" ""))))]\
"GET\_CODE (operands\[1]) == CONST\_INT\
&& INTVAL (operands\[1]) < 0x10 && INTVAL (operands\[1]) >= 0"\
"ld.s %0,r31;btne %1,r31,%2")

(define\_insn ""\
\[(set (pc) (if\_then\_else (eq (match\_operand:SI 0 "immediate\_operand" "K")\
(zero\_extend:SI (match\_operand:HI 1 "load\_operand" "m")))\
(pc)\
(label\_ref (match\_operand 2 "" ""))))]\
"GET\_CODE (operands\[0]) == CONST\_INT\
&& INTVAL (operands\[0]) < 0x10 && INTVAL (operands\[0]) >= 0"\
"ld.s %1,r31;btne %0,r31,%2")

(define\_insn ""\
\[(set (pc) (if\_then\_else (eq (zero\_extend:SI (match\_operand:QI 0 "load\_operand" "m"))\
(match\_operand:SI 1 "immediate\_operand" "K"))\
(label\_ref (match\_operand 2 "" ""))\
(pc)))]\
"GET\_CODE (operands\[1]) == CONST\_INT\
&& INTVAL (operands\[1]) < 0x10 && INTVAL (operands\[1]) >= 0"\
"ld.b %0,r31;bte %1,r31,%2")

(define\_insn ""\
\[(set (pc) (if\_then\_else (eq (match\_operand:SI 0 "immediate\_operand" "K")\
(zero\_extend:SI (match\_operand:QI 1 "load\_operand" "m")))\
(label\_ref (match\_operand 2 "" ""))\
(pc)))]\
"GET\_CODE (operands\[0]) == CONST\_INT\
&& INTVAL (operands\[0]) < 0x10 && INTVAL (operands\[0]) >= 0"\
"ld.b %1,r31;bte %0,r31,%2")

(define\_insn ""\
\[(set (pc) (if\_then\_else (eq (zero\_extend:SI (match\_operand:QI 0 "load\_operand" "m"))\
(match\_operand:SI 1 "immediate\_operand" "K"))\
(pc)\
(label\_ref (match\_operand 2 "" ""))))]\
"GET\_CODE (operands\[1]) == CONST\_INT\
&& INTVAL (operands\[1]) < 0x10 && INTVAL (operands\[1]) >= 0"\
"ld.b %0,r31;btne %1,r31,%2")

(define\_insn ""\
\[(set (pc) (if\_then\_else (eq (match\_operand:SI 0 "immediate\_operand" "K")\
(zero\_extend:SI (match\_operand:QI 1 "load\_operand" "m")))\
(pc)\
(label\_ref (match\_operand 2 "" ""))))]\
"GET\_CODE (operands\[0]) == CONST\_INT\
&& INTVAL (operands\[0]) < 0x10 && INTVAL (operands\[0]) >= 0"\
"ld.b %1,r31;btne %0,r31,%2")\
;; Generation of conditionals.

;; The first step is the emission of a standard-looking compare insn.\
;; Then a standard-named conditional branch pattern is run.\
;; That branch pattern looks back at the compare insn and deletes it.\
;; It then emits a machine-specific compare insn and a branch-if-true\
;; or a branch-if-false.

;; These patterns have \`abort' because they are supposed to be deleted\
;; in that fashion.

(define\_insn "cmpsi"\
\[(set (cc0) (compare (match\_operand:SI 0 "compare\_operand" "")\
(match\_operand:SI 1 "compare\_operand" "")))]\
""\
"\* abort ();")

(define\_insn "cmpsf"\
\[(set (cc0) (compare (match\_operand:SF 0 "register\_operand" "")\
(match\_operand:SF 1 "register\_operand" "")))]\
""\
"\* abort ();")

(define\_insn "cmpdf"\
\[(set (cc0) (compare (match\_operand:DF 0 "register\_operand" "")\
(match\_operand:DF 1 "register\_operand" "")))]\
""\
"\* abort ();")

;; These are the standard-named conditional branch patterns.\
;; Detailed comments are found in the first one only.

(define\_expand "beq"\
\[(set (pc)\
(if\_then\_else (eq (cc0)\
(const\_int 0))\
(label\_ref (match\_operand 0 "" ""))\
(pc)))]\
""\
"\
{\
rtx label = operands\[0];\
enum insn\_code code;\
rtx prev;

/\* Get out of the sequence just started for us. \*/

end\_sequence ();\
prev = get\_last\_insn ();

/\* Examine the preceding compare insn, and get rid of it. \*/

code = recog\_memoized (prev);\
insn\_extract (prev);\
NEXT\_INSN (PREV\_INSN (prev)) = 0;\
set\_last\_insn (PREV\_INSN (prev));

/\* Now once again start a sequence for our new instructions. \*/

start\_sequence ();

/\* Emit a single-condition compare insn according to\
the type of operands and the condition to be tested. \*/

if (code == CODE\_FOR\_cmpsi)\
emit\_insn (gen\_cmpeqsi (recog\_operand\[0], recog\_operand\[1]));\
else if (code == CODE\_FOR\_cmpsf)\
emit\_insn (gen\_cmpeqsf (recog\_operand\[0], recog\_operand\[1]));\
else if (code == CODE\_FOR\_cmpdf)\
emit\_insn (gen\_cmpeqdf (recog\_operand\[0], recog\_operand\[1]));\
else\
abort ();

/\* Emit branch-if-true. \*/

emit\_jump\_insn (gen\_cbranch (label));

DONE;\
}")

(define\_expand "bne"\
\[(set (pc)\
(if\_then\_else (ne (cc0)\
(const\_int 0))\
(label\_ref (match\_operand 0 "" ""))\
(pc)))]\
""\
"\
{\
rtx label = operands\[0];\
enum insn\_code code;\
rtx prev;

end\_sequence ();\
prev = get\_last\_insn ();

code = recog\_memoized (prev);\
insn\_extract (prev);\
NEXT\_INSN (PREV\_INSN (prev)) = 0;\
set\_last\_insn (PREV\_INSN (prev));\
start\_sequence ();

if (code == CODE\_FOR\_cmpsi)\
emit\_insn (gen\_cmpeqsi (recog\_operand\[0], recog\_operand\[1]));\
else if (code == CODE\_FOR\_cmpsf)\
emit\_insn (gen\_cmpeqsf (recog\_operand\[0], recog\_operand\[1]));\
else if (code == CODE\_FOR\_cmpdf)\
emit\_insn (gen\_cmpeqdf (recog\_operand\[0], recog\_operand\[1]));\
else\
abort ();\
emit\_jump\_insn (gen\_inverse\_cbranch (label));

DONE;\
}")

(define\_expand "bgt"\
\[(set (pc)\
(if\_then\_else (gt (cc0)\
(const\_int 0))\
(label\_ref (match\_operand 0 "" ""))\
(pc)))]\
""\
"\
{\
rtx label = operands\[0];\
enum insn\_code code;\
rtx prev;

end\_sequence ();\
prev = get\_last\_insn ();

code = recog\_memoized (prev);\
insn\_extract (prev);\
NEXT\_INSN (PREV\_INSN (prev)) = 0;\
set\_last\_insn (PREV\_INSN (prev));\
start\_sequence ();

if (code == CODE\_FOR\_cmpsi)\
emit\_insn (gen\_cmpgtsi (recog\_operand\[0], recog\_operand\[1]));\
else if (code == CODE\_FOR\_cmpsf)\
emit\_insn (gen\_cmpgtsf (recog\_operand\[0], recog\_operand\[1]));\
else if (code == CODE\_FOR\_cmpdf)\
emit\_insn (gen\_cmpgtdf (recog\_operand\[0], recog\_operand\[1]));\
else\
abort ();\
emit\_jump\_insn (gen\_cbranch (label));\
DONE;\
}")

(define\_expand "blt"\
\[(set (pc)\
(if\_then\_else (lt (cc0)\
(const\_int 0))\
(label\_ref (match\_operand 0 "" ""))\
(pc)))]\
""\
"\
{\
rtx label = operands\[0];\
enum insn\_code code;\
rtx prev;

end\_sequence ();\
prev = get\_last\_insn ();

code = recog\_memoized (prev);\
insn\_extract (prev);\
NEXT\_INSN (PREV\_INSN (prev)) = 0;\
set\_last\_insn (PREV\_INSN (prev));\
start\_sequence ();

if (code == CODE\_FOR\_cmpsi)\
emit\_insn (gen\_cmpltsi (recog\_operand\[0], recog\_operand\[1]));\
else if (code == CODE\_FOR\_cmpsf)\
emit\_insn (gen\_cmpltsf (recog\_operand\[0], recog\_operand\[1]));\
else if (code == CODE\_FOR\_cmpdf)\
emit\_insn (gen\_cmpltdf (recog\_operand\[0], recog\_operand\[1]));\
else\
abort ();\
emit\_jump\_insn (gen\_cbranch (label));\
DONE;\
}")

(define\_expand "ble"\
\[(set (pc)\
(if\_then\_else (le (cc0)\
(const\_int 0))\
(label\_ref (match\_operand 0 "" ""))\
(pc)))]\
""\
"\
{\
rtx label = operands\[0];\
enum insn\_code code;\
rtx prev;

end\_sequence ();\
prev = get\_last\_insn ();

code = recog\_memoized (prev);\
insn\_extract (prev);\
NEXT\_INSN (PREV\_INSN (prev)) = 0;\
set\_last\_insn (PREV\_INSN (prev));\
start\_sequence ();

if (code == CODE\_FOR\_cmpsi)\
{\
emit\_insn (gen\_cmpgtsi (recog\_operand\[0], recog\_operand\[1]));\
emit\_jump\_insn (gen\_inverse\_cbranch (label));\
}\
else\
{\
if (code == CODE\_FOR\_cmpsf)\
emit\_insn (gen\_cmplesf (recog\_operand\[0], recog\_operand\[1]));\
else if (code == CODE\_FOR\_cmpdf)\
emit\_insn (gen\_cmpledf (recog\_operand\[0], recog\_operand\[1]));\
else\
abort ();\
emit\_jump\_insn (gen\_cbranch (label));\
}\
DONE;\
}")

(define\_expand "bge"\
\[(set (pc)\
(if\_then\_else (ge (cc0)\
(const\_int 0))\
(label\_ref (match\_operand 0 "" ""))\
(pc)))]\
""\
"\
{\
rtx label = operands\[0];\
enum insn\_code code;\
rtx prev;

end\_sequence ();\
prev = get\_last\_insn ();

code = recog\_memoized (prev);\
insn\_extract (prev);\
NEXT\_INSN (PREV\_INSN (prev)) = 0;\
set\_last\_insn (PREV\_INSN (prev));\
start\_sequence ();

if (code == CODE\_FOR\_cmpsi)\
{\
emit\_insn (gen\_cmpltsi (recog\_operand\[0], recog\_operand\[1]));\
emit\_jump\_insn (gen\_inverse\_cbranch (label));\
}\
else\
{\
if (code == CODE\_FOR\_cmpsf)\
emit\_insn (gen\_cmpgesf (recog\_operand\[0], recog\_operand\[1]));\
else if (code == CODE\_FOR\_cmpdf)\
emit\_insn (gen\_cmpgedf (recog\_operand\[0], recog\_operand\[1]));\
else\
abort ();\
emit\_jump\_insn (gen\_cbranch (label));\
}\
DONE;\
}")

(define\_expand "bgtu"\
\[(set (pc)\
(if\_then\_else (gtu (cc0)\
(const\_int 0))\
(label\_ref (match\_operand 0 "" ""))\
(pc)))]\
""\
"\
{\
rtx label = operands\[0];\
enum insn\_code code;\
rtx prev;

end\_sequence ();\
prev = get\_last\_insn ();

code = recog\_memoized (prev);\
insn\_extract (prev);\
NEXT\_INSN (PREV\_INSN (prev)) = 0;\
set\_last\_insn (PREV\_INSN (prev));\
start\_sequence ();

if (code == CODE\_FOR\_cmpsi)\
emit\_insn (gen\_cmpleusi (recog\_operand\[0], recog\_operand\[1]));\
else\
abort ();\
emit\_jump\_insn (gen\_inverse\_cbranch (label));\
DONE;\
}")

(define\_expand "bltu"\
\[(set (pc)\
(if\_then\_else (ltu (cc0)\
(const\_int 0))\
(label\_ref (match\_operand 0 "" ""))\
(pc)))]\
""\
"\
{\
rtx label = operands\[0];\
enum insn\_code code;\
rtx prev;

end\_sequence ();\
prev = get\_last\_insn ();

code = recog\_memoized (prev);\
insn\_extract (prev);\
NEXT\_INSN (PREV\_INSN (prev)) = 0;\
set\_last\_insn (PREV\_INSN (prev));\
start\_sequence ();

if (code == CODE\_FOR\_cmpsi)\
emit\_insn (gen\_cmpgeusi (recog\_operand\[0], recog\_operand\[1]));\
else\
abort ();\
emit\_jump\_insn (gen\_inverse\_cbranch (label));\
DONE;\
}")

(define\_expand "bgeu"\
\[(set (pc)\
(if\_then\_else (geu (cc0)\
(const\_int 0))\
(label\_ref (match\_operand 0 "" ""))\
(pc)))]\
""\
"\
{\
rtx label = operands\[0];\
enum insn\_code code;\
rtx prev;

end\_sequence ();\
prev = get\_last\_insn ();

code = recog\_memoized (prev);\
insn\_extract (prev);\
NEXT\_INSN (PREV\_INSN (prev)) = 0;\
set\_last\_insn (PREV\_INSN (prev));\
start\_sequence ();

if (code == CODE\_FOR\_cmpsi)\
emit\_insn (gen\_cmpgeusi (recog\_operand\[0], recog\_operand\[1]));\
else\
abort ();\
emit\_jump\_insn (gen\_cbranch (label));\
DONE;\
}")

(define\_expand "bleu"\
\[(set (pc)\
(if\_then\_else (leu (cc0)\
(const\_int 0))\
(label\_ref (match\_operand 0 "" ""))\
(pc)))]\
""\
"\
{\
rtx label = operands\[0];\
enum insn\_code code;\
rtx prev;

end\_sequence ();\
prev = get\_last\_insn ();

code = recog\_memoized (prev);\
insn\_extract (prev);\
NEXT\_INSN (PREV\_INSN (prev)) = 0;\
set\_last\_insn (PREV\_INSN (prev));\
start\_sequence ();

if (code == CODE\_FOR\_cmpsi)\
emit\_insn (gen\_cmpleusi (recog\_operand\[0], recog\_operand\[1]));\
else\
abort ();\
emit\_jump\_insn (gen\_cbranch (label));\
DONE;\
}")\
;; Move instructions

(define\_insn "movsi"\
\[(set (match\_operand:SI 0 "general\_operand" "=r,m,f")\
(match\_operand:SI 1 "general\_operand" "rmif,rfJ,rmfJ"))]\
""\
"\*\
{\
if (GET\_CODE (operands\[0]) == MEM)\
{\
if (CONSTANT\_ADDRESS\_P (XEXP (operands\[0], 0)))\
return output\_store (operands);\
if (FP\_REG\_P (operands\[1]))\
return "fst.l %1,%0";\
return "st.l %r1,%0";\
}\
if (GET\_CODE (operands\[1]) == MEM)\
{\
if (CONSTANT\_ADDRESS\_P (XEXP (operands\[1], 0)))\
return output\_load (operands);\
if (FP\_REG\_P (operands\[0]))\
return "fld.l %1,%0";\
return "ld.l %1,%0";\
}\
if (FP\_REG\_P (operands\[1]) && FP\_REG\_P (operands\[0]))\
return "fmov.ss %1,%0";\
if (FP\_REG\_P (operands\[1]))\
return "fxfr %1,%0";\
if (FP\_REG\_P (operands\[0]) && operands\[1] == const0\_rtx)\
return "fmov.ss f0,%0";\
if (FP\_REG\_P (operands\[0]))\
return "ixfr %1,%0";\
return "mov %1,%0";\
}")

(define\_insn "movhi"\
\[(set (match\_operand:HI 0 "general\_operand" "=r,m,!_f,!r")_\
_(match\_operand:HI 1 "general\_operand" "rmi,rJ,r&#x4A;_&#x66;,_f"))]_\
_""_\
_"_\
{\
if (GET\_CODE (operands\[0]) == MEM)\
{\
if (CONSTANT\_ADDRESS\_P (XEXP (operands\[0], 0)))\
return output\_store (operands);\
return "st.s %r1,%0";\
}\
if (GET\_CODE (operands\[1]) == MEM)\
{\
if (CONSTANT\_ADDRESS\_P (XEXP (operands\[1], 0)))\
return output\_load (operands);\
return "ld.s %1,%0";\
}\
if (FP\_REG\_P (operands\[1]) && FP\_REG\_P (operands\[0]))\
return "fmov.ss %1,%0";\
if (FP\_REG\_P (operands\[1]))\
return "fxfr %1,%0";\
if (FP\_REG\_P (operands\[0]) && operands\[1] == const0\_rtx)\
return "fmov.ss f0,%0";\
if (FP\_REG\_P (operands\[0]))\
return "ixfr %1,%0";\
return "mov %1,%0";\
}")

(define\_insn "movqi"\
\[(set (match\_operand:QI 0 "general\_operand" "=r,m,!_f,!r")_\
_(match\_operand:QI 1 "general\_operand" "rmi,rJ,r&#x4A;_&#x66;,_f"))]_\
_""_\
_"_\
{\
if (GET\_CODE (operands\[0]) == MEM)\
{\
if (CONSTANT\_ADDRESS\_P (XEXP (operands\[0], 0)))\
return output\_store (operands);\
return "st.b %r1,%0";\
}\
if (GET\_CODE (operands\[1]) == MEM)\
{\
if (CONSTANT\_ADDRESS\_P (XEXP (operands\[1], 0)))\
return output\_load (operands);\
return "ld.b %1,%0";\
}\
if (FP\_REG\_P (operands\[1]) && FP\_REG\_P (operands\[0]))\
return "fmov.ss %1,%0";\
if (FP\_REG\_P (operands\[1]))\
return "fxfr %1,%0";\
if (FP\_REG\_P (operands\[0]) && operands\[1] == const0\_rtx)\
return "fmov.ss f0,%0";\
if (FP\_REG\_P (operands\[0]))\
return "ixfr %1,%0";\
return "mov %1,%0";\
}")

;; The definition of this insn does not really explain what it does,\
;; but it should suffice\
;; that anything generated as this insn will be recognized as one\
;; and that it won't successfully combine with anything.\
(define\_expand "movstrsi"\
\[(parallel \[(set (mem:BLK (match\_operand:BLK 0 "general\_operand" ""))\
(mem:BLK (match\_operand:BLK 1 "general\_operand" "")))\
(use (match\_operand:SI 2 "nonmemory\_operand" ""))\
(use (match\_operand:SI 3 "immediate\_operand" ""))\
(clobber (match\_dup 4))\
(clobber (match\_dup 5))\
(clobber (match\_dup 6))\
(clobber (match\_dup 0))\
(clobber (match\_dup 1))])]\
""\
"\
{\
operands\[0] = copy\_to\_mode\_reg (SImode, XEXP (operands\[0], 0));\
operands\[1] = copy\_to\_mode\_reg (SImode, XEXP (operands\[1], 0));\
operands\[4] = gen\_reg\_rtx (SImode);\
operands\[5] = gen\_reg\_rtx (SImode);\
operands\[6] = gen\_reg\_rtx (SImode);\
}")

(define\_insn ""\
\[(set (mem:BLK (match\_operand:SI 0 "register\_operand" "r"))\
(mem:BLK (match\_operand:SI 1 "register\_operand" "r")))\
(use (match\_operand:SI 2 "nonmemory\_operand" "rn"))\
(use (match\_operand:SI 3 "immediate\_operand" "i"))\
(clobber (match\_operand:SI 4 "register\_operand" "=r"))\
(clobber (match\_operand:SI 5 "register\_operand" "=r"))\
(clobber (match\_operand:SI 6 "register\_operand" "=r"))\
(clobber (match\_dup 0))\
(clobber (match\_dup 1))]\
""\
"\* return output\_block\_move (operands);")\
;; Floating point move insns

;; This pattern forces (set (reg:DF ...) (const\_double ...))\
;; to be reloaded by putting the constant into memory.\
;; It must come before the more general movdf pattern.\
(define\_insn ""\
\[(set (match\_operand:DF 0 "general\_operand" "=r,f,o")\
(match\_operand:DF 1 "" "mG,m,G"))]\
"GET\_CODE (operands\[1]) == CONST\_DOUBLE"\
"\*\
{\
if (FP\_REG\_P (operands\[0]))\
return output\_fp\_move\_double (operands);\
if (operands\[1] == dconst0\_rtx && GET\_CODE (operands\[0]) == REG)\
{\
operands\[1] = gen\_rtx (REG, SImode, REGNO (operands\[0]) + 1);\
return "mov r0,%0;mov r0,%1";\
}\
if (operands\[1] == dconst0\_rtx && GET\_CODE (operands\[0]) == MEM)\
{\
if (CONSTANT\_ADDRESS\_P (XEXP (operands\[0], 0)))\
{\
if (! ((cc\_prev\_status.flags & CC\_KNOW\_HI\_R31)\
&& (cc\_prev\_status.flags & CC\_HI\_R31\_ADJ)\
&& XEXP (operands\[0], 0) == cc\_prev\_status.mdep))\
{\
cc\_status.flags |= CC\_KNOW\_HI\_R31 | CC\_HI\_R31\_ADJ;\
cc\_status.mdep = XEXP (operands\[0], 0);\
output\_asm\_insn ("orh ha%%%m0,r0,r31", operands);\
}\
return "st.l r0,l%%%m0(r31);st.l r0,l%%%m0+4(r31)";\
}\
operands\[1] = adj\_offsettable\_operand (operands\[0], 4);\
return "st.l r0,%0;st.l r0,%1";\
}\
return output\_move\_double (operands);\
}")

(define\_insn "movdf"\
\[(set (match\_operand:DF 0 "general\_operand" "=\*rm,&\*r,?f,?\*rm")\
(match\_operand:DF 1 "general\_operand" "\*r,m,_rfmG,f"))]_\
_""_\
_"_\
{\
if (GET\_CODE (operands\[0]) == MEM\
&& CONSTANT\_ADDRESS\_P (XEXP (operands\[0], 0)))\
return output\_store (operands);\
if (GET\_CODE (operands\[1]) == MEM\
&& CONSTANT\_ADDRESS\_P (XEXP (operands\[1], 0)))\
return output\_load (operands);

if (FP\_REG\_P (operands\[0]) || FP\_REG\_P (operands\[1]))\
return output\_fp\_move\_double (operands);\
return output\_move\_double (operands);\
}")

(define\_insn "movdi"\
\[(set (match\_operand:DI 0 "general\_operand" "=rm,\&r,?f,?rm")\
(match\_operand:DI 1 "general\_operand" "r,miF,rfmG,f"))]\
""\
"\*\
{\
if (GET\_CODE (operands\[0]) == MEM\
&& CONSTANT\_ADDRESS\_P (XEXP (operands\[0], 0)))\
return output\_store (operands);\
if (GET\_CODE (operands\[1]) == MEM\
&& CONSTANT\_ADDRESS\_P (XEXP (operands\[1], 0)))\
return output\_load (operands);

if (FP\_REG\_P (operands\[0]) && operands\[1] == dconst0\_rtx)\
return "fmov.dd f0,%0";

if (FP\_REG\_P (operands\[0]) || FP\_REG\_P (operands\[1]))\
return output\_fp\_move\_double (operands);\
return output\_move\_double (operands);\
}")

;; The alternative m/r is separate from m/f\
;; so that an f-reg won't be used as a reload reg between m and F.\
;; The first alternative is separate from the second for the same reason.\
(define\_insn "movsf"\
\[(set (match\_operand:SF 0 "general\_operand" "=\*rf,\*rf,\*r,m,m")\
(match\_operand:SF 1 "general\_operand" "\*r,fmG,F,_r,f"))]_\
_""_\
_"_\
{\
if (GET\_CODE (operands\[0]) == MEM\
&& CONSTANT\_ADDRESS\_P (XEXP (operands\[0], 0)))\
return output\_store (operands);\
if (GET\_CODE (operands\[1]) == MEM\
&& CONSTANT\_ADDRESS\_P (XEXP (operands\[1], 0)))\
return output\_load (operands);\
if (FP\_REG\_P (operands\[0]))\
{\
if (FP\_REG\_P (operands\[1]))\
return "fmov.ss %1,%0";\
if (GET\_CODE (operands\[1]) == REG)\
return "ixfr %1,%0";\
if (operands\[1] == fconst0\_rtx)\
return "fmov.ss f0,%0";\
if (CONSTANT\_ADDRESS\_P (XEXP (operands\[1], 0)))\
{\
cc\_status.flags |= CC\_KNOW\_HI\_R31 | CC\_HI\_R31\_ADJ;\
cc\_status.mdep = XEXP (operands\[1], 0);\
return "orh ha%%%m1,r0,r31;fld.l l%%%m1(r31),%0";\
}\
return "fld.l %1,%0";\
}\
if (FP\_REG\_P (operands\[1]))\
{\
if (GET\_CODE (operands\[0]) == REG)\
return "fxfr %1,%0";\
if (CONSTANT\_ADDRESS\_P (XEXP (operands\[0], 0)))\
{\
if (! ((cc\_prev\_status.flags & CC\_KNOW\_HI\_R31)\
&& (cc\_prev\_status.flags & CC\_HI\_R31\_ADJ)\
&& XEXP (operands\[0], 0) == cc\_prev\_status.mdep))\
{\
cc\_status.flags |= CC\_KNOW\_HI\_R31 | CC\_HI\_R31\_ADJ;\
cc\_status.mdep = XEXP (operands\[0], 0);\
output\_asm\_insn ("orh ha%%%m0,r0,r31", operands);\
}\
return "fst.l %r1,l%%%m0(r31)";\
}\
return "fst.l %r1,%0";\
}\
if (GET\_CODE (operands\[0]) == MEM)\
return "st.l %r1,%0";\
if (GET\_CODE (operands\[1]) == MEM)\
return "ld.l %1,%0";\
if (operands\[1] == fconst0\_rtx)\
return "mov r0,%0";\
return "mov %1,%0";\
}")\
;; Special load insns for REG+REG addresses.\
;; Such addresses are not "legitimate" because st rejects them.

(define\_insn ""\
\[(set (match\_operand:DF 0 "register\_operand" "rf")\
(match\_operand:DF 1 "indexed\_operand" "m"))]\
""\
"\*\
{\
if (FP\_REG\_P (operands\[0]))\
return output\_fp\_move\_double (operands);\
return output\_move\_double (operands);\
}")

(define\_insn ""\
\[(set (match\_operand:SF 0 "register\_operand" "rf")\
(match\_operand:SF 1 "indexed\_operand" "m"))]\
""\
"\*\
{\
if (FP\_REG\_P (operands\[0]))\
return "fld.l %1,%0";\
return "ld.l %1,%0";\
}")

(define\_insn ""\
\[(set (match\_operand:SI 0 "register\_operand" "rf")\
(match\_operand:SI 1 "indexed\_operand" "m"))]\
""\
"\*\
{\
if (FP\_REG\_P (operands\[0]))\
return "fld.l %1,%0";\
return "ld.l %1,%0";\
}")

(define\_insn ""\
\[(set (match\_operand:HI 0 "register\_operand" "r")\
(match\_operand:HI 1 "indexed\_operand" "m"))]\
""\
"ld.s %1,%0")

(define\_insn ""\
\[(set (match\_operand:QI 0 "register\_operand" "r")\
(match\_operand:QI 1 "indexed\_operand" "m"))]\
""\
"ld.b %1,%0")

;; Likewise for floating-point store insns.

(define\_insn ""\
\[(set (match\_operand:DF 0 "indexed\_operand" "m")\
(match\_operand:DF 1 "register\_operand" "f"))]\
""\
"fst.d %1,%0")

(define\_insn ""\
\[(set (match\_operand:SF 0 "indexed\_operand" "m")\
(match\_operand:SF 1 "register\_operand" "f"))]\
""\
"fst.l %1,%0")\
;;- truncation instructions\
(define\_insn "truncsiqi2"\
\[(set (match\_operand:QI 0 "general\_operand" "=g")\
(truncate:QI\
(match\_operand:SI 1 "register\_operand" "r")))]\
""\
"\*\
{\
if (GET\_CODE (operands\[0]) == MEM)\
if (CONSTANT\_ADDRESS\_P (XEXP (operands\[0], 0)))\
{\
if (! ((cc\_prev\_status.flags & CC\_KNOW\_HI\_R31)\
&& (cc\_prev\_status.flags & CC\_HI\_R31\_ADJ)\
&& XEXP (operands\[0], 0) == cc\_prev\_status.mdep))\
{\
cc\_status.flags |= CC\_KNOW\_HI\_R31 | CC\_HI\_R31\_ADJ;\
cc\_status.mdep = XEXP (operands\[0], 0);\
output\_asm\_insn ("orh ha%%%m0,r0,r31", operands);\
}\
return "st.b %1,l%%%m0(r31)";\
}\
else\
return "st.b %1,%0";\
return "mov %1,%0";\
}")

(define\_insn "trunchiqi2"\
\[(set (match\_operand:QI 0 "general\_operand" "=g")\
(truncate:QI\
(match\_operand:HI 1 "register\_operand" "r")))]\
""\
"\*\
{\
if (GET\_CODE (operands\[0]) == MEM)\
if (CONSTANT\_ADDRESS\_P (XEXP (operands\[0], 0)))\
{\
if (! ((cc\_prev\_status.flags & CC\_KNOW\_HI\_R31)\
&& (cc\_prev\_status.flags & CC\_HI\_R31\_ADJ)\
&& XEXP (operands\[0], 0) == cc\_prev\_status.mdep))\
{\
cc\_status.flags |= CC\_KNOW\_HI\_R31 | CC\_HI\_R31\_ADJ;\
cc\_status.mdep = XEXP (operands\[0], 0);\
output\_asm\_insn ("orh ha%%%m0,r0,r31", operands);\
}\
return "st.b %1,l%%%m0(r31)";\
}\
else\
return "st.b %1,%0";\
return "mov %1,%0";\
}")

(define\_insn "truncsihi2"\
\[(set (match\_operand:HI 0 "general\_operand" "=g")\
(truncate:HI\
(match\_operand:SI 1 "register\_operand" "r")))]\
""\
"\*\
{\
if (GET\_CODE (operands\[0]) == MEM)\
if (CONSTANT\_ADDRESS\_P (XEXP (operands\[0], 0)))\
{\
if (! ((cc\_prev\_status.flags & CC\_KNOW\_HI\_R31)\
&& (cc\_prev\_status.flags & CC\_HI\_R31\_ADJ)\
&& XEXP (operands\[0], 0) == cc\_prev\_status.mdep))\
{\
cc\_status.flags |= CC\_KNOW\_HI\_R31 | CC\_HI\_R31\_ADJ;\
cc\_status.mdep = XEXP (operands\[0], 0);\
output\_asm\_insn ("orh ha%%%m0,r0,r31", operands);\
}\
return "st.s %1,l%%%m0(r31)";\
}\
else\
return "st.s %1,%0";\
return "mov %1,%0";\
}")\
;;- zero extension instructions

;; Note that the one starting from HImode comes before those for QImode\
;; so that a constant operand will match HImode, not QImode.

(define\_insn "zero\_extendhisi2"\
\[(set (match\_operand:SI 0 "register\_operand" "=r")\
(zero\_extend:SI\
(match\_operand:HI 1 "register\_operand" "r")))]\
""\
"and 0xffff,%1,%0")

(define\_insn "zero\_extendqihi2"\
\[(set (match\_operand:HI 0 "register\_operand" "=r")\
(zero\_extend:HI\
(match\_operand:QI 1 "register\_operand" "r")))]\
""\
"and 0xff,%1,%0")

(define\_insn "zero\_extendqisi2"\
\[(set (match\_operand:SI 0 "register\_operand" "=r")\
(zero\_extend:SI\
(match\_operand:QI 1 "register\_operand" "r")))]\
""\
"and 0xff,%1,%0")\
;;- sign extension instructions\
;; Note that the one starting from HImode comes before those for QImode\
;; so that a constant operand will match HImode, not QImode.

(define\_insn "extendhisi2"\
\[(set (match\_operand:SI 0 "register\_operand" "=r")\
(sign\_extend:SI\
(match\_operand:HI 1 "general\_operand" "mr")))]\
""\
"\*\
{\
if (REG\_P (operands\[1]))\
return "shl 16,%1,%0;shra 16,%0,%0";\
if (GET\_CODE (operands\[1]) == CONST\_INT)\
abort ();\
if (CONSTANT\_ADDRESS\_P (XEXP (operands\[1], 0)))\
{\
cc\_status.flags |= CC\_KNOW\_HI\_R31 | CC\_HI\_R31\_ADJ;\
cc\_status.mdep = XEXP (operands\[1], 0);\
return "orh ha%%%m1,r0,r31;ld.s l%%%m1(r31),%0";\
}\
else\
return "ld.s %1,%0";\
}")

(define\_insn "extendqihi2"\
\[(set (match\_operand:HI 0 "register\_operand" "=r")\
(sign\_extend:HI\
(match\_operand:QI 1 "general\_operand" "mr")))]\
""\
"\*\
{\
if (REG\_P (operands\[1]))\
return "shl 24,%1,%0;shra 24,%0,%0";\
if (GET\_CODE (operands\[1]) == CONST\_INT)\
abort ();\
if (CONSTANT\_ADDRESS\_P (XEXP (operands\[1], 0)))\
{\
cc\_status.flags |= CC\_KNOW\_HI\_R31 | CC\_HI\_R31\_ADJ;\
cc\_status.mdep = XEXP (operands\[1], 0);\
return "orh ha%%%m1,r0,r31;ld.b l%%%m1(r31),%0";\
}\
else\
return "ld.b %1,%0";\
}")

(define\_insn "extendqisi2"\
\[(set (match\_operand:SI 0 "register\_operand" "=r")\
(sign\_extend:SI\
(match\_operand:QI 1 "general\_operand" "mr")))]\
""\
"\*\
{\
if (REG\_P (operands\[1]))\
return "shl 24,%1,%0;shra 24,%0,%0";\
if (GET\_CODE (operands\[1]) == CONST\_INT)\
abort ();\
if (CONSTANT\_ADDRESS\_P (XEXP (operands\[1], 0)))\
{\
cc\_status.flags |= CC\_KNOW\_HI\_R31 | CC\_HI\_R31\_ADJ;\
cc\_status.mdep = XEXP (operands\[1], 0);\
return "orh ha%%%m1,r0,r31;ld.b l%%%m1(r31),%0";\
}\
else\
return "ld.b %1,%0";\
}")

(define\_insn ""\
\[(set (match\_operand:SI 0 "register\_operand" "=r")\
(sign\_extend:SI\
(match\_operand:HI 1 "indexed\_operand" "m")))]\
""\
"ld.s %1,%0")

(define\_insn ""\
\[(set (match\_operand:HI 0 "register\_operand" "=r")\
(sign\_extend:HI\
(match\_operand:QI 1 "indexed\_operand" "m")))]\
""\
"ld.b %1,%0")

(define\_insn ""\
\[(set (match\_operand:SI 0 "register\_operand" "=r")\
(sign\_extend:SI\
(match\_operand:QI 1 "indexed\_operand" "m")))]\
""\
"ld.b %1,%0")

;; Signed bitfield extractions come out looking like\
;; (shiftrt (sign\_extend (shift )) )\
;; which we expand poorly as four shift insns.\
;; These patters yeild two shifts:\
;; (shiftrt (shift ) )\
(define\_insn ""\
\[(set (match\_operand:SI 0 "register\_operand" "=r")\
(ashiftrt:SI\
(sign\_extend:SI\
(match\_operand:QI 1 "register\_operand" "r"))\
(match\_operand:SI 2 "logic\_int" "n")))]\
""\
"\*\
{\
return "shl 24,%1,%0;shra 24+%2,%0,%0";\
}")

(define\_insn ""\
\[(set (match\_operand:SI 0 "register\_operand" "=r")\
(ashiftrt:SI\
(sign\_extend:SI\
(subreg:QI (ashift:SI (match\_operand:SI 1 "register\_operand" "r")\
(match\_operand:SI 2 "logic\_int" "n")) 0))\
(match\_operand:SI 3 "logic\_int" "n")))]\
""\
"\*\
{\
return "shl 0x18+%2,%1,%0;shra 0x18+%3,%0,%0";\
}")

(define\_insn ""\
\[(set (match\_operand:SI 0 "register\_operand" "=r")\
(ashiftrt:SI\
(sign\_extend:SI\
(ashift:QI (match\_operand:QI 1 "register\_operand" "r")\
(match\_operand:QI 2 "logic\_int" "n")))\
(match\_operand:SI 3 "logic\_int" "n")))]\
""\
"\*\
{\
return "shl 0x18+%2,%1,%0;shra 0x18+%3,%0,%0";\
}")\
;; Special patterns for optimizing bit-field instructions.

;; First two patterns are for bitfields that came from memory\
;; testing only the high bit. They work with old combiner.

(define\_insn ""\
\[(set (cc0)\
(eq (zero\_extend:SI (subreg:QI (lshiftrt:SI (match\_operand:SI 0 "register\_operand" "r")\
(const\_int 7)) 0))\
(const\_int 0)))]\
""\
"and 128,%0,r0")

(define\_insn ""\
\[(set (cc0)\
(eq (sign\_extend:SI (subreg:QI (ashiftrt:SI (match\_operand:SI 0 "register\_operand" "r")\
(const\_int 7)) 0))\
(const\_int 0)))]\
""\
"and 128,%0,r0")

;; next two patterns are good for bitfields coming from memory\
;; (via pseudo-register) or from a register, though this optimization\
;; is only good for values contained wholly within the bottom 13 bits\
(define\_insn ""\
\[(set (cc0)\
(eq\
(and:SI (lshiftrt:SI (match\_operand:SI 0 "register\_operand" "r")\
(match\_operand:SI 1 "logic\_int" "n"))\
(match\_operand:SI 2 "logic\_int" "n"))\
(const\_int 0)))]\
"LOGIC\_INTVAL (INTVAL (operands\[2]) << INTVAL (operands\[1]))"\
"\*\
{\
operands\[2] = gen\_rtx (CONST\_INT, VOIDmode,\
(INTVAL (operands\[2]) << INTVAL (operands\[1])));\
return "and %2,%0,r0";\
}")

(define\_insn ""\
\[(set (cc0)\
(eq\
(and:SI (ashiftrt:SI (match\_operand:SI 0 "register\_operand" "r")\
(match\_operand:SI 1 "logic\_int" "n"))\
(match\_operand:SI 2 "logic\_int" "n"))\
(const\_int 0)))]\
"LOGIC\_INTVAL (INTVAL (operands\[2]) << INTVAL (operands\[1]))"\
"\*\
{\
operands\[2] = gen\_rtx (CONST\_INT, VOIDmode,\
(INTVAL (operands\[2]) << INTVAL (operands\[1])));\
return "and %2,%0,r0";\
}")\
;; Conversions between float and double.

(define\_insn "extendsfdf2"\
\[(set (match\_operand:DF 0 "register\_operand" "=f")\
(float\_extend:DF\
(match\_operand:SF 1 "register\_operand" "f")))]\
""\
"fmov.sd %1,%0")

(define\_insn "truncdfsf2"\
\[(set (match\_operand:SF 0 "register\_operand" "=f")\
(float\_truncate:SF\
(match\_operand:DF 1 "register\_operand" "f")))]\
""\
"fmov.ds %1,%0")\
;; Conversion between fixed point and floating point.\
;; Note that among the fix-to-float insns\
;; the ones that start with SImode come first.\
;; That is so that an operand that is a CONST\_INT\
;; (and therefore lacks a specific machine mode).\
;; will be recognized as SImode (which is always valid)\
;; rather than as QImode or HImode.

(define\_expand "floatsidf2"\
\[(set (match\_dup 2) (match\_dup 3))\
(set (match\_dup 4) (xor:SI (match\_operand:SI 1 "register\_operand" "")\
(const\_int -2147483648)))\
(set (subreg:SI (match\_dup 5) 0) (match\_dup 4))\
(set (subreg:SI (match\_dup 5) 1) (subreg:SI (match\_dup 2) 1))\
(set (match\_operand:DF 0 "register\_operand" "")\
(minus:DF (match\_dup 5) (match\_dup 2)))]\
""\
"\
{\
/\* Generate desired value, in float format of host machine. \*/\
double d = (double) (1 << 30) \* ((double) (1 << 22) + (double) (1 << 1));\
operands\[2] = gen\_reg\_rtx (DFmode);\
operands\[3] = immed\_double\_const (d, DFmode);\
operands\[4] = gen\_reg\_rtx (SImode);\
operands\[5] = gen\_reg\_rtx (DFmode);\
}")\
;; Floating to fixed conversion.

(define\_expand "fix\_truncdfsi2"\
;; This first insn produces a double-word value\
;; in which only the low word is valid.\
\[(set (match\_dup 2)\
(fix:DI (fix:DF (match\_operand:DF 1 "register\_operand" "f"))))\
(set (match\_operand:SI 0 "register\_operand" "=f")\
(subreg:SI (match\_dup 2) 0))]\
""\
"\
{\
operands\[2] = gen\_reg\_rtx (DImode);\
}")

;; Recognize the first insn generated above.\
;; This RTL looks like a fix\_truncdfdi2 insn,\
;; but we dont call it that, because only 32 bits\
;; of the result are valid.\
;; This pattern will work for the intended purposes\
;; as long as we do not have any fixdfdi2 or fix\_truncdfdi2.\
(define\_insn ""\
\[(set (match\_operand:DI 0 "register\_operand" "=f")\
(fix:DI (fix:DF (match\_operand:DF 1 "register\_operand" "f"))))]\
""\
"ftrunc.dd %1,%0")

(define\_expand "fix\_truncsfsi2"\
;; This first insn produces a double-word value\
;; in which only the low word is valid.\
\[(set (match\_dup 2)\
(fix:DI (fix:SF (match\_operand:SF 1 "register\_operand" "f"))))\
(set (match\_operand:SI 0 "register\_operand" "=f")\
(subreg:SI (match\_dup 2) 0))]\
""\
"\
{\
operands\[2] = gen\_reg\_rtx (DImode);\
}")

;; Recognize the first insn generated above.\
;; This RTL looks like a fix\_truncsfdi2 insn,\
;; but we dont call it that, because only 32 bits\
;; of the result are valid.\
;; This pattern will work for the intended purposes\
;; as long as we do not have any fixsfdi2 or fix\_truncsfdi2.\
(define\_insn ""\
\[(set (match\_operand:DI 0 "register\_operand" "=f")\
(fix:DI (fix:SF (match\_operand:SF 1 "register\_operand" "f"))))]\
""\
"ftrunc.sd %1,%0")\
;;- arithmetic instructions

(define\_insn "addsi3"\
\[(set (match\_operand:SI 0 "register\_operand" "=r,\*f")\
(plus:SI (match\_operand:SI 1 "nonmemory\_operand" "%r,\*f")\
(match\_operand:SI 2 "nonmemory\_operand" "rn,_f")))]_\
_""_\
_"_\
{\
if (which\_alternative == 1)\
return "fiadd.ss %2,%1,%0";\
if (REG\_P (operands\[2]))\
return "addu %2,%1,%0";\
if (SMALL\_INT (operands\[2]))\
return "addu %2,%1,%0";\
cc\_status.flags &= \~CC\_KNOW\_HI\_R31;\
return "orh h%%%2,r0,r31;or l%%%2,r31,r31;addu %1,r31,%0";\
}")

(define\_insn "adddi3"\
\[(set (match\_operand:DI 0 "register\_operand" "=f")\
(plus:DI (match\_operand:DI 1 "register\_operand" "%f")\
(match\_operand:DI 2 "register\_operand" "f")))]\
""\
"fiadd.dd %1,%2,%0")

(define\_insn "subsi3"\
\[(set (match\_operand:SI 0 "register\_operand" "=r,r,\*f")\
(minus:SI (match\_operand:SI 1 "register\_operand" "r,I,\*f")\
(match\_operand:SI 2 "nonmemory\_operand" "rn,r,_f")))]_\
_""_\
_"_\
{\
if (which\_alternative == 2)\
return "fisub.ss %1,%2,%0";\
if (REG\_P (operands\[2]))\
return "subu %1,%2,%0";\
if (SMALL\_INT (operands\[2]) && INTVAL (operands\[2]) != -0x10000)\
{\
operands\[2] = gen\_rtx (CONST\_INT, VOIDmode, - INTVAL (operands\[2]));\
return "addu %2,%1,%0";\
}\
cc\_status.flags &= \~CC\_KNOW\_HI\_R31;\
return "orh h%%%2,r0,r31;or l%%%2,r31,r31;sub %1,r31,%0";\
}")

(define\_insn "subdi3"\
\[(set (match\_operand:DI 0 "register\_operand" "=f")\
(minus:DI (match\_operand:DI 1 "register\_operand" "%f")\
(match\_operand:DI 2 "register\_operand" "f")))]\
""\
"fisub.dd %1,%2,%0")

(define\_expand "mulsi3"\
\[(set (subreg:SI (match\_dup 4) 0) (match\_operand:SI 1 "general\_operand" ""))\
(set (subreg:SI (match\_dup 5) 0) (match\_operand:SI 2 "general\_operand" ""))\
(clobber (match\_dup 3))\
(set (subreg:SI (match\_dup 3) 0)\
(mult:SI (subreg:SI (match\_dup 4) 0) (subreg:SI (match\_dup 5) 0)))\
(set (match\_operand:SI 0 "register\_operand" "") (subreg:SI (match\_dup 3) 0))]\
""\
"\
{\
operands\[3] = gen\_reg\_rtx (DImode);\
operands\[4] = gen\_reg\_rtx (DImode);\
operands\[5] = gen\_reg\_rtx (DImode);\
}")

(define\_insn ""\
\[(set (subreg:SI (match\_operand:DI 0 "register\_operand" "=f") 0)\
(mult:SI (subreg:SI (match\_operand:DI 1 "register\_operand" "f") 0)\
(subreg:SI (match\_operand:DI 2 "register\_operand" "f") 0)))]\
""\
"fmlow.dd %2,%1,%0")\
;;- and instructions (with compliment also)\
(define\_insn "andsi3"\
\[(set (match\_operand:SI 0 "register\_operand" "=r")\
(and:SI (match\_operand:SI 1 "nonmemory\_operand" "%r")\
(match\_operand:SI 2 "nonmemory\_operand" "rn")))]\
""\
"\*\
{\
rtx xop\[3];

if (REG\_P (operands\[2]) || LOGIC\_INT (operands\[2]))\
return "and %2,%1,%0";\
if ((INTVAL (operands\[2]) & 0xffff) == 0)\
{\
operands\[2] = gen\_rtx (CONST\_INT, VOIDmode,\
(unsigned) INTVAL (operands\[2]) >> 16);\
return "andh %2,%1,%0";\
}\
xop\[0] = operands\[0];\
xop\[1] = operands\[1];\
xop\[2] = gen\_rtx (CONST\_INT, VOIDmode, \~INTVAL (operands\[2]) & 0xffff);\
output\_asm\_insn ("andnot %2,%1,%0", xop);\
operands\[2] = gen\_rtx (CONST\_INT, VOIDmode,\
\~(unsigned) INTVAL (operands\[2]) >> 16);\
return "andnoth %2,%0,%0";\
}")

(define\_insn "andcbsi3"\
\[(set (match\_operand:SI 0 "register\_operand" "=r")\
(and:SI (match\_operand:SI 1 "register\_operand" "r")\
(not:SI (match\_operand:SI 2 "register\_operand" "rn"))))]\
""\
"\*\
{\
rtx xop\[3];

if (REG\_P (operands\[2]) || LOGIC\_INT (operands\[2]))\
return "andnot %2,%1,%0";\
if ((INTVAL (operands\[2]) & 0xffff) == 0)\
{\
operands\[2] = gen\_rtx (CONST\_INT, VOIDmode,\
(unsigned) INTVAL (operands\[2]) >> 16);\
return "andnoth %2,%1,%0";\
}\
xop\[0] = operands\[0];\
xop\[1] = operands\[1];\
xop\[2] = gen\_rtx (CONST\_INT, VOIDmode, (INTVAL (operands\[2]) & 0xffff));\
output\_asm\_insn ("andnot %2,%1,%0", xop);\
operands\[2] = gen\_rtx (CONST\_INT, VOIDmode,\
(unsigned) INTVAL (operands\[2]) >> 16);\
return "andnoth %2,%0,%0";\
}")

(define\_insn "iorsi3"\
\[(set (match\_operand:SI 0 "register\_operand" "=r")\
(ior:SI (match\_operand:SI 1 "nonmemory\_operand" "%r")\
(match\_operand:SI 2 "nonmemory\_operand" "rn")))]\
""\
"\*\
{\
rtx xop\[3];

if (REG\_P (operands\[2]) || LOGIC\_INT (operands\[2]))\
return "or %2,%1,%0";\
if ((INTVAL (operands\[2]) & 0xffff) == 0)\
{\
operands\[2] = gen\_rtx (CONST\_INT, VOIDmode,\
(unsigned) INTVAL (operands\[2]) >> 16);\
return "orh %2,%1,%0";\
}\
xop\[0] = operands\[0];\
xop\[1] = operands\[1];\
xop\[2] = gen\_rtx (CONST\_INT, VOIDmode, (INTVAL (operands\[2]) & 0xffff));\
output\_asm\_insn ("or %2,%1,%0", xop);\
operands\[2] = gen\_rtx (CONST\_INT, VOIDmode,\
(unsigned) INTVAL (operands\[2]) >> 16);\
return "orh %2,%0,%0";\
}")

(define\_insn "xorsi3"\
\[(set (match\_operand:SI 0 "register\_operand" "=r")\
(xor:SI (match\_operand:SI 1 "nonmemory\_operand" "%r")\
(match\_operand:SI 2 "nonmemory\_operand" "rn")))]\
""\
"\*\
{\
rtx xop\[3];

if (REG\_P (operands\[2]) || LOGIC\_INT (operands\[2]))\
return "xor %2,%1,%0";\
if ((INTVAL (operands\[2]) & 0xffff) == 0)\
{\
operands\[2] = gen\_rtx (CONST\_INT, VOIDmode,\
(unsigned) INTVAL (operands\[2]) >> 16);\
return "xorh %2,%1,%0";\
}\
xop\[0] = operands\[0];\
xop\[1] = operands\[1];\
xop\[2] = gen\_rtx (CONST\_INT, VOIDmode, (INTVAL (operands\[2]) & 0xffff));\
output\_asm\_insn ("xor %2,%1,%0", xop);\
operands\[2] = gen\_rtx (CONST\_INT, VOIDmode,\
(unsigned) INTVAL (operands\[2]) >> 16);\
return "xorh %2,%0,%0";\
}")

(define\_insn "negsi2"\
\[(set (match\_operand:SI 0 "general\_operand" "=r")\
(neg:SI (match\_operand:SI 1 "arith\_operand" "rI")))]\
""\
"subu r0,%1,%0")

(define\_insn "one\_cmplsi2"\
\[(set (match\_operand:SI 0 "general\_operand" "=r")\
(not:SI (match\_operand:SI 1 "arith\_operand" "r")))]\
""\
"subu -1,%1,%0")\
;; Floating point arithmetic instructions.

(define\_insn "adddf3"\
\[(set (match\_operand:DF 0 "register\_operand" "=f")\
(plus:DF (match\_operand:DF 1 "register\_operand" "f")\
(match\_operand:DF 2 "register\_operand" "f")))]\
""\
"fadd.dd %1,%2,%0")

(define\_insn "addsf3"\
\[(set (match\_operand:SF 0 "register\_operand" "=f")\
(plus:SF (match\_operand:SF 1 "register\_operand" "f")\
(match\_operand:SF 2 "register\_operand" "f")))]\
""\
"fadd.ss %1,%2,%0")

(define\_insn "subdf3"\
\[(set (match\_operand:DF 0 "register\_operand" "=f")\
(minus:DF (match\_operand:DF 1 "register\_operand" "f")\
(match\_operand:DF 2 "register\_operand" "f")))]\
""\
"fsub.dd %1,%2,%0")

(define\_insn "subsf3"\
\[(set (match\_operand:SF 0 "register\_operand" "=f")\
(minus:SF (match\_operand:SF 1 "register\_operand" "f")\
(match\_operand:SF 2 "register\_operand" "f")))]\
""\
"fsub.ss %1,%2,%0")

(define\_insn "muldf3"\
\[(set (match\_operand:DF 0 "register\_operand" "=f")\
(mult:DF (match\_operand:DF 1 "register\_operand" "f")\
(match\_operand:DF 2 "register\_operand" "f")))]\
""\
"fmul.dd %1,%2,%0")

(define\_insn "mulsf3"\
\[(set (match\_operand:SF 0 "register\_operand" "=f")\
(mult:SF (match\_operand:SF 1 "register\_operand" "f")\
(match\_operand:SF 2 "register\_operand" "f")))]\
""\
"fmul.ss %1,%2,%0")

(define\_insn "negdf2"\
\[(set (match\_operand:DF 0 "register\_operand" "=f")\
(neg:DF (match\_operand:DF 1 "register\_operand" "f")))]\
""\
"fsub.dd f0,%1,%0")

(define\_insn "negsf2"\
\[(set (match\_operand:SF 0 "register\_operand" "=f")\
(neg:SF (match\_operand:SF 1 "register\_operand" "f")))]\
""\
"fsub.ss f0,%1,%0")\
;; Shift instructions

;; Optimized special case of shifting.\
;; Must precede the general case.

(define\_insn ""\
\[(set (match\_operand:SI 0 "register\_operand" "=r")\
(ashiftrt:SI (match\_operand:SI 1 "memory\_operand" "m")\
(const\_int 24)))]\
""\
"\*\
{\
if (CONSTANT\_ADDRESS\_P (XEXP (operands\[1], 0)))\
{\
cc\_status.flags |= CC\_KNOW\_HI\_R31 | CC\_HI\_R31\_ADJ;\
cc\_status.mdep = XEXP (operands\[1], 0);\
return "orh ha%%%m1,r0,r31;ld.b l%%%m1(r31),%0";\
}\
return "ld.b %1,%0";\
}")

\
;;- arithmetic shift instructions\
(define\_insn "ashlsi3"\
\[(set (match\_operand:SI 0 "register\_operand" "=r")\
(ashift:SI (match\_operand:SI 1 "register\_operand" "r")\
(match\_operand:SI 2 "nonmemory\_operand" "rn")))]\
""\
"\*\
{\
if (GET\_CODE (operands\[2]) == CONST\_INT\
&& INTVAL (operands\[2]) >= 32)\
return "mov r0,%0";\
return "shl %2,%1,%0";\
}")

(define\_insn "ashlhi3"\
\[(set (match\_operand:HI 0 "register\_operand" "=r")\
(ashift:HI (match\_operand:HI 1 "register\_operand" "r")\
(match\_operand:HI 2 "nonmemory\_operand" "rn")))]\
""\
"\*\
{\
if (GET\_CODE (operands\[2]) == CONST\_INT\
&& INTVAL (operands\[2]) >= 16)\
return "mov r0,%0";\
return "shl %2,%1,%0";\
}")

(define\_insn "ashlqi3"\
\[(set (match\_operand:QI 0 "register\_operand" "=r")\
(ashift:QI (match\_operand:QI 1 "register\_operand" "r")\
(match\_operand:QI 2 "nonmemory\_operand" "rn")))]\
""\
"\*\
{\
if (GET\_CODE (operands\[2]) == CONST\_INT\
&& INTVAL (operands\[2]) >= 8)\
return "mov r0,%0";\
return "shl %2,%1,%0";\
}")

(define\_insn "ashrsi3"\
\[(set (match\_operand:SI 0 "register\_operand" "=r")\
(ashiftrt:SI (match\_operand:SI 1 "register\_operand" "r")\
(match\_operand:SI 2 "nonmemory\_operand" "rn")))]\
""\
"\*\
{\
if (GET\_CODE (operands\[2]) == CONST\_INT\
&& INTVAL (operands\[2]) >= 32)\
return "shra 31,%1,%0";\
return "shra %2,%1,%0";\
}")

(define\_insn "lshrsi3"\
\[(set (match\_operand:SI 0 "register\_operand" "=r")\
(lshiftrt:SI (match\_operand:SI 1 "register\_operand" "r")\
(match\_operand:SI 2 "nonmemory\_operand" "rn")))]\
""\
"\*\
{\
if (GET\_CODE (operands\[2]) == CONST\_INT\
&& INTVAL (operands\[2]) >= 32)\
return "mov r0,%0";\
return "shr %2,%1,%0";\
}")\
;; Unconditional and other jump instructions

(define\_insn "jump"\
\[(set (pc) (label\_ref (match\_operand 0 "" "")))]\
""\
"\*\
{\
return "br %l0;nop";\
}")

;; Here are two simple peepholes which fill the delay slot of\
;; an unconditional branch.

(define\_peephole\
\[(set (match\_operand:SI 0 "register\_operand" "=rf")\
(match\_operand:SI 1 "single\_insn\_src\_p" "p"))\
(set (pc) (label\_ref (match\_operand 2 "" "")))]\
""\
"\* return output\_delayed\_branch ("br %l2", operands, insn);")

(define\_peephole\
\[(set (match\_operand:SI 0 "memory\_operand" "=m")\
(match\_operand:SI 1 "reg\_or\_0\_operand" "rfJ"))\
(set (pc) (label\_ref (match\_operand 2 "" "")))]\
""\
"\* return output\_delayed\_branch ("br %l2", operands, insn);")

(define\_insn "tablejump"\
\[(set (pc) (match\_operand:SI 0 "register\_operand" "r"))\
(use (label\_ref (match\_operand 1 "" "")))]\
""\
"bri %0;nop")

(define\_peephole\
\[(set (match\_operand:SI 0 "memory\_operand" "=m")\
(match\_operand:SI 1 "reg\_or\_0\_operand" "rfJ"))\
(set (pc) (match\_operand:SI 2 "register\_operand" "r"))\
(use (label\_ref (match\_operand 3 "" "")))]\
""\
"\* return output\_delayed\_branch ("bri %2", operands, insn);")

;;- jump to subroutine\
(define\_expand "call"\
\[(call (match\_operand:SI 0 "memory\_operand" "m")\
(match\_operand 1 "" "i"))]\
;; operand\[2] is next\_arg\_register\
""\
"\
{\
if (INTVAL (operands\[1]) > 0)\
{\
emit\_move\_insn (arg\_pointer\_rtx, stack\_pointer\_rtx);\
emit\_insn (gen\_rtx (USE, VOIDmode, arg\_pointer\_rtx));\
}\
}")

;;- jump to subroutine\
(define\_insn ""\
\[(call (match\_operand:SI 0 "memory\_operand" "m")\
(match\_operand 1 "" "i"))]\
;; operand\[2] is next\_arg\_register\
""\
"\*\
{\
/\* strip the MEM. \*/\
operands\[0] = XEXP (operands\[0], 0);\
CC\_STATUS\_INIT;\
if (GET\_CODE (operands\[0]) == REG)\
return "calli %0;nop";\
return "call %0;nop";\
}")

(define\_peephole\
\[(set (match\_operand:SI 0 "register\_operand" "=rf")\
(match\_operand:SI 1 "single\_insn\_src\_p" "p"))\
(call (match\_operand:SI 2 "memory\_operand" "m")\
(match\_operand 3 "" "i"))]\
;;- Don't use operand 1 for most machines.\
"! reg\_mentioned\_p (operands\[0], operands\[2])"\
"\*\
{\
/\* strip the MEM. \*/\
operands\[2] = XEXP (operands\[2], 0);\
if (GET\_CODE (operands\[2]) == REG)\
return output\_delayed\_branch ("calli %2", operands, insn);\
return output\_delayed\_branch ("call %2", operands, insn);\
}")

(define\_peephole\
\[(set (match\_operand:SI 0 "memory\_operand" "=m")\
(match\_operand:SI 1 "reg\_or\_0\_operand" "rfJ"))\
(call (match\_operand:SI 2 "memory\_operand" "m")\
(match\_operand 3 "" "i"))]\
;;- Don't use operand 1 for most machines.\
""\
"\*\
{\
/\* strip the MEM. \*/\
operands\[2] = XEXP (operands\[2], 0);\
if (GET\_CODE (operands\[2]) == REG)\
return output\_delayed\_branch ("calli %2", operands, insn);\
return output\_delayed\_branch ("call %2", operands, insn);\
}")

(define\_expand "call\_value"\
\[(set (match\_operand 0 "register\_operand" "rf")\
(call (match\_operand:SI 1 "memory\_operand" "m")\
(match\_operand 2 "" "i")))]\
;; operand 3 is next\_arg\_register\
""\
"\
{\
if (INTVAL (operands\[2]) > 0)\
{\
emit\_move\_insn (arg\_pointer\_rtx, stack\_pointer\_rtx);\
emit\_insn (gen\_rtx (USE, VOIDmode, arg\_pointer\_rtx));\
}\
}")

(define\_insn ""\
\[(set (match\_operand 0 "register\_operand" "=rf")\
(call (match\_operand:SI 1 "memory\_operand" "m")\
(match\_operand 2 "" "i")))]\
;; operand 3 is next\_arg\_register\
""\
"\*\
{\
/\* strip the MEM. \*/\
operands\[1] = XEXP (operands\[1], 0);\
CC\_STATUS\_INIT;\
if (GET\_CODE (operands\[1]) == REG)\
return "calli %1;nop";\
return "call %1;nop";\
}")

(define\_peephole\
\[(set (match\_operand:SI 0 "register\_operand" "=rf")\
(match\_operand:SI 1 "single\_insn\_src\_p" "p"))\
(set (match\_operand 2 "" "=rf")\
(call (match\_operand:SI 3 "memory\_operand" "m")\
(match\_operand 4 "" "i")))]\
;;- Don't use operand 4 for most machines.\
"! reg\_mentioned\_p (operands\[0], operands\[3])"\
"\*\
{\
/\* strip the MEM. \*/\
operands\[3] = XEXP (operands\[3], 0);\
if (GET\_CODE (operands\[3]) == REG)\
return output\_delayed\_branch ("calli %3", operands, insn);\
return output\_delayed\_branch ("call %3", operands, insn);\
}")

(define\_peephole\
\[(set (match\_operand:SI 0 "memory\_operand" "=m")\
(match\_operand:SI 1 "reg\_or\_0\_operand" "rJf"))\
(set (match\_operand 2 "" "=rf")\
(call (match\_operand:SI 3 "memory\_operand" "m")\
(match\_operand 4 "" "i")))]\
;;- Don't use operand 4 for most machines.\
""\
"\*\
{\
/\* strip the MEM. _/_\
_operands\[3] = XEXP (operands\[3], 0);_\
_if (GET\_CODE (operands\[3]) == REG)_\
_return output\_delayed\_branch ("calli %3", operands, insn);_\
_return output\_delayed\_branch ("call %3", operands, insn);_\
_}")_\
_(define\_insn "nop"_\
_\[(const\_int 0)]_\
_""_\
_"nop")_\
_(define\_insn ""_\
_\[(set (match\_operand:SI 0 "register\_operand" "r")_\
_(mem:SI (plus:SI (match\_operand:SI 1 "register\_operand" "r")_\
_(label\_ref (match\_operand 2 "" "")))))]_\
_""_\
_"_\
{\
cc\_status.flags = 0;\
return "mov %l2,r31;ld.l r31(%1),%0";\
}")

(define\_peephole\
\[(set (match\_operand:SI 0 "register\_operand" "=rf")\
(match\_operand:SI 1 "single\_insn\_src\_p" "p"))\
(set (pc) (match\_operand:SI 2 "register\_operand" "r"))\
(use (label\_ref (match\_operand 3 "" "")))]\
"REGNO (operands\[0]) != REGNO (operands\[2])"\
"\* return output\_delayed\_branch ("bri %2", operands, insn);")\
;;- Local variables:\
;;- mode:emacs-lisp\
;;- comment-start: ";;- "\
;;- eval: (set-syntax-table (copy-sequence (syntax-table)))\
;;- eval: (modify-syntax-entry ?\[ "(]")\
;;- eval: (modify-syntax-entry ?] ")\[")\
;;- eval: (modify-syntax-entry ?{ "(}")\
;;- eval: (modify-syntax-entry ?} "){")\
;;- End:
