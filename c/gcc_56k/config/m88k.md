# m88k

;;- Machine description for the Motorola 88000 for GNU C compiler\
;; Copyright (C) 1988 Free Software Foundation, Inc.\
;; Contributed by Michael Tiemann (tiemann@mcc.com)

;; This file is part of GNU CC.

;; GNU CC is free software; you can redistribute it and/or modify\
;; it under the terms of the GNU General Public License as published by\
;; the Free Software Foundation; either version 1, or (at your option)\
;; any later version.

;; GNU CC is distributed in the hope that it will be useful,\
;; but WITHOUT ANY WARRANTY; without even the implied warranty of\
;; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\
;; GNU General Public License for more details.

;; You should have received a copy of the GNU General Public License\
;; along with GNU CC; see the file COPYING. If not, write to\
;; the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.

;;- See file "rtl.def" for documentation on define\_insn, match\_\*, et. al.

;;- cpp macro #define NOTICE\_UPDATE\_CC in file tm.h handles condition code\
;;- updates for most instructions.

;;- Operand classes for the register allocator:\
;; Compare instructions.\
;; This pattern is used for generating an "insn"\
;; which does just a compare and sets a (fictitious) condition code.

;; The actual the m88000 insns are compare-and-conditional-jump.\
;; The define\_peephole's below recognize the combinations of\
;; compares and jumps, and output each pair as a single assembler insn.

;; This controls RTL generation and register allocation.\
(define\_insn "cmpsi"\
\[(set (cc0)\
(compare (match\_operand:SI 0 "arith\_operand" "rI")\
(match\_operand:SI 1 "arith\_operand" "rI")))]\
""\
"\*\
{\
if (GET\_CODE (operands\[0]) == CONST\_INT)\
{\
cc\_status.flags |= CC\_REVERSED;\
return "cmp r25,%1,%0";\
}\
return "cmp r25,%0,%1";\
}")

(define\_insn "cmpdf"\
\[(set (cc0)\
(compare (match\_operand:DF 0 "nonmemory\_operand" "rG")\
(match\_operand:DF 1 "nonmemory\_operand" "rG")))]\
""\
"\*\
{\
if (GET\_CODE (operands\[0]) == CONST\_DOUBLE)\
{\
cc\_status.flags |= CC\_REVERSED | CC\_IN\_FCCR;\
return "fcmp.sdd r25,%1,%0";\
}\
cc\_status.flags |= CC\_IN\_FCCR;\
return "fcmp.sdd r25,%0,%1";\
}")

(define\_insn "cmpsf"\
\[(set (cc0)\
(compare (match\_operand:SF 0 "nonmemory\_operand" "rG")\
(match\_operand:SF 1 "nonmemory\_operand" "rG")))]\
""\
"\*\
{\
if (GET\_CODE (operands\[0]) == CONST\_DOUBLE)\
{\
cc\_status.flags |= CC\_REVERSED | CC\_IN\_FCCR;\
return "fcmp.sss r25,%1,%0";\
}\
cc\_status.flags |= CC\_IN\_FCCR;\
return "fcmp.sss r25,%0,%1";\
}")\
;; We have to have this because cse can optimize the previous pattern\
;; into this one.

(define\_insn "tstsi"\
\[(set (cc0)\
(match\_operand:SI 0 "register\_operand" "r"))]\
""\
"cmp r25,%0,0")

(define\_insn "tstdf"\
\[(set (cc0)\
(match\_operand:DF 0 "register\_operand" "r"))]\
""\
"\*\
{\
cc\_status.flags |= CC\_IN\_FCCR;\
return "fcmp.sds r25,%0,r0";\
}")

(define\_insn "tstsf"\
\[(set (cc0)\
(match\_operand:SF 0 "register\_operand" "r"))]\
""\
"\*\
{\
cc\_status.flags |= CC\_IN\_FCCR;\
return "fcmp.sss r25,%0,r0";\
}")

;; These control RTL generation for conditional jump insns\
;; and match them for register allocation.

(define\_insn "beq"\
\[(set (pc)\
(if\_then\_else (eq (cc0)\
(const\_int 0))\
(label\_ref (match\_operand 0 "" ""))\
(pc)))]\
""\
"bb1 eq,r25,%l0")

(define\_peephole\
\[(set (cc0)\
(match\_operand:SI 0 "register\_operand" "r"))\
(set (pc)\
(if\_then\_else (eq (cc0)\
(const\_int 0))\
(label\_ref (match\_operand 1 "" ""))\
(pc)))]\
""\
"\*\
{\
CC\_STATUS\_INIT;\
return "bcnd eq0,%0,%l1";\
}")

(define\_insn "bne"\
\[(set (pc)\
(if\_then\_else (ne (cc0)\
(const\_int 0))\
(label\_ref (match\_operand 0 "" ""))\
(pc)))]\
""\
"bb1 ne,r25,%l0")

(define\_peephole\
\[(set (cc0)\
(match\_operand:SI 0 "register\_operand" "r"))\
(set (pc)\
(if\_then\_else (ne (cc0)\
(const\_int 0))\
(label\_ref (match\_operand 1 "" ""))\
(pc)))]\
""\
"\*\
{\
CC\_STATUS\_INIT;\
return "bcnd ne0,%0,%l1";\
}")

(define\_insn "bgt"\
\[(set (pc)\
(if\_then\_else (gt (cc0)\
(const\_int 0))\
(label\_ref (match\_operand 0 "" ""))\
(pc)))]\
""\
"bb1 gt,r25,%l0")

(define\_insn "bgtu"\
\[(set (pc)\
(if\_then\_else (gtu (cc0)\
(const\_int 0))\
(label\_ref (match\_operand 0 "" ""))\
(pc)))]\
""\
"bb1 hi,r25,%l0")

(define\_insn "blt"\
\[(set (pc)\
(if\_then\_else (lt (cc0)\
(const\_int 0))\
(label\_ref (match\_operand 0 "" ""))\
(pc)))]\
""\
"bb1 lt,r25,%l0")

(define\_insn "bltu"\
\[(set (pc)\
(if\_then\_else (ltu (cc0)\
(const\_int 0))\
(label\_ref (match\_operand 0 "" ""))\
(pc)))]\
""\
"bb1 lo,r25,%l0")

(define\_insn "bge"\
\[(set (pc)\
(if\_then\_else (ge (cc0)\
(const\_int 0))\
(label\_ref (match\_operand 0 "" ""))\
(pc)))]\
""\
"bb1 ge,r25,%l0")

(define\_insn "bgeu"\
\[(set (pc)\
(if\_then\_else (geu (cc0)\
(const\_int 0))\
(label\_ref (match\_operand 0 "" ""))\
(pc)))]\
""\
"bb1 hs,r25,%l0")

(define\_insn "ble"\
\[(set (pc)\
(if\_then\_else (le (cc0)\
(const\_int 0))\
(label\_ref (match\_operand 0 "" ""))\
(pc)))]\
""\
"bb1 le,r25,%l0")

(define\_insn "bleu"\
\[(set (pc)\
(if\_then\_else (leu (cc0)\
(const\_int 0))\
(label\_ref (match\_operand 0 "" ""))\
(pc)))]\
""\
"bb1 ls,r25,%l0")\
;; These match inverted jump insns for register allocation.

(define\_insn ""\
\[(set (pc)\
(if\_then\_else (eq (cc0)\
(const\_int 0))\
(pc)\
(label\_ref (match\_operand 0 "" ""))))]\
""\
"bb0 eq,r25,%l0")

(define\_peephole\
\[(set (cc0) (match\_operand:SI 0 "register\_operand" "r"))\
(set (pc)\
(if\_then\_else (eq (cc0)\
(const\_int 0))\
(pc)\
(label\_ref (match\_operand 1 "" ""))))]\
""\
"\*\
{\
CC\_STATUS\_INIT;\
return "bcnd ne0,%0,%l1";\
}")

(define\_insn ""\
\[(set (pc)\
(if\_then\_else (ne (cc0)\
(const\_int 0))\
(pc)\
(label\_ref (match\_operand 0 "" ""))))]\
""\
"bb0 ne,r25,%l0")

(define\_peephole\
\[(set (cc0) (match\_operand:SI 0 "register\_operand" "r"))\
(set (pc)\
(if\_then\_else (ne (cc0)\
(const\_int 0))\
(pc)\
(label\_ref (match\_operand 1 "" ""))))]\
""\
"\*\
{\
CC\_STATUS\_INIT;\
return "bcnd eq0,%0,%l1";\
}")

(define\_insn ""\
\[(set (pc)\
(if\_then\_else (gt (cc0)\
(const\_int 0))\
(pc)\
(label\_ref (match\_operand 0 "" ""))))]\
""\
"bb0 gt,r25,%l0")

(define\_insn ""\
\[(set (pc)\
(if\_then\_else (gtu (cc0)\
(const\_int 0))\
(pc)\
(label\_ref (match\_operand 0 "" ""))))]\
""\
"bb0 hi,r25,%l0")

(define\_insn ""\
\[(set (pc)\
(if\_then\_else (lt (cc0)\
(const\_int 0))\
(pc)\
(label\_ref (match\_operand 0 "" ""))))]\
""\
"bb0 lt,r25,%l0")

(define\_insn ""\
\[(set (pc)\
(if\_then\_else (ltu (cc0)\
(const\_int 0))\
(pc)\
(label\_ref (match\_operand 0 "" ""))))]\
""\
"bb0 lo,r25,%l0")

(define\_insn ""\
\[(set (pc)\
(if\_then\_else (ge (cc0)\
(const\_int 0))\
(pc)\
(label\_ref (match\_operand 0 "" ""))))]\
""\
"bb0 ge,r25,%l0")

(define\_insn ""\
\[(set (pc)\
(if\_then\_else (geu (cc0)\
(const\_int 0))\
(pc)\
(label\_ref (match\_operand 0 "" ""))))]\
""\
"bb0 hs,r25,%l0")

(define\_insn ""\
\[(set (pc)\
(if\_then\_else (le (cc0)\
(const\_int 0))\
(pc)\
(label\_ref (match\_operand 0 "" ""))))]\
""\
"bb0 le,r25,%l0")

(define\_insn ""\
\[(set (pc)\
(if\_then\_else (leu (cc0)\
(const\_int 0))\
(pc)\
(label\_ref (match\_operand 0 "" ""))))]\
""\
"bb0 ls,r25,%l0")\
;; Move instructions

(define\_insn "swapsi"\
\[(set (match\_operand:SI 0 "general\_operand" "g")\
(match\_operand:SI 1 "general\_operand" "g"))\
(set (match\_dup 1) (match\_dup 0))]\
""\
"\*\
{\
if (GET\_CODE (operands\[0]) == MEM && GET\_CODE (operands\[1]) == MEM)\
{\
CC\_STATUS\_INIT;\
return "ld r25,%0;xmem r25,%1;st r25,%0";\
}\
if (! REG\_P (operands\[1]))\
return "xmem %0,%1";\
if (REG\_P (operands\[0]))\
{\
if (REGNO (operands\[0]) == REGNO (operands\[1]))\
return "";\
return "xor %0,%0,%1;xor %1,%1,%0;xor %0,%0,%1";\
}\
return "xmem %1,%0";\
}")

(define\_peephole\
\[(set (match\_operand:SI 0 "register\_operand" "=r")\
(match\_operand:SI 1 "memory\_operand" "m"))\
(set (match\_operand:SI 2 "register\_operand" "=r")\
(match\_operand:SI 3 "memory\_operand" "m"))\
(set (match\_dup 1) (match\_dup 2))\
(set (match\_dup 3) (match\_dup 0))]\
""\
"\*\
{\
CC\_STATUS\_INIT;\
return "ld r25,%1;xmem r25,%3;st r25,%1";\
}")

(define\_insn "swapqi"\
\[(set (match\_operand:QI 0 "general\_operand" "g")\
(match\_operand:QI 1 "general\_operand" "g"))\
(set (match\_dup 1) (match\_dup 0))]\
""\
"\*\
{\
if (GET\_CODE (operands\[0]) == MEM && GET\_CODE (operands\[1]) == MEM)\
{\
CC\_STATUS\_INIT;\
return "ld.bu r25,%0;xmem.bu r25,%1;st.bu r25,%0";\
}\
if (! REG\_P (operands\[1]))\
return "xmem.bu %0,%1";\
if (REG\_P (operands\[0]))\
{\
if (REGNO (operands\[0]) == REGNO (operands\[1]))\
return "";\
return "xor %0,%0,%1;xor %1,%1,%0;xor %0,%0,%1";\
}\
return "xmem.bu %1,%0";\
}")

(define\_peephole\
\[(set (match\_operand:QI 0 "register\_operand" "=r")\
(match\_operand:QI 1 "memory\_operand" "m"))\
(set (match\_operand:QI 2 "register\_operand" "=r")\
(match\_operand:QI 3 "memory\_operand" "m"))\
(set (match\_dup 1) (match\_dup 2))\
(set (match\_dup 3) (match\_dup 0))]\
""\
"\*\
{\
CC\_STATUS\_INIT;\
return "ld.bu r25,%1;xmem.bu r25,%3;st.bu r25,%1";\
}")

(define\_insn ""\
\[(set (match\_operand:SI 0 "general\_operand" "g")\
(const\_int 0))]\
""\
"\*\
{\
if (REG\_P (operands\[0]))\
return "or %0,r0,0";\
return "st r0,%0";\
}")

(define\_insn "movsi"\
\[(set (match\_operand:SI 0 "general\_operand" "=g,r")\
(match\_operand:SI 1 "general\_operand" "r,mi"))]\
""\
"\*\
{\
if (REG\_P (operands\[0]))\
{\
if (GET\_CODE (operands\[1]) == MEM)\
return "ld %0,%1";\
if (GET\_CODE (operands\[1]) == CONST\_INT)\
return output\_store\_const\_int (SImode, operands);\
if (GET\_CODE (operands\[1]) == LABEL\_REF\
|| GET\_CODE (operands\[1]) == SYMBOL\_REF)\
return "lda %0,r0,%1";\
return "or %0,r0,%1";\
}\
return "st %1,%0";\
}")

;; Simulate pre inc. Post inc/dec is automatically optimized\
;; by sheer luck. ?? In which phase should this really be done??\
(define\_insn ""\
\[(set (match\_operand:SI 0 "register\_operand" "r")\
(mem:SI (plus:SI (match\_operand:SI 1 "register\_operand" "r")\
(match\_operand:SI 2 "arith\_operand" "rI"))))\
(set (match\_dup 1)\
(plus:SI (match\_dup 1)\
(match\_dup 2)))]\
""\
"ld %0,%1,%2\t;; pipelined!;addu %1,%1,%2\t;; /")

(define\_insn ""\
\[(set (mem:SI (plus:SI (match\_operand:SI 0 "register\_operand" "r")\
(match\_operand:SI 1 "arith\_operand" "rI")))\
(match\_operand:SI 2 "register\_operand" "r"))\
(set (match\_dup 0)\
(plus:SI (match\_dup 0)\
(match\_dup 1)))]\
""\
"st %2,%0,%1\t;; pipelined!;addu %0,%0,%1\t;; /")

(define\_insn ""\
\[(set (match\_operand:HI 0 "general\_operand" "g")\
(const\_int 0))]\
""\
"\*\
{\
if (REG\_P (operands\[0]))\
return "or %0,r0,0";\
return "st.h r0,%0";\
}")

(define\_insn "movhi"\
\[(set (match\_operand:HI 0 "general\_operand" "=g,r")\
(match\_operand:HI 1 "general\_operand" "r,mn"))]\
""\
"\*\
{\
if (REG\_P (operands\[0]))\
{\
if (GET\_CODE (operands\[1]) == MEM)\
return "ld.h %0,%1";\
if (GET\_CODE (operands\[1]) == CONST\_INT)\
return output\_store\_const\_int (HImode, operands);\
return "or %0,r0,%1";\
}\
return "st.h %1,%0";\
}")

(define\_insn ""\
\[(set (match\_operand:SI 0 "register\_operand" "r")\
(sign\_extend:SI\
(mem:HI (plus:SI (match\_operand:SI 1 "register\_operand" "r")\
(match\_operand:SI 2 "arith\_operand" "rI")))))\
(set (match\_dup 1)\
(plus:SI (match\_dup 1)\
(match\_dup 2)))]\
""\
"ld.h %0,%1,%2\t;; pipelined!;addu %1,%1,%2\t;; /")

(define\_insn ""\
\[(set (match\_operand:SI 0 "register\_operand" "r")\
(zero\_extend:SI\
(mem:HI (plus:SI (match\_operand:SI 1 "register\_operand" "r")\
(match\_operand:SI 2 "arith\_operand" "rI")))))\
(set (match\_dup 1)\
(plus:SI (match\_dup 1)\
(match\_dup 2)))]\
""\
"ld.hu %0,%1,%2\t;; pipelined!;addu %1,%1,%2\t;; /")

(define\_insn ""\
\[(set (mem:HI (plus:SI (match\_operand:SI 0 "register\_operand" "r")\
(match\_operand:SI 1 "arith\_operand" "rI")))\
(match\_operand:SI 2 "register\_operand" "r"))\
(set (match\_dup 0)\
(plus:SI (match\_dup 0)\
(match\_dup 1)))]\
""\
"st.h %2,%0,%1\t;; pipelined!;addu %0,%0,%1\t;; /")

(define\_insn ""\
\[(set (match\_operand:QI 0 "general\_operand" "g")\
(const\_int 0))]\
""\
"\*\
{\
if (REG\_P (operands\[0]))\
return "or %0,r0,0";\
return "st.b r0,%0";\
}")

(define\_insn "movqi"\
\[(set (match\_operand:QI 0 "general\_operand" "=g,r")\
(match\_operand:QI 1 "general\_operand" "r,mn"))]\
""\
"\*\
{\
if (REG\_P (operands\[0]))\
{\
if (GET\_CODE (operands\[1]) == MEM)\
return "ld.b %0,%1";\
if (GET\_CODE (operands\[1]) == CONST\_INT)\
return output\_store\_const\_int (QImode, operands);\
return "or %0,r0,%1";\
}\
return "st.b %1,%0";\
}")

(define\_insn ""\
\[(set (match\_operand:SI 0 "register\_operand" "r")\
(sign\_extend:SI\
(mem:QI (plus:SI (match\_operand:SI 1 "register\_operand" "r")\
(match\_operand:SI 2 "arith\_operand" "rI")))))\
(set (match\_dup 1)\
(plus:SI (match\_dup 1)\
(match\_dup 2)))]\
""\
"ld.b %0,%1,%2\t;; pipelined!;addu %1,%1,%2\t;; /")

(define\_insn ""\
\[(set (match\_operand:SI 0 "register\_operand" "r")\
(zero\_extend:SI\
(mem:QI (plus:SI (match\_operand:SI 1 "register\_operand" "r")\
(match\_operand:SI 2 "arith\_operand" "rI")))))\
(set (match\_dup 1)\
(plus:SI (match\_dup 1)\
(match\_dup 2)))]\
""\
"ld.bu %0,%1,%2\t;; pipelined!;addu %1,%1,%2\t;; /")

(define\_insn ""\
\[(set (mem:QI (plus:SI (match\_operand:SI 0 "register\_operand" "r")\
(match\_operand:SI 1 "arith\_operand" "rI")))\
(match\_operand:SI 2 "register\_operand" "r"))\
(set (match\_dup 0)\
(plus:SI (match\_dup 0)\
(match\_dup 1)))]\
""\
"st.b %2,%0,%1\t;; pipelined!;addu %0,%0,%1\t;; /")

;; The definition of this insn does not really explain what it does,\
;; but it should suffice\
;; that anything generated as this insn will be recognized as one\
;; and that it won't successfully combine with anything.\
(define\_insn "movstrsi"\
\[(set (match\_operand:BLK 0 "general\_operand" "=g")\
(match\_operand:BLK 1 "general\_operand" "g"))\
(use (match\_operand:SI 2 "arith32\_operand" "rn"))\
(clobber (reg:SI 10))\
(clobber (reg:SI 11))\
(clobber (reg:SI 12))]\
""\
"\* output\_block\_move (operands);")\
;; This pattern forces (set (reg:DF ...) (const\_double ...))\
;; to be reloaded by putting the constant into memory.\
;; It must come before the more general movdf pattern.\
(define\_insn ""\
\[(set (match\_operand:DF 0 "general\_operand" "=r,o")\
(match\_operand:DF 1 "" "mG,G"))]\
"GET\_CODE (operands\[1]) == CONST\_DOUBLE"\
"\*\
{\
if (operands\[1] == dconst0\_rtx && GET\_CODE (operands\[0]) == REG)\
{\
operands\[1] = gen\_rtx (REG, SImode, REGNO (operands\[0]) + 1);\
return "add %0,r0,0;add %1,r0,0";\
}\
if (operands\[1] == dconst0\_rtx && GET\_CODE (operands\[0]) == MEM)\
{\
operands\[1] = adj\_offsettable\_operand (operands\[0], 4);\
return "st r0,%0;st r0,%1";\
}\
return output\_move\_double (operands);\
}\
")

(define\_insn "movdf"\
\[(set (match\_operand:DF 0 "general\_operand" "=r,m")\
(match\_operand:DF 1 "general\_operand" "rm,r"))]\
""\
"\* return output\_move\_double (operands);")

(define\_insn "movdi"\
\[(set (match\_operand:DI 0 "general\_operand" "=r,m")\
(match\_operand:DI 1 "general\_operand" "rm,r"))]\
""\
"\* return output\_move\_double (operands);")

(define\_insn "movsf"\
\[(set (match\_operand:SF 0 "general\_operand" "=g,r")\
(match\_operand:SF 1 "general\_operand" "r,mF"))]\
""\
"\*\
{\
if (REG\_P (operands\[0]))\
{\
if (GET\_CODE (operands\[1]) == MEM)\
return "ld %0,%1";\
if (GET\_CODE (operands\[1]) == CONST\_DOUBLE)\
return output\_store\_const\_float (SFmode, operands);\
return "or %0,r0,%1";\
}\
return "st %1,%0";\
}")\
;;- load effective address\
(define\_insn ""\
\[(set (match\_operand:SI 0 "register\_operand" "=r")\
(match\_operand:QI 1 "address\_operand" "p"))]\
""\
"lda.b %0,%a1")

(define\_insn ""\
\[(set (match\_operand:SI 0 "register\_operand" "=r")\
(match\_operand:HI 1 "address\_operand" "p"))]\
""\
"lda.w %0,%a1")

(define\_insn ""\
\[(set (match\_operand:SI 0 "register\_operand" "=r")\
(match\_operand:SI 1 "address\_operand" "p"))]\
""\
"lda %0,%a1")

(define\_insn ""\
\[(set (match\_operand:SI 0 "register\_operand" "=r")\
(match\_operand:DI 1 "address\_operand" "p"))]\
""\
"lda.d %0,%a1")

(define\_insn ""\
\[(set (match\_operand:SI 0 "register\_operand" "=r")\
(match\_operand:SF 1 "address\_operand" "p"))]\
""\
"lda %0,%a1")

(define\_insn ""\
\[(set (match\_operand:SI 0 "register\_operand" "=r")\
(match\_operand:DF 1 "address\_operand" "p"))]\
""\
"lda.d %0,%a1")\
;;- truncation instructions\
(define\_insn "truncsiqi2"\
\[(set (match\_operand:QI 0 "general\_operand" "=g")\
(truncate:QI\
(match\_operand:SI 1 "register\_operand" "r")))]\
""\
"\*\
{\
if (GET\_CODE (operands\[0]) == MEM)\
return "st.b %1,%0";\
return "or %0,r0,%1";\
}")

(define\_insn "trunchiqi2"\
\[(set (match\_operand:QI 0 "general\_operand" "=g")\
(truncate:QI\
(match\_operand:HI 1 "register\_operand" "r")))]\
""\
"\*\
{\
if (GET\_CODE (operands\[0]) == MEM)\
return "st.b %1,%0";\
return "or %0,r0,%1";\
}")

(define\_insn "truncsihi2"\
\[(set (match\_operand:HI 0 "general\_operand" "=g")\
(truncate:HI\
(match\_operand:SI 1 "register\_operand" "r")))]\
""\
"\*\
{\
if (GET\_CODE (operands\[0]) == MEM)\
return "st.h %1,%0";\
return "or %0,r0,%1";\
}")\
;;- zero extension instructions

;; Note that the one starting from HImode comes before those for QImode\
;; so that a constant operand will match HImode, not QImode.

(define\_insn "zero\_extendhisi2"\
\[(set (match\_operand:SI 0 "register\_operand" "=r")\
(zero\_extend:SI\
(match\_operand:HI 1 "general\_operand" "g")))]\
""\
"\*\
{\
if (REG\_P (operands\[1]))\
return "mask %0,%1,0xffff";\
if (GET\_CODE (operands\[1]) == CONST\_INT)\
return output\_store\_const\_int (SImode, operands);\
return "ld.hu %0,%1";\
}")

(define\_insn "zero\_extendqihi2"\
\[(set (match\_operand:HI 0 "register\_operand" "=r")\
(zero\_extend:HI\
(match\_operand:QI 1 "general\_operand" "g")))]\
""\
"\*\
{\
if (REG\_P (operands\[1]))\
return "mask %0,%1,0xff";\
if (GET\_CODE (operands\[1]) == CONST\_INT)\
return output\_store\_const\_int (SImode, operands);\
return "ld.bu %0,%1";\
}")

(define\_insn "zero\_extendqisi2"\
\[(set (match\_operand:SI 0 "register\_operand" "=r")\
(zero\_extend:SI\
(match\_operand:QI 1 "general\_operand" "g")))]\
""\
"\*\
{\
if (REG\_P (operands\[1]))\
return "mask %0,%1,0xff";\
if (GET\_CODE (operands\[1]) == CONST\_INT)\
return output\_store\_const\_int (SImode, operands);\
return "ld.bu %0,%1";\
}")\
;;- sign extension instructions\
;; Note that the one starting from HImode comes before those for QImode\
;; so that a constant operand will match HImode, not QImode.

(define\_insn "extendhisi2"\
\[(set (match\_operand:SI 0 "register\_operand" "=r")\
(sign\_extend:SI\
(match\_operand:HI 1 "general\_operand" "g")))]\
""\
"\*\
{\
if (REG\_P (operands\[1]))\
return "ext %0,%1,16<0>";\
if (GET\_CODE (operands\[1]) == CONST\_INT)\
return output\_store\_const\_int (SImode, operands);\
return "ld.h %0,%1";\
}")

(define\_insn "extendqihi2"\
\[(set (match\_operand:HI 0 "register\_operand" "=r")\
(sign\_extend:HI\
(match\_operand:QI 1 "general\_operand" "g")))]\
""\
"\*\
{\
if (REG\_P (operands\[1]))\
return "ext %0,%1,8<0>";\
if (GET\_CODE (operands\[1]) == CONST\_INT)\
return output\_store\_const\_int (SImode, operands);\
return "ld.b %0,%1";\
}")

(define\_insn "extendqisi2"\
\[(set (match\_operand:SI 0 "register\_operand" "=r")\
(sign\_extend:SI\
(match\_operand:QI 1 "general\_operand" "g")))]\
""\
"\*\
{\
if (REG\_P (operands\[1]))\
return "ext %0,%1,8<0>";\
if (GET\_CODE (operands\[1]) == CONST\_INT)\
return output\_store\_const\_int (SImode, operands);\
return "ld.b %0,%1";\
}")\
;; Conversions between float and double.

(define\_insn "extendsfdf2"\
\[(set (match\_operand:DF 0 "general\_operand" "=r")\
(float\_extend:DF\
(match\_operand:SF 1 "general\_operand" "r")))]\
""\
"fadd.dss %0,r0,%1")

(define\_insn "truncdfsf2"\
\[(set (match\_operand:SF 0 "general\_operand" "=r")\
(float\_truncate:SF\
(match\_operand:DF 1 "general\_operand" "r")))]\
""\
"fadd.ssd %0,r0,%1")\
;; Conversions between floating point and integer

(define\_insn "floatsidf2"\
\[(set (match\_operand:DF 0 "general\_operand" "=r")\
(float:DF (match\_operand:SI 1 "general\_operand" "r")))]\
""\
"flt.ds %0,%1")

(define\_insn "floatsisf2"\
\[(set (match\_operand:SF 0 "general\_operand" "=r")\
(float:SF (match\_operand:SI 1 "general\_operand" "r")))]\
""\
"flt.ss %0,%1")

(define\_insn "fixdfsi2"\
\[(set (match\_operand:SI 0 "general\_operand" "=r")\
(fix:SI (fix:DF (match\_operand:DF 1 "general\_operand" "r"))))]\
""\
"int.sd %0,%1")

(define\_insn "fixsfsi2"\
\[(set (match\_operand:SI 0 "general\_operand" "=r")\
(fix:SI (fix:SF (match\_operand:SF 1 "general\_operand" "r"))))]\
""\
"int.ss %0,%1")\
;;- arithmetic instructions\
;;- add instructions\
(define\_insn "addsi3"\
\[(set (match\_operand:SI 0 "register\_operand" "=r")\
(plus:SI (match\_operand:SI 1 "arith32\_operand" "%r")\
(match\_operand:SI 2 "arith32\_operand" "rn")))]\
""\
"\*\
{\
unsigned int i;

if (REG\_P (operands\[2]))\
return "addu %0,%1,%2";\
i = INTVAL (operands\[2]);\
if (INT\_FITS\_16\_BITS (i))\
return "addu %0,%1,%2";\
if (INT\_FITS\_16\_BITS (-i))\
{\
operands\[2] = gen\_rtx (CONST\_INT, VOIDmode, -i);\
return "subu %0,%1,%2";\
}\
return "or.u %0,r0,hi16(%2);or %0,%0,lo16(%2);addu %0,%1,%0";\
}")

(define\_insn "adddf3"\
\[(set (match\_operand:DF 0 "register\_operand" "=r")\
(plus:DF (match\_operand:DF 1 "register\_operand" "%r")\
(match\_operand:DF 2 "register\_operand" "r")))]\
""\
"fadd.ddd %0,%1,%2")

;; a bunch more can go in here!

(define\_insn "addsf3"\
\[(set (match\_operand:SF 0 "register\_operand" "=r")\
(plus:SF (match\_operand:SF 1 "register\_operand" "%r")\
(match\_operand:SF 2 "register\_operand" "r")))]\
""\
"fadd.sss %0,%1,%2")\
;;- subtract instructions\
(define\_insn "subsi3"\
\[(set (match\_operand:SI 0 "register\_operand" "=r")\
(minus:SI (match\_operand:SI 1 "register\_operand" "r")\
(match\_operand:SI 2 "arith32\_operand" "rn")))]\
""\
"\*\
{\
unsigned int i;

if (REG\_P (operands\[2]))\
return "subu %0,%1,%2";\
i = INTVAL (operands\[2]);\
if (INT\_FITS\_16\_BITS (i))\
return "subu %0,%1,%2";\
if (INT\_FITS\_16\_BITS (-i))\
{\
operands\[2] = gen\_rtx (CONST\_INT, VOIDmode, -i);\
return "addu %0,%1,%2";\
}\
return "or.u %0,r0,hi16(%2);or %0,%0,lo16(%2);subu %0,%1,%0";\
}")

(define\_insn "subdf3"\
\[(set (match\_operand:DF 0 "register\_operand" "=r")\
(minus:DF (match\_operand:DF 1 "register\_operand" "%r")\
(match\_operand:DF 2 "register\_operand" "r")))]\
""\
"fsub.ddd %0,%1,%2")

(define\_insn "subsf3"\
\[(set (match\_operand:SF 0 "register\_operand" "=r")\
(minus:SF (match\_operand:SF 1 "register\_operand" "%r")\
(match\_operand:SF 2 "register\_operand" "r")))]\
""\
"fsub.sss %0,%1,%2")\
;;- multiply instructions\
(define\_insn "mulsi3"\
\[(set (match\_operand:SI 0 "register\_operand" "=r")\
(mult:SI (match\_operand:SI 1 "register\_operand" "%r")\
(match\_operand:SI 2 "arith32\_operand" "rn")))]\
""\
"\*\
{\
unsigned int i;

if (REG\_P (operands\[2]))\
return "mul %0,%1,%2";\
i = INTVAL (operands\[2]);\
if (INT\_FITS\_16\_BITS (i))\
return "mul %0,%1,%2";\
return "or.u %0,r0,hi16(%2);or %0,%0,lo16(%2);mul %0,%1,%0";\
}")

(define\_insn "umulsi3"\
\[(set (match\_operand:SI 0 "register\_operand" "=r")\
(umult:SI (match\_operand:SI 1 "register\_operand" "%r")\
(match\_operand:SI 2 "arith\_operand" "rI")))]\
""\
"mul %0,%1,%2")

(define\_insn "muldf3"\
\[(set (match\_operand:DF 0 "register\_operand" "=r")\
(mult:DF (match\_operand:DF 1 "register\_operand" "%r")\
(match\_operand:DF 2 "register\_operand" "r")))]\
""\
"fmul.ddd %0,%1,%2")

(define\_insn "mulsf3"\
\[(set (match\_operand:SF 0 "register\_operand" "=r")\
(mult:SF (match\_operand:SF 1 "register\_operand" "%r")\
(match\_operand:SF 2 "register\_operand" "r")))]\
""\
"fmul.sss %0,%1,%2")\
;;- divide instructions\
(define\_insn "divsi3"\
\[(set (match\_operand:SI 0 "register\_operand" "=r")\
(div:SI (match\_operand:SI 1 "register\_operand" "r")\
(match\_operand:SI 2 "arith32\_operand" "rn")))]\
""\
"\*\
{\
unsigned int i;

if (REG\_P (operands\[2]))\
return "div %0,%1,%2";\
i = INTVAL (operands\[2]);\
if (INT\_FITS\_16\_BITS (i))\
return "div %0,%1,%2";\
return "or.u %0,r0,hi16(%2);or %0,%0,lo16(%2);div %0,%1,%0";\
}")

(define\_insn "udivsi3"\
\[(set (match\_operand:SI 0 "register\_operand" "=r")\
(udiv:SI (match\_operand:SI 1 "register\_operand" "r")\
(match\_operand:SI 2 "arith\_operand" "rI")))]\
""\
"div %0,%1,%2")

(define\_insn "divdf3"\
\[(set (match\_operand:DF 0 "register\_operand" "=r")\
(div:DF (match\_operand:DF 1 "register\_operand" "r")\
(match\_operand:DF 2 "register\_operand" "r")))]\
""\
"fdiv.ddd %0,%1,%2")

(define\_insn "divsf3"\
\[(set (match\_operand:SF 0 "register\_operand" "=r")\
(div:SF (match\_operand:SF 1 "register\_operand" "r")\
(match\_operand:SF 2 "register\_operand" "r")))]\
""\
"fdiv.sss %0,%1,%2")\
;; Remainder instructions.

(define\_insn "modsi3"\
\[(set (match\_operand:SI 0 "register\_operand" "=r")\
(mod:SI (match\_operand:SI 1 "register\_operand" "r")\
(match\_operand:SI 2 "arith32\_operand" "rn")))]\
""\
"\*\
{\
unsigned int i;

if (REG\_P (operands\[2]))\
return "div %0,%1,%2;mul %0,%0,%2;sub %0,%1,%0";\
i = INTVAL (operands\[2]);\
if (INT\_FITS\_16\_BITS (i))\
return "div %0,%1,%2;mul %0,%0,%2;sub %0,%1,%0";\
if (INT\_FITS\_16\_BITS (-i))\
fatal ("implement negative case for mod");\
fatal ("implement 32 bit case for mod");\
}")

(define\_insn "umodsi3"\
\[(set (match\_operand:SI 0 "register\_operand" "=r")\
(umod:SI (match\_operand:SI 1 "register\_operand" "r")\
(match\_operand:SI 2 "arith\_operand" "rI")))]\
""\
"\*\
{\
unsigned int i;

if (REG\_P (operands\[2]))\
return "div %0,%1,%2;mul %0,%0,%2;sub %0,%1,%0";\
i = INTVAL (operands\[2]);\
if (INT\_FITS\_16\_BITS (i))\
return "div %0,%1,%2;mul %0,%0,%2;sub %0,%1,%0";\
if (INT\_FITS\_16\_BITS (-i))\
fatal ("implement negative case for umod");\
fatal ("implement 32 bit case for umod");\
}")

(define\_insn "divmodsi4"\
\[(set (match\_operand:SI 0 "register\_operand" "=r")\
(div:SI (match\_operand:SI 1 "register\_operand" "r")\
(match\_operand:SI 2 "arith\_operand" "rI")))\
(set (match\_operand:SI 3 "register\_operand" "=r")\
(mod:SI (match\_dup 1) (match\_dup 2)))]\
""\
"div %0,%1,%2;mul %3,%0,%2;sub %3,%1,%3")

(define\_insn "udivmodsi4"\
\[(set (match\_operand:SI 0 "register\_operand" "=r")\
(udiv:SI (match\_operand:SI 1 "register\_operand" "r")\
(match\_operand:SI 2 "arith\_operand" "rI")))\
(set (match\_operand:SI 3 "register\_operand" "=r")\
(umod:SI (match\_dup 1) (match\_dup 2)))]\
""\
"div %0,%1,%2;mul %3,%0,%2;sub %3,%1,%3")\
;;- and instructions (with complement also)\
(define\_insn "andsi3"\
\[(set (match\_operand:SI 0 "register\_operand" "=r")\
(and:SI (match\_operand:SI 1 "register\_operand" "%r")\
(match\_operand:SI 2 "arith32\_operand" "rn")))]\
""\
"\*\
{\
unsigned int i;

if (REG\_P (operands\[2]))\
return "and %0,%1,%2";\
i = INTVAL (operands\[2]);\
if (INT\_FITS\_16\_BITS (i))\
return "mask %0,%1,%2";\
if (INT\_FITS\_16\_BITS (-i))\
{\
operands\[2] = gen\_rtx (CONST\_INT, VOIDmode, i & 0xffff);\
return "and %0,%1,%2";\
}\
return "and.u %0,%1,hi16(%2);and %0,%1,lo16(%2)";\
}")

(define\_insn "andcbsi3"\
\[(set (match\_operand:SI 0 "register\_operand" "=r")\
(and:SI (match\_operand:SI 1 "register\_operand" "%r")\
(not:SI (match\_operand:SI 2 "register\_operand" "r"))))]\
""\
"and.c %0,%1,%2")\
;;- Bit set (inclusive or) instructions (with complement also)\
(define\_insn "iorsi3"\
\[(set (match\_operand:SI 0 "register\_operand" "=r")\
(ior:SI (match\_operand:SI 1 "register\_operand" "%r")\
(match\_operand:SI 2 "arith32\_operand" "rn")))]\
""\
"\*\
{\
unsigned int i;

if (REG\_P (operands\[2]))\
return "or %0,%1,%2";\
i = INTVAL (operands\[2]);\
if (INT\_FITS\_16\_BITS (i))\
return "or %0,%1,%2";\
return "or.u %0,%1,hi16(%2);or %0,%1,lo16(%2)";\
}")

(define\_insn "iorcbsi3"\
\[(set (match\_operand:SI 0 "register\_operand" "=r")\
(ior:SI (match\_operand:SI 1 "register\_operand" "%r")\
(not:SI (match\_operand:SI 2 "register\_operand" "r"))))]\
""\
"or.c %0,%1,%2")\
;;- xor instructions (with complement also)\
(define\_insn "xorsi3"\
\[(set (match\_operand:SI 0 "register\_operand" "=r")\
(xor:SI (match\_operand:SI 1 "register\_operand" "%r")\
(match\_operand:SI 2 "arith32\_operand" "rn")))]\
""\
"\*\
{\
unsigned int i;

if (REG\_P (operands\[2]))\
return "xor %0,%1,%2";\
i = INTVAL (operands\[2]);\
if (INT\_FITS\_16\_BITS (i))\
return "xor %0,%1,%2";\
if ((i & 0xffff) == 0)\
return "xor.u %0,%1,hi16(%2)";\
return "xor.u %0,%1,hi16(%2);xor %0,%1,lo16(%2)";\
}")

(define\_insn "xorcbsi3"\
\[(set (match\_operand:SI 0 "register\_operand" "=r")\
(xor:SI (match\_operand:SI 1 "register\_operand" "%r")\
(not:SI (match\_operand:SI 2 "register\_operand" "r"))))]\
""\
"xor.c %0,%1,%2")\
;;- one complement instructions\
(define\_insn "one\_cmplsi2"\
\[(set (match\_operand:SI 0 "register\_operand" "=r")\
(not:SI (match\_operand:SI 1 "register\_operand" "r")))]\
""\
"xor.c %0,%1,r0")\
;; Optimized special case of shifting.\
;; Must precede the general case.

(define\_insn ""\
\[(set (match\_operand:SI 0 "register\_operand" "=r")\
(ashiftrt:SI (match\_operand:SI 1 "memory\_operand" "m")\
(const\_int 24)))]\
""\
"ld.b %0,%1")

(define\_insn ""\
\[(set (match\_operand:SI 0 "register\_operand" "=r")\
(lshiftrt:SI (match\_operand:SI 1 "memory\_operand" "m")\
(const\_int 24)))]\
""\
"ld.bu %0,%1")\
;;- arithmetic shift instructions\
(define\_insn "ashlsi3"\
\[(set (match\_operand:SI 0 "register\_operand" "=r")\
(ashift:SI (match\_operand:SI 1 "register\_operand" "r")\
(match\_operand:SI 2 "arith\_operand" "rI")))]\
""\
"\*\
{\
if (GET\_CODE (operands\[2]) == CONST\_INT)\
return "mak %0,%1,0<%2>";\
return "mask %0,%2,0x1f;mak %0,%1,%0";\
}")

(define\_insn "ashrsi3"\
\[(set (match\_operand:SI 0 "register\_operand" "=r")\
(ashiftrt:SI (match\_operand:SI 1 "register\_operand" "r")\
(match\_operand:SI 2 "arith\_operand" "rI")))]\
""\
"\*\
{\
if (GET\_CODE (operands\[2]) == CONST\_INT)\
return "ext %0,%1,0<%2>";\
return "mask %0,%2,0x1f;ext %0,%1,%0";\
}")\
;;- logical shift instructions\
(define\_insn "lshrsi3"\
\[(set (match\_operand:SI 0 "register\_operand" "=r")\
(lshiftrt:SI (match\_operand:SI 1 "register\_operand" "r")\
(match\_operand:SI 2 "arith\_operand" "rI")))]\
""\
"\*\
{\
if (GET\_CODE (operands\[2]) == CONST\_INT)\
return "extu %0,%1,0<%2>";\
return "mask %0,%2,0x1f;extu %0,%1,%0";\
}")\
;;- rotate instructions

(define\_insn "rotlsi3"\
\[(set (match\_operand:SI 0 "register\_operand" "=r")\
(rotate:SI (match\_operand:SI 1 "register\_operand" "r")\
(match\_operand:SI 2 "arith\_operand" "rI")))]\
""\
"\*\
{\
if (GET\_CODE (operands\[2]) == CONST\_INT)\
{\
operands\[2] = gen\_rtx (CONST\_INT, SImode, 32 - INTVAL (operands\[2]));\
return "rot %0,%1,%2";\
}\
return "or %0,r0,32;sub %0,%2,%0;rot %0,%1,%0";\
}")

(define\_insn "rotrsi3"\
\[(set (match\_operand:SI 0 "register\_operand" "=r")\
(rotatert:SI (match\_operand:SI 1 "register\_operand" "r")\
(match\_operand:SI 2 "arith\_operand" "rI")))]\
""\
"rot %0,%1,%2")\
;; Special cases of bit-field insns which we should\
;; recognize in preference to the general case.\
;; These handle aligned 8-bit and 16-bit fields,\
;; which can usually be done with move instructions.

(define\_insn ""\
\[(set (zero\_extract:SI (match\_operand:SI 0 "general\_operand" "+ro")\
(match\_operand:SI 1 "int5\_operand" "K")\
(match\_operand:SI 2 "int5\_operand" "K"))\
(match\_operand:SI 3 "register\_operand" "r"))]\
"(INTVAL (operands\[1]) == 8 || INTVAL (operands\[1]) == 16)\
&& INTVAL (operands\[2]) % INTVAL (operands\[1]) == 0"\
"\*\
{\
if (REG\_P (operands\[0]))\
{\
if (INTVAL (operands\[1]) + INTVAL (operands\[2]) != 32)\
return "mak %0,%3,%1<%2>";\
}\
else\
operands\[0]\
\= adj\_offsettable\_operand (operands\[0], INTVAL (operands\[2]) / 8);

if (GET\_CODE (operands\[3]) == MEM)\
operands\[3] = adj\_offsettable\_operand (operands\[3],\
(32 - INTVAL (operands\[1])) / 8);\
if (INTVAL (operands\[1]) == 8)\
return "st.b %3,%0";\
return "st.w %3,%0";\
}")

(define\_insn ""\
\[(set (match\_operand:SI 0 "register\_operand" "=\&r")\
(zero\_extract:SI (match\_operand:SI 1 "general\_operand" "ro")\
(match\_operand:SI 2 "int5\_operand" "K")\
(match\_operand:SI 3 "int5\_operand" "K")))]\
"(INTVAL (operands\[2]) == 8 || INTVAL (operands\[2]) == 16)\
&& INTVAL (operands\[3]) % INTVAL (operands\[2]) == 0"\
"\*\
{\
if (REG\_P (operands\[1]))\
{\
if (INTVAL (operands\[2]) + INTVAL (operands\[3]) != 32)\
return "extu %0,%1,%2<%3>";\
}\
else\
operands\[1]\
\= adj\_offsettable\_operand (operands\[1], INTVAL (operands\[3]) / 8);

if (GET\_CODE (operands\[0]) == MEM)\
operands\[0] = adj\_offsettable\_operand (operands\[0],\
(32 - INTVAL (operands\[1])) / 8);\
if (INTVAL (operands\[2]) == 8)\
return "ld.bu %0,%1";\
return "ld.hu %0,%1";\
}")

(define\_insn ""\
\[(set (match\_operand:SI 0 "register\_operand" "=r")\
(sign\_extract:SI (match\_operand:SI 1 "general\_operand" "ro")\
(match\_operand:SI 2 "int5\_operand" "K")\
(match\_operand:SI 3 "int5\_operand" "K")))]\
"(INTVAL (operands\[2]) == 8 || INTVAL (operands\[2]) == 16)\
&& INTVAL (operands\[3]) % INTVAL (operands\[2]) == 0"\
"\*\
{\
if (REG\_P (operands\[1]))\
{\
if (INTVAL (operands\[2]) + INTVAL (operands\[3]) != 32)\
return "extu %0,%1,%2<%3>";\
}\
else\
operands\[1]\
\= adj\_offsettable\_operand (operands\[1], INTVAL (operands\[3]) / 8);

if (INTVAL (operands\[2]) == 8)\
return "ld.b %0,%1";\
return "ld.h %0,%1";\
}")\
;; Bit field instructions.

(define\_insn "extv"\
\[(set (match\_operand:SI 0 "register\_operand" "=r,r")\
(sign\_extract:SI (match\_operand:QI 1 "register\_operand" "r,r")\
(match\_operand:SI 2 "arith\_operand" "K,rK")\
(match\_operand:SI 3 "arith\_operand" "K,\&r")))]\
""\
"\*\
{\
if (GET\_CODE (operands\[3]) == CONST\_INT)\
return "ext %0,%1,%2<%3>";\
if (GET\_CODE (operands\[2]) == CONST\_INT)\
{\
operands\[2] = gen\_rtx (CONST\_INT, VOIDmode,\
(INTVAL (operands\[2]) & 0x1f) << 5);\
return "mask %3,%3,0x1f;or %3,%3,%2;ext %0,%1,%3";\
}\
return "mak %0,%2,5<5>;mask %3,%3,0x1f;or %3,%3,%0;ext %0,%1,%3";\
}")

(define\_insn ""\
\[(set (match\_operand:SI 0 "register\_operand" "=r,r")\
(sign\_extract:SI (match\_operand:SI 1 "register\_operand" "r,r")\
(match\_operand:SI 2 "arith\_operand" "K,rK")\
(match\_operand:SI 3 "arith\_operand" "K,\&r")))]\
""\
"\*\
{\
if (GET\_CODE (operands\[3]) == CONST\_INT)\
return "ext %0,%1,%2<%3>";\
if (GET\_CODE (operands\[2]) == CONST\_INT)\
{\
operands\[2] = gen\_rtx (CONST\_INT, VOIDmode,\
(INTVAL (operands\[2]) & 0x1f) << 5);\
return "mask %3,%3,0x1f;or %3,%3,%2;ext %0,%1,%3";\
}\
return "mak %0,%2,5<5>;mask %3,%3,0x1f;or %3,%3,%0;ext %0,%1,%3";\
}")

(define\_insn "extzv"\
\[(set (match\_operand:SI 0 "register\_operand" "=r,r")\
(zero\_extract:SI (match\_operand:QI 1 "register\_operand" "r,r")\
(match\_operand:SI 2 "arith\_operand" "K,Kr")\
(match\_operand:SI 3 "arith\_operand" "K,\&r")))]\
""\
"\*\
{\
if (GET\_CODE (operands\[3]) == CONST\_INT)\
return "extu %0,%1,%2<%3>";\
if (GET\_CODE (operands\[2]) == CONST\_INT)\
{\
operands\[2] = gen\_rtx (CONST\_INT, VOIDmode,\
(INTVAL (operands\[2]) & 0x1f) << 5);\
return "mask %3,%3,0x1f;or %3,%3,%2;extu %0,%1,%3";\
}\
return "mak %0,%2,5<5>;mask %3,%3,0x1f;or %3,%3,%0;ext %0,%1,%3";\
}")

(define\_insn ""\
\[(set (match\_operand:SI 0 "register\_operand" "=r,r")\
(zero\_extract:SI (match\_operand:SI 1 "register\_operand" "r,r")\
(match\_operand:SI 2 "arith\_operand" "K,Kr")\
(match\_operand:SI 3 "arith\_operand" "K,\&r")))]\
""\
"\*\
{\
if (GET\_CODE (operands\[3]) == CONST\_INT)\
return "extu %0,%1,%2<%3>";\
if (GET\_CODE (operands\[2]) == CONST\_INT)\
{\
operands\[2] = gen\_rtx (CONST\_INT, VOIDmode,\
(INTVAL (operands\[2]) & 0x1f) << 5);\
return "mask %3,%3,0x1f;or %3,%3,%2;extu %0,%1,%3";\
}\
return "mak %0,%2,5<5>;mask %3,%3,0x1f;or %3,%3,%0;ext %0,%1,%3";\
}")

(define\_insn ""\
\[(set (zero\_extract:SI (match\_operand:SI 0 "register\_operand" "r,r,r")\
(match\_operand:SI 1 "arith\_operand" "K,K,\&r")\
(match\_operand:SI 2 "arith\_operand" "K,\&r,&"))\
(const\_int 0))]\
""\
"\*\
{\
if (GET\_CODE (operands\[2]) == CONST\_INT)\
return "clr %0,%0,%1<%2>";\
if (GET\_CODE (operands\[1]) == CONST\_INT)\
{\
operands\[1] = gen\_rtx (CONST\_INT, VOIDmode,\
(INTVAL (operands\[1]) & 0x1f) << 5);\
return "mask %2,%2,0x1f;or %2,%2,%1;clr %0,%0,%2";\
}\
return "mak %1,%1,5<5>;mask %2,%2,0x1f;or %2,%2,%1;clr %0,%0,%2";\
}")

(define\_insn ""\
\[(set (zero\_extract:SI (match\_operand:SI 0 "register\_operand" "r,r,r")\
(match\_operand:SI 1 "arith\_operand" "K,K,\&r")\
(match\_operand:SI 2 "arith\_operand" "K,\&r,\&r"))\
(const\_int -1))]\
""\
"\*\
{\
if (GET\_CODE (operands\[2]) == CONST\_INT)\
return "set %0,%0,%1<%2>";\
if (GET\_CODE (operands\[1]) == CONST\_INT)\
{\
operands\[1] = gen\_rtx (CONST\_INT, VOIDmode,\
(INTVAL (operands\[1]) & 0x1f) << 5);\
return "mask %2,%2,0x1f;or %2,%2,%1;set %0,%0,%2";\
}\
return "mak %1,%1,5<5>;mask %2,%2,0x1f;or %2,%2,%1;set %0,%0,%2";\
}")

(define\_insn "insv"\
\[(set (zero\_extract:SI (match\_operand:SI 0 "register\_operand" "r,r,r")\
(match\_operand:SI 1 "arith\_operand" "K,K,\&r")\
(match\_operand:SI 2 "arith\_operand" "K,\&r,\&r"))\
(match\_operand:SI 3 "register\_operand" "\&r,\&r,r"))]\
""\
"\*\
{\
if (GET\_CODE (operands\[2]) == CONST\_INT)\
return "mak %3,%3,%1<%2>;clr %0,%0,%1<%2>;or %0,%0,%3";\
if (GET\_CODE (operands\[1]) == CONST\_INT)\
{\
operands\[1] = gen\_rtx (CONST\_INT, VOIDmode,\
(INTVAL (operands\[1]) & 0x1f) << 5);\
return "mask %2,%2,0x1f;or %2,%2,%1;mak %3,%3,%2;clr %0,%0,%2;or %0,%0,%3";\
}\
return "mak %1,%1,5<5>;mask %2,%2,0x1f;or %2,%2,%1;mak %1,%3,%2;clr %0,%0,%2;or %0,%0,%1";\
}")\
;; negate insns\
(define\_insn "negsi2"\
\[(set (match\_operand:SI 0 "register\_operand" "=r")\
(neg:SI (match\_operand:SI 1 "arith\_operand" "rI")))]\
""\
"sub %0,r0,%1")

(define\_insn "negdf2"\
\[(set (match\_operand:DF 0 "register\_operand" "=r")\
(neg:DF (match\_operand:DF 1 "register\_operand" "r")))]\
""\
"fsub.dsd %0,r0,%1")

(define\_insn "negsf2"\
\[(set (match\_operand:SF 0 "register\_operand" "=r")\
(neg:SF (match\_operand:SF 1 "register\_operand" "r")))]\
""\
"fsub.sss %0,r0,%1")\
;; Store condition code values into registers\
(define\_insn "seq"\
\[(set (match\_operand:SI 0 "general\_operand" "=g")\
(eq (cc0) (const\_int 0)))]\
""\
"\*\
{\
CC\_STATUS\_INIT;\
if (REG\_P (operands\[0]))\
return "extu %0,r25,1";\
return "extu r25,r25,1;st r25,%0";\
}")

(define\_peephole\
\[(set (cc0) (match\_operand:SI 0 "register\_operand" "r"))\
(set (match\_operand:SI 1 "general\_operand" "=g")\
(eq (cc0) (const\_int 0)))]\
""\
"\*\
{\
CC\_STATUS\_INIT;\
if (REG\_P (operands\[1]))\
return "cmp r25,%0,0;extu %1,r25,1";\
return "cmp r25,%0,0;extu r25,r25,1;st r25,%1";\
}")

(define\_peephole\
\[(set (cc0)\
(compare\
(match\_operand:SI 0 "arith\_operand" "r")\
(match\_operand:SI 1 "arith\_operand" "rI")))\
(set (match\_operand:SI 2 "general\_operand" "=g")\
(eq (cc0) (const\_int 0)))]\
""\
"\*\
{\
CC\_STATUS\_INIT;\
if (REG\_P (operands\[2]))\
return "cmp r25,%0,%1;extu %2,r25,1";\
return "cmp r25,%0,%1;extu r25,r25,1;st r25,%2";\
}")

(define\_insn "sne"\
\[(set (match\_operand:SI 0 "general\_operand" "=g")\
(ne (cc0) (const\_int 0)))]\
""\
"\*\
{\
CC\_STATUS\_INIT;\
if (REG\_P (operands\[0]))\
return "extu %0,r25,1";\
return "extu r25,r25,1;st r25,%0";\
}")

(define\_peephole\
\[(set (cc0) (match\_operand:SI 0 "register\_operand" "r"))\
(set (match\_operand:SI 1 "general\_operand" "=g")\
(ne (cc0) (const\_int 0)))]\
""\
"\*\
{\
CC\_STATUS\_INIT;\
if (REG\_P (operands\[1]))\
return "cmp r25,%0,0;extu %1,r25,1";\
return "cmp r25,%0,0;extu r25,r25,1;st r25,%1";\
}")

(define\_peephole\
\[(set (cc0)\
(compare\
(match\_operand:SI 0 "arith\_operand" "r")\
(match\_operand:SI 1 "arith\_operand" "rI")))\
(set (match\_operand:SI 2 "general\_operand" "=g")\
(ne (cc0) (const\_int 0)))]\
""\
"\*\
{\
CC\_STATUS\_INIT;\
if (REG\_P (operands\[2]))\
return "cmp r25,%0,%1;extu %2,r25,1";\
return "cmp r25,%0,%1;extu r25,r25,1;st r25,%2";\
}")

(define\_insn "sgt"\
\[(set (match\_operand:SI 0 "general\_operand" "=g")\
(gt (cc0) (const\_int 0)))]\
""\
"\*\
{\
CC\_STATUS\_INIT;\
if (REG\_P (operands\[0]))\
return "extu %0,r25,1";\
return "extu r25,r25,1;st r25,%0";\
}")

(define\_peephole\
\[(set (cc0) (match\_operand:SI 0 "register\_operand" "r"))\
(set (match\_operand:SI 1 "general\_operand" "=g")\
(gt (cc0) (const\_int 0)))]\
""\
"\*\
{\
CC\_STATUS\_INIT;\
if (REG\_P (operands\[1]))\
return "cmp r25,%0,0;extu %1,r25,1";\
return "cmp r25,%0,0;extu r25,r25,1;st r25,%1";\
}")

(define\_peephole\
\[(set (cc0)\
(compare\
(match\_operand:SI 0 "arith\_operand" "r")\
(match\_operand:SI 1 "arith\_operand" "rI")))\
(set (match\_operand:SI 2 "general\_operand" "=g")\
(gt (cc0) (const\_int 0)))]\
""\
"\*\
{\
CC\_STATUS\_INIT;\
if (REG\_P (operands\[2]))\
return "cmp r25,%0,%1;extu %2,r25,1";\
return "cmp r25,%0,%1;extu r25,r25,1;st r25,%2";\
}")

(define\_insn "sgtu"\
\[(set (match\_operand:SI 0 "general\_operand" "=g")\
(gtu (cc0) (const\_int 0)))]\
""\
"\*\
{\
CC\_STATUS\_INIT;\
if (REG\_P (operands\[0]))\
return "extu %0,r25,1";\
return "extu r25,r25,1;st r25,%0";\
}")

(define\_peephole\
\[(set (cc0) (match\_operand:SI 0 "register\_operand" "r"))\
(set (match\_operand:SI 1 "general\_operand" "=g")\
(gtu (cc0) (const\_int 0)))]\
""\
"\*\
{\
CC\_STATUS\_INIT;\
if (REG\_P (operands\[1]))\
return "cmp r25,%0,0;extu %1,r25,1";\
return "cmp r25,%0,0;extu r25,r25,1;st r25,%1";\
}")

(define\_peephole\
\[(set (cc0)\
(compare\
(match\_operand:SI 0 "arith\_operand" "r")\
(match\_operand:SI 1 "arith\_operand" "rI")))\
(set (match\_operand:SI 2 "general\_operand" "=g")\
(gtu (cc0) (const\_int 0)))]\
""\
"\*\
{\
CC\_STATUS\_INIT;\
if (REG\_P (operands\[2]))\
return "cmp r25,%0,%1;extu %2,r25,1";\
return "cmp r25,%0,%1;extu r25,r25,1;st r25,%2";\
}")

(define\_insn "slt"\
\[(set (match\_operand:SI 0 "general\_operand" "=g")\
(lt (cc0) (const\_int 0)))]\
""\
"\*\
{\
CC\_STATUS\_INIT;\
if (REG\_P (operands\[0]))\
return "extu %0,r25,1";\
return "extu r25,r25,1;st r25,%0";\
}")

(define\_peephole\
\[(set (cc0) (match\_operand:SI 0 "register\_operand" "r"))\
(set (match\_operand:SI 1 "general\_operand" "=g")\
(lt (cc0) (const\_int 0)))]\
""\
"\*\
{\
CC\_STATUS\_INIT;\
if (REG\_P (operands\[1]))\
return "cmp r25,%0,0;extu %1,r25,1";\
return "cmp r25,%0,0;extu r25,r25,1;st r25,%1";\
}")

(define\_peephole\
\[(set (cc0)\
(compare\
(match\_operand:SI 0 "arith\_operand" "r")\
(match\_operand:SI 1 "arith\_operand" "rI")))\
(set (match\_operand:SI 2 "general\_operand" "=g")\
(lt (cc0) (const\_int 0)))]\
""\
"\*\
{\
CC\_STATUS\_INIT;\
if (REG\_P (operands\[2]))\
return "cmp r25,%0,%1;extu %2,r25,1";\
return "cmp r25,%0,%1;extu r25,r25,1;st r25,%2";\
}")

(define\_insn "sltu"\
\[(set (match\_operand:SI 0 "general\_operand" "=g")\
(ltu (cc0) (const\_int 0)))]\
""\
"\*\
{\
CC\_STATUS\_INIT;\
if (REG\_P (operands\[0]))\
return "extu %0,r25,1";\
return "extu r25,r25,1;st r25,%0";\
}")

(define\_peephole\
\[(set (cc0) (match\_operand:SI 0 "register\_operand" "r"))\
(set (match\_operand:SI 1 "general\_operand" "=g")\
(ltu (cc0) (const\_int 0)))]\
""\
"\*\
{\
CC\_STATUS\_INIT;\
if (REG\_P (operands\[1]))\
return "cmp r25,%0,0;extu %1,r25,1";\
return "cmp r25,%0,0;extu r25,r25,1;st r25,%1";\
}")

(define\_peephole\
\[(set (cc0)\
(compare\
(match\_operand:SI 0 "arith\_operand" "r")\
(match\_operand:SI 1 "arith\_operand" "rI")))\
(set (match\_operand:SI 2 "general\_operand" "=g")\
(ltu (cc0) (const\_int 0)))]\
""\
"\*\
{\
CC\_STATUS\_INIT;\
if (REG\_P (operands\[2]))\
return "cmp r25,%0,%1;extu %2,r25,1";\
return "cmp r25,%0,%1;extu r25,r25,1;st r25,%2";\
}")

(define\_insn "sge"\
\[(set (match\_operand:SI 0 "general\_operand" "=g")\
(ge (cc0) (const\_int 0)))]\
""\
"\*\
{\
CC\_STATUS\_INIT;\
if (REG\_P (operands\[0]))\
return "extu %0,r25,1";\
return "extu r25,r25,1;st r25,%0";\
}")

(define\_peephole\
\[(set (cc0) (match\_operand:SI 0 "register\_operand" "r"))\
(set (match\_operand:SI 1 "general\_operand" "=g")\
(ge (cc0) (const\_int 0)))]\
""\
"\*\
{\
CC\_STATUS\_INIT;\
if (REG\_P (operands\[1]))\
return "cmp r25,%0,0;extu %1,r25,1";\
return "cmp r25,%0,0;extu r25,r25,1;st r25,%1";\
}")

(define\_peephole\
\[(set (cc0)\
(compare\
(match\_operand:SI 0 "arith\_operand" "r")\
(match\_operand:SI 1 "arith\_operand" "rI")))\
(set (match\_operand:SI 2 "general\_operand" "=g")\
(ge (cc0) (const\_int 0)))]\
""\
"\*\
{\
CC\_STATUS\_INIT;\
if (REG\_P (operands\[2]))\
return "cmp r25,%0,%1;extu %2,r25,1";\
return "cmp r25,%0,%1;extu r25,r25,1;st r25,%2";\
}")

(define\_insn "sgeu"\
\[(set (match\_operand:SI 0 "general\_operand" "=g")\
(geu (cc0) (const\_int 0)))]\
""\
"\*\
{\
CC\_STATUS\_INIT;\
if (REG\_P (operands\[0]))\
return "extu %0,r25,1";\
return "extu r25,r25,1;st r25,%0";\
}")

(define\_peephole\
\[(set (cc0) (match\_operand:SI 0 "register\_operand" "r"))\
(set (match\_operand:SI 1 "general\_operand" "=g")\
(geu (cc0) (const\_int 0)))]\
""\
"\*\
{\
CC\_STATUS\_INIT;\
if (REG\_P (operands\[1]))\
return "cmp r25,%0,0;extu %1,r25,1";\
return "cmp r25,%0,0;extu r25,r25,1;st r25,%1";\
}")

(define\_peephole\
\[(set (cc0)\
(compare\
(match\_operand:SI 0 "arith\_operand" "r")\
(match\_operand:SI 1 "arith\_operand" "rI")))\
(set (match\_operand:SI 2 "general\_operand" "=g")\
(geu (cc0) (const\_int 0)))]\
""\
"\*\
{\
CC\_STATUS\_INIT;\
if (REG\_P (operands\[2]))\
return "cmp r25,%0,%1;extu %2,r25,1";\
return "cmp r25,%0,%1;extu r25,r25,1;st r25,%2";\
}")

(define\_insn "sle"\
\[(set (match\_operand:SI 0 "general\_operand" "=g")\
(le (cc0) (const\_int 0)))]\
""\
"\*\
{\
CC\_STATUS\_INIT;\
if (REG\_P (operands\[0]))\
return "extu %0,r25,1";\
return "extu r25,r25,1;st r25,%0";\
}")

(define\_peephole\
\[(set (cc0) (match\_operand:SI 0 "register\_operand" "r"))\
(set (match\_operand:SI 1 "general\_operand" "=g")\
(le (cc0) (const\_int 0)))]\
""\
"\*\
{\
CC\_STATUS\_INIT;\
if (REG\_P (operands\[1]))\
return "cmp r25,%0,0;extu %1,r25,1";\
return "cmp r25,%0,0;extu r25,r25,1;st r25,%1";\
}")

(define\_peephole\
\[(set (cc0)\
(compare\
(match\_operand:SI 0 "arith\_operand" "r")\
(match\_operand:SI 1 "arith\_operand" "rI")))\
(set (match\_operand:SI 2 "general\_operand" "=g")\
(le (cc0) (const\_int 0)))]\
""\
"\*\
{\
CC\_STATUS\_INIT;\
if (REG\_P (operands\[2]))\
return "cmp r25,%0,%1;extu %2,r25,1";\
return "cmp r25,%0,%1;extu r25,r25,1;st r25,%2";\
}")

(define\_insn "sleu"\
\[(set (match\_operand:SI 0 "general\_operand" "=g")\
(leu (cc0) (const\_int 0)))]\
""\
"\*\
{\
CC\_STATUS\_INIT;\
if (REG\_P (operands\[0]))\
return "extu %0,r25,1";\
return "extu r25,r25,1;st r25,%0";\
}")

(define\_peephole\
\[(set (cc0) (match\_operand:SI 0 "register\_operand" "r"))\
(set (match\_operand:SI 1 "general\_operand" "=g")\
(leu (cc0) (const\_int 0)))]\
""\
"\*\
{\
CC\_STATUS\_INIT;\
if (REG\_P (operands\[1]))\
return "cmp r25,%0,0;extu %1,r25,1";\
return "cmp r25,%0,0;extu r25,r25,1;st r25,%1";\
}")

(define\_peephole\
\[(set (cc0)\
(compare\
(match\_operand:SI 0 "arith\_operand" "r")\
(match\_operand:SI 1 "arith\_operand" "rI")))\
(set (match\_operand:SI 2 "general\_operand" "=g")\
(leu (cc0) (const\_int 0)))]\
""\
"\*\
{\
CC\_STATUS\_INIT;\
if (REG\_P (operands\[2]))\
return "cmp r25,%0,%1;extu %2,r25,1";\
return "cmp r25,%0,%1;extu r25,r25,1;st r25,%2";\
}")

;; Unconditional and other jump instructions\
(define\_insn "jump"\
\[(set (pc)\
(label\_ref (match\_operand 0 "" "")))]\
""\
"br %l0")

(define\_insn ""\
\[(set (pc)\
(label\_ref (match\_operand 0 "" "")))\
(clobber (const\_int 1))]\
""\
"br.n %l0")

(define\_insn "tablejump"\
\[(set (pc) (match\_operand:SI 0 "register\_operand" "r"))\
(use (label\_ref (match\_operand 1 "" "")))]\
""\
"jmp %0")

;;- jump to subroutine\
(define\_insn "call"\
\[(call (match\_operand:SI 0 "memory\_operand" "m")\
(match\_operand:SI 1 "general\_operand" "g"))\
(use (reg:SI 1))]\
;;- Don't use operand 1 for most machines.\
""\
"\*\
{\
operands\[0] = XEXP (operands\[0], 0);\
if (REG\_P (operands\[0]))\
return "jsr %0";\
return "bsr %0";\
}")

(define\_insn ""\
\[(call (match\_operand:SI 0 "memory\_operand" "m")\
(match\_operand:SI 1 "general\_operand" "g"))\
(clobber (const\_int 1))\
(use (reg:SI 1))]\
;;- Don't use operand 1 for most machines.\
""\
"\*\
{\
operands\[0] = XEXP (operands\[0], 0);\
if (REG\_P (operands\[0]))\
return "jsr.n %0";\
return "bsr.n %0";\
}")

;;- jump to subroutine\
(define\_insn "call\_value"\
\[(set (match\_operand 0 "" "=r")\
(call (match\_operand:SI 1 "memory\_operand" "m")\
(match\_operand:SI 2 "general\_operand" "g")))\
(use (reg:SI 1))]\
;;- Don't use operand 2 for most machines.\
""\
"\*\
{\
operands\[1] = XEXP (operands\[1], 0);\
if (REG\_P (operands\[1]))\
return "jsr %1";\
return "bsr %1";\
}")

(define\_insn ""\
\[(set (match\_operand 0 "" "=r")\
(call (match\_operand:SI 1 "memory\_operand" "m")\
(match\_operand:SI 2 "general\_operand" "g")))\
(use (reg:SI 1))\
(clobber (const\_int 2))]\
;;- Don't use operand 2 for most machines.\
""\
"\*\
{\
operands\[1] = XEXP (operands\[1], 0);\
if (REG\_P (operands\[1]))\
return "jsr.n %1";\
return "bsr.n %1";\
}")

;; A memory ref with constant address is not normally valid.\
;; But it is valid in a call insns. This pattern allows the\
;; loading of the address to combine with the call.\
(define\_insn ""\
\[(call (mem:SI (match\_operand:SI 0 "" "i"))\
(match\_operand:SI 1 "general\_operand" "g"))\
(use (reg:SI 1))]\
;;- Don't use operand 1 for most machines.\
"GET\_CODE (operands\[0]) == SYMBOL\_REF"\
"bsr %0")

(define\_insn ""\
\[(call (mem:SI (match\_operand:SI 0 "" "i"))\
(match\_operand:SI 1 "general\_operand" "g"))\
(clobber (const\_int 1))\
(use (reg:SI 1))]\
;;- Don't use operand 1 for most machines.\
"GET\_CODE (operands\[0]) == SYMBOL\_REF"\
"bsr.n %0")

(define\_insn "nop"\
\[(const\_int 0)]\
""\
"nop")\
;; Recognize jbs and jbc instructions.

(define\_insn ""\
\[(set (pc)\
(if\_then\_else\
(ne (sign\_extract:SI (match\_operand:SI 0 "register\_operand" "r")\
(const\_int 1)\
(match\_operand:SI 1 "int5\_operand" "K"))\
(const\_int 0))\
(label\_ref (match\_operand 2 "" ""))\
(pc)))]\
""\
"bb1 %1,%0,%l2")

(define\_insn ""\
\[(set (pc)\
(if\_then\_else\
(eq (sign\_extract:SI (match\_operand:SI 0 "register\_operand" "r")\
(const\_int 1)\
(match\_operand:SI 1 "int5\_operand" "K"))\
(const\_int 0))\
(label\_ref (match\_operand 2 "" ""))\
(pc)))]\
""\
"bb0 %1,%0,%l2")

(define\_insn ""\
\[(set (pc)\
(if\_then\_else\
(ne (sign\_extract:SI (match\_operand:SI 0 "register\_operand" "r")\
(const\_int 1)\
(match\_operand:SI 1 "int5\_operand" "K"))\
(const\_int 0))\
(pc)\
(label\_ref (match\_operand 2 "" ""))))]\
""\
"bb0 %1,%0,%l2")

(define\_insn ""\
\[(set (pc)\
(if\_then\_else\
(eq (sign\_extract:SI (match\_operand:SI 0 "register\_operand" "r")\
(const\_int 1)\
(match\_operand:SI 1 "int5\_operand" "K"))\
(const\_int 0))\
(pc)\
(label\_ref (match\_operand 2 "" ""))))]\
""\
"bb1 %1,%0,%l2")

(define\_insn ""\
\[(set (pc)\
(if\_then\_else\
(ne (sign\_extract:SI (match\_operand:SI 0 "general\_operand" "r")\
(const\_int 1)\
(match\_operand:SI 1 "int5\_operand" "K"))\
(const\_int 0))\
(label\_ref (match\_operand 2 "" ""))\
(pc)))]\
""\
"bb1 %1,%0,%l2")

(define\_insn ""\
\[(set (pc)\
(if\_then\_else\
(eq (sign\_extract:SI (match\_operand:SI 0 "general\_operand" "r")\
(const\_int 1)\
(match\_operand:SI 1 "int5\_operand" "K"))\
(const\_int 0))\
(label\_ref (match\_operand 2 "" ""))\
(pc)))]\
""\
"bb0 %1,%0,%l2")

(define\_insn ""\
\[(set (pc)\
(if\_then\_else\
(eq (and:SI (match\_operand:SI 0 "register\_operand" "r")\
(match\_operand:SI 1 "int5\_operand" "K"))\
(const\_int 0))\
(pc)\
(label\_ref (match\_operand 2 "" ""))))]\
"exact\_log2 (INTVAL (operands\[1])) >= 0"\
"\*\
{\
operands\[1]\
\= gen\_rtx (CONST\_INT, VOIDmode, exact\_log2 (INTVAL (operands\[1])));\
return "bb1 %1,%0,%l2";\
}")

(define\_insn ""\
\[(set (pc)\
(if\_then\_else\
(eq (and:SI (match\_operand:SI 0 "register\_operand" "r")\
(match\_operand:SI 1 "int5\_operand" "K"))\
(const\_int 0))\
(label\_ref (match\_operand 2 "" ""))\
(pc)))]\
"exact\_log2 (INTVAL (operands\[1])) >= 0"\
"\*\
{\
operands\[1]\
\= gen\_rtx (CONST\_INT, VOIDmode, exact\_log2 (INTVAL (operands\[1])));\
return "bb0 %1,%0,%l2";\
}")

(define\_insn ""\
\[(set (pc)\
(if\_then\_else\
(ne (and:SI (match\_operand:SI 0 "register\_operand" "r")\
(match\_operand:SI 1 "int5\_operand" "K"))\
(const\_int 0))\
(pc)\
(label\_ref (match\_operand 2 "" ""))))]\
"exact\_log2 (INTVAL (operands\[1])) >= 0"\
"\*\
{\
operands\[1]\
\= gen\_rtx (CONST\_INT, VOIDmode, exact\_log2 (INTVAL (operands\[1])));\
return "bb0 %1,%0,%l2";\
}")

(define\_insn ""\
\[(set (pc)\
(if\_then\_else\
(ne (and:SI (match\_operand:SI 0 "register\_operand" "r")\
(match\_operand:SI 1 "int5\_operand" "K"))\
(const\_int 0))\
(label\_ref (match\_operand 2 "" ""))\
(pc)))]\
"exact\_log2 (INTVAL (operands\[1])) >= 0"\
"\*\
{\
operands\[1]\
\= gen\_rtx (CONST\_INT, VOIDmode, exact\_log2 (INTVAL (operands\[1])));\
return "bb1 %1,%0,%l2";\
}")

(define\_insn ""\
\[(set (pc)\
(if\_then\_else\
(ne (sign\_extract:SI (match\_operand:SI 0 "general\_operand" "r")\
(const\_int 1)\
(match\_operand:SI 1 "int5\_operand" "K"))\
(const\_int 0))\
(pc)\
(label\_ref (match\_operand 2 "" ""))))]\
""\
"bb0 %1,%0,%l2")

(define\_insn ""\
\[(set (pc)\
(if\_then\_else\
(eq (sign\_extract:SI (match\_operand:SI 0 "general\_operand" "r")\
(const\_int 1)\
(match\_operand:SI 1 "int5\_operand" "K"))\
(const\_int 0))\
(pc)\
(label\_ref (match\_operand 2 "" ""))))]\
""\
"bb1 %1,%0,%l2")

(define\_insn ""\
\[(set (pc)\
(if\_then\_else\
(ne (and:SI (match\_operand:SI 0 "register\_operand" "r")\
(const\_int 1))\
(const\_int 0))\
(label\_ref (match\_operand 1 "" ""))\
(pc)))]\
""\
"bb1 0,%0,%l1")

(define\_insn ""\
\[(set (pc)\
(if\_then\_else\
(eq (and:SI (match\_operand:SI 0 "register\_operand" "r")\
(const\_int 1))\
(const\_int 0))\
(label\_ref (match\_operand 1 "" ""))\
(pc)))]\
""\
"bb0 0,%0,%l1")

(define\_insn ""\
\[(set (pc)\
(if\_then\_else\
(ne (and:SI (match\_operand:SI 0 "register\_operand" "r")\
(const\_int 1))\
(const\_int 0))\
(pc)\
(label\_ref (match\_operand 1 "" ""))))]\
""\
"bb0 0,%0,%l1")

(define\_insn ""\
\[(set (pc)\
(if\_then\_else\
(eq (and:SI (match\_operand:SI 0 "register\_operand" "r")\
(const\_int 1))\
(const\_int 0))\
(pc)\
(label\_ref (match\_operand 1 "" ""))))]\
""\
"bb1 0,%0,%l1")

;; These four entries allow a jlbc or jlbs,to be made\
;; by combination with a bic.\
(define\_insn ""\
\[(set (pc)\
(if\_then\_else\
(ne (and:SI (match\_operand:SI 0 "register\_operand" "r")\
(not:SI (const\_int -2)))\
(const\_int 0))\
(label\_ref (match\_operand 1 "" ""))\
(pc)))]\
""\
"bb1 0,%0,%l1")

(define\_insn ""\
\[(set (pc)\
(if\_then\_else\
(eq (and:SI (match\_operand:SI 0 "register\_operand" "r")\
(not:SI (const\_int -2)))\
(const\_int 0))\
(label\_ref (match\_operand 1 "" ""))\
(pc)))]\
""\
"bb0 0,%0,%l1")

(define\_insn ""\
\[(set (pc)\
(if\_then\_else\
(ne (and:SI (match\_operand:SI 0 "register\_operand" "r")\
(not:SI (const\_int -2)))\
(const\_int 0))\
(pc)\
(label\_ref (match\_operand 1 "" ""))))]\
""\
"bb0 0,%0,%l1")

(define\_insn ""\
\[(set (pc)\
(if\_then\_else\
(eq (and:SI (match\_operand:SI 0 "register\_operand" "r")\
(not:SI (const\_int -2)))\
(const\_int 0))\
(pc)\
(label\_ref (match\_operand 1 "" ""))))]\
""\
"bb1 0,%0,%l1")\
;;- Local variables:\
;;- mode:emacs-lisp\
;;- comment-start: ";;- "\
;;- eval: (set-syntax-table (copy-sequence (syntax-table)))\
;;- eval: (modify-syntax-entry ?\[ "(]")\
;;- eval: (modify-syntax-entry ?] ")\[")\
;;- eval: (modify-syntax-entry ?{ "(}")\
;;- eval: (modify-syntax-entry ?} "){")\
;;- End:
