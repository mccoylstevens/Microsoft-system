# m68k

;;- Machine description for GNU compiler\
;;- Motorola 68000 Version\
;; Copyright (C) 1987, 1988 Free Software Foundation, Inc.

;; This file is part of GNU CC.

;; GNU CC is free software; you can redistribute it and/or modify\
;; it under the terms of the GNU General Public License as published by\
;; the Free Software Foundation; either version 1, or (at your option)\
;; any later version.

;; GNU CC is distributed in the hope that it will be useful,\
;; but WITHOUT ANY WARRANTY; without even the implied warranty of\
;; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\
;; GNU General Public License for more details.

;; You should have received a copy of the GNU General Public License\
;; along with GNU CC; see the file COPYING. If not, write to\
;; the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.

;;- instruction definitions

;;- @@The original PO technology requires these to be ordered by speed,\
;;- @@ so that assigner will pick the fastest.

;;- See file "rtl.def" for documentation on define\_insn, match\_\*, et. al.

;;- When naming insn's (operand 0 of define\_insn) be careful about using\
;;- names from other targets machine descriptions.

;;- cpp macro #define NOTICE\_UPDATE\_CC in file tm.h handles condition code\
;;- updates for most instructions.

;;- Operand classes for the register allocator:\
;;- 'a' one of the address registers can be used.\
;;- 'd' one of the data registers can be used.\
;;- 'f' one of the m68881 registers can be used\
;;- 'r' either a data or an address register can be used.\
;;- 'x' if one of the Sun FPA registers\
;;- 'y' if one of the Low Sun FPA registers (fpa0-fpa15).

;;- Immediate Floating point operator constraints\
;;- 'G' a floating point constant that is _NOT_ one of the standard\
;; 68881 constant values (to force calling output\_move\_const\_double\
;; to get it from rom if it is a 68881 constant).\
;;- 'H' one of the standard FPA constant values\
;;\
;; See the functions standard\_XXX\_constant\_p in output-m68k.c for more\
;; info.

;;- Immediate integer operand constraints:\
;;- 'I' 1 .. 8\
;;- 'J' -32768 .. 32767\
;;- 'K' -128 .. 127\
;;- 'L' -8 .. -1

;;- FPA port explanation:

;;- Usage of the Sun FPA and the 68881 together

;;- The current port of gcc to the sun fpa disallows use of the m68881\
;;- instructions completely if code is targetted for the fpa. This is\
;;- for the following reasons:

;;- 1) Expressing the preference hierarchy (ie. use the fpa if you\
;;- can, the 68881 otherwise, and data registers only if you are\
;;- forced to it) is a bitch with the current constraint scheme,\
;;- especially since it would have to work for any combination of\
;;- -mfpa, -m68881.

;;- 2) There are no instructions to move between the two types of\
;;- registers; the stack must be used as an intermediary.

;;- It could indeed be done; I think the best way would be to have\
;;- seperate patterns for TARGET\_FPA (which implies a 68881),\
;;- TARGET\_68881, and no floating point co-processor. Use\
;;- define\_expands for all of the named instruction patterns, and\
;;- include code in the FPA instruction to deal with the 68881 with\
;;- preferences specifically set to favor the fpa. Some of this has\
;;- already been done:\
;;-\
;;- 1) Separation of most of the patterns out into a TARGET\_FPA\
;;- case and a TARGET\_68881 case (the exceptions are the patterns\
;;- which would need one define\_expand and three define\_insn's under\
;;- it (with alot of duplicate code between them) to replace the\
;;- current single define\_insn. These are mov{\[ds]f,\[ds]i} and the\
;;- first two patterns in the md.\
;;-\
;;- Some would still have to be done:\
;;-\
;;- 1) Add code to the fpa patterns which correspond to 68881\
;;- patterns to deal with the 68881 case (including preferences!).\
;;- What you might actually do here is combine the fpa and 68881 code\
;;- back together into one pattern for those instructions where it's\
;;- absolutely necessary and save yourself some duplicate code. I'm\
;;- not completely sure as to whether you could get away with doing\
;;- this only for the mov\* insns, or if you'd have to do it for all\
;;- named insns.\
;;- 2) Add code to the mov{\[ds]f,\[ds]i} instructions to handle\
;;- moving between fpa regs and 68881 regs.

;;- Since the fpa is more powerful than the 68881 and also has more\
;;- registers, and since I think the reultant md would be medium ugly\
;;- (lot's of duplicate code, ugly constraint strings), I elected not\
;;- to do this change.

;;- Another reason why someone _might_ want to do the change is to\
;;- control which register classes are accessed in a slightly cleaner\
;;- way than I have. See the blurb on CONDITIONAL\_REGISTER\_USAGE in\
;;- the internals manual.

;;- Yet another reason why someone might want to do this change is to\
;;- allow use of some of the 68881 insns which have no equivalent on\
;;- the fpa. The sqrt instruction comes fairly quickly to mind.

;;- If this is ever done, don't forget to change tm-sun3.h so that\
;;- it _will_ define **HAVE\_68881** when the FPA is in use.

;;- Condition code hack

;;- When a floating point compare is done in the fpa, the resulting\
;;- condition codes are left in the fpastatus register. The values in\
;;- this register must be moved into the 68000 cc register before any\
;;- jump is executed. Once this has been done, regular jump\
;;- instructions are fine (ie. floating point jumps are not necessary.\
;;- They are only done if the cc is in the 68881).

;;- The instructions that move the fpastatus register to the 68000\
;;- register clobber a data register (the move cannot be done direct).\
;;- These instructions might be bundled either with the compare\
;;- instruction, or the branch instruction. If we were using both the\
;;- fpa and the 68881 together, we would wish to only mark the\
;;- register clobbered if we were doing the compare in the fpa, but I\
;;- think that that decision (whether to clobber the register or not)\
;;- must be done before register allocation (makes sense) and hence we\
;;- can't know if the floating point compare will be done in the fpa\
;;- or the fp. So whenever we are asked for code that uses the fpa,\
;;- we will mark a data register as clobbered. This is reasonable, as\
;;- almost all floating point compare operations done with fpa code\
;;- enabled will be done in the fpa. It's even more reasonable since\
;;- we decided to make the 68881 and the fpa mutually exclusive.

;;- We place to code to move the fpastatus register inside of a\
;;- define\_expand so that we can do it conditionally based on whether\
;;- we are tagetting an fpa or not.

;;- This still leaves us with the question of where we wish to put the\
;;- code to move the fpastatus reg. If we put it in the compare\
;;- instruction, we can restrict the clobbering of the register to\
;;- floating point compares, but we can't take advantage of floating\
;;- point subtracts & etc. that alter the fpastatus register. If we\
;;- put it in the branch instruction, all branches compiled with fpa\
;;- code enabled will clobber a data register, but we will be able to\
;;- take advantage of fpa subtracts. This balance favors putting the\
;;- code in with the compare instruction.

;;- Note that if some enterprising hacker should decide to switch\
;;- this, he'll need to modify the code in NOTICE\_UPDATE\_CC.

;;- Usage of the top 16 fpa registers

;;- The only locations which we may transfer fpa registers 16-31 from\
;;- or to are the fpa registers 0-15. (68000 registers and memory\
;;- locations are impossible). This causes problems in gcc, which\
;;- assumes that mov?? instructions require no additional registers\
;;- (see section 11.7) and since floating point moves _must_ be\
;;- supported into general registers (see section 12.3 under\
;;- HARD\_REGNO\_OK\_FOR\_MODE\_P) from anywhere.

;;- My solution was to reserve fpa0 for moves into or out of these top\
;;- 16 registers and to disparage the choice to reload into or out of\
;;- these registers as much as I could. That alternative is always\
;;- last in the list, so it will not be used unless all else fails. I\
;;- will note that according to my current information, sun's compiler\
;;- doesn't use these top 16 registers at all.

;;- There is another possible way to do it. I _believe_ that if you\
;;- make absolutely sure that the code will not be exectued in the\
;;- reload pass, you can support the mov?? names with define\_expands\
;;- which require new registers. This may be possible by the\
;;- appropriate juggling of constraints. I may come back to this later.

;;- Usage of constant RAM

;;- This has been handled correctly (I believe) but the way I've done\
;;- it could use a little explanation. The constant RAM can only be\
;;- accessed when the instruction is in "command register" mode.\
;;- "command register" mode means that no accessing of memory or the\
;;- 68000 registers is being done. This can be expressed easily in\
;;- constraints, so generally the mode of the instruction is\
;;- determined by a branch off of which\_alternative. In outputing\
;;- instructions, a 'w' means to output an access to the constant ram\
;;- (if the arg is CONST\_DOUBLE and is one of the available\
;;- constants), and 'x' means to output a register pair (if the arg is\
;;- a 68000 register) and a 'y' is the combination of the above two\
;;- processies. You use a 'y' in two operand DF instructions where you\
;;- _know_ the other operand is an fpa register, you use an 'x' in DF\
;;- instructions where the arg might be a 68000 register and the\
;;- instruction is _not_ in "command register" mode, and you use a 'w'\
;;- in two situations: 1) The instruction _is_ in command register\
;;- mode (and hence won't be accessing 68000 registers), or 2) The\
;;- instruction is a two operand SF instruction where you know the\
;;- other operand is an fpa register.

;;- Optimization issues

;;- I actually think that I've included all of the fpa instructions\
;;- that should be included. Note that if someone is interested in\
;;- doing serious floating point work on the sun fpa, I would advise\
;;- the use of the "asm" instruction in gcc to allow you to use the\
;;- sin, cos, and exponential functions on the fpa board.

;;- END FPA Explanation Section.

;;- Some of these insn's are composites of several m68000 op codes.\
;;- The assembler (or final @@??) insures that the appropriate one is\
;;- selected.\
(define\_insn ""\
\[(set (match\_operand:DF 0 "push\_operand" "=m")\
(match\_operand:DF 1 "general\_operand" "ro<>fyF"))]\
""\
"\*\
{\
if (FP\_REG\_P (operands\[1]))\
return "fmove%.d %f1,%0";\
if (FPA\_REG\_P (operands\[1]))\
return "fpmove%.d %1, %x0";\
return output\_move\_double (operands);\
}")

(define\_insn ""\
\[(set (match\_operand:DI 0 "push\_operand" "=m")\
(match\_operand:DI 1 "general\_operand" "ro<>Fy"))]\
""\
"\*\
{\
return output\_move\_double (operands);\
}")\
;; Put tstsi first among test insns so it matches a CONST\_INT operand.

(define\_insn "tstsi"\
\[(set (cc0)\
(match\_operand:SI 0 "general\_operand" "rm"))]\
""\
"\*\
{\
\#ifdef ISI\_OV\
/\* ISI's assembler fails to handle tstl a0. _/_\
_if (! ADDRESS\_REG\_P (operands\[0]))_\
_#else_\
_if (TARGET\_68020 || ! ADDRESS\_REG\_P (operands\[0]))_\
_#endif_\
_return "tst%.l %0";_\
_/_ If you think that the 68020 does not support tstl a0,\
reread page B-167 of the 68020 manual more carefully. _/_\
_/_ On an address reg, cmpw may replace cmpl. \*/\
\#ifdef HPUX\_ASM\
return "cmp%.w %0,%#0";\
\#else\
return "cmp%.w %#0,%0";\
\#endif\
}")

(define\_insn "tsthi"\
\[(set (cc0)\
(match\_operand:HI 0 "general\_operand" "rm"))]\
""\
"\*\
{\
\#ifdef ISI\_OV\
if (! ADDRESS\_REG\_P (operands\[0]))\
\#else\
if (TARGET\_68020 || ! ADDRESS\_REG\_P (operands\[0]))\
\#endif\
return "tst%.w %0";\
\#ifdef HPUX\_ASM\
return "cmp%.w %0,%#0";\
\#else\
return "cmp%.w %#0,%0";\
\#endif\
}")

(define\_insn "tstqi"\
\[(set (cc0)\
(match\_operand:QI 0 "general\_operand" "dm"))]\
""\
"tst%.b %0")

(define\_expand "tstsf"\
\[(set (cc0)\
(match\_operand:SF 0 "general\_operand" ""))]\
"TARGET\_68881 || TARGET\_FPA"\
"\
{\
if (TARGET\_FPA)\
{\
emit\_insn (gen\_rtx (PARALLEL, VOIDmode,\
gen\_rtvec (2,\
gen\_rtx (SET, VOIDmode,\
cc0\_rtx, operands\[0]),\
gen\_rtx (CLOBBER, VOIDmode,\
gen\_reg\_rtx (SImode)))));\
DONE;\
}\
}")

(define\_insn ""\
\[(set (cc0)\
(match\_operand:SF 0 "general\_operand" "xmdF"))\
(clobber (match\_operand:SI 1 "general\_operand" "d"))]\
"TARGET\_FPA"\
"fptst%.s %x0;fpmove fpastatus,%1;movw %1,cc")

(define\_insn ""\
\[(set (cc0)\
(match\_operand:SF 0 "general\_operand" "fdm"))]\
"TARGET\_68881"\
"\*\
{\
cc\_status.flags = CC\_IN\_68881;\
if (FP\_REG\_P (operands\[0]))\
return "ftst%.x %0";\
return "ftst%.s %0";\
}")

(define\_expand "tstdf"\
\[(set (cc0)\
(match\_operand:DF 0 "general\_operand" ""))]\
"TARGET\_68881 || TARGET\_FPA"\
"\
{\
if (TARGET\_FPA)\
{\
emit\_insn (gen\_rtx (PARALLEL, VOIDmode,\
gen\_rtvec (2, gen\_rtx (SET, VOIDmode,\
cc0\_rtx, operands\[0]),\
gen\_rtx (CLOBBER, VOIDmode,\
gen\_reg\_rtx (SImode)))));\
DONE;\
}\
}")

(define\_insn ""\
\[(set (cc0)\
(match\_operand:DF 0 "general\_operand" "xrmF"))\
(clobber (match\_operand:SI 1 "general\_operand" "d"))]\
"TARGET\_FPA"\
"fptst%.d %x0;fpmove fpastatus,%1;movw %1,cc")

(define\_insn ""\
\[(set (cc0)\
(match\_operand:DF 0 "general\_operand" "fm"))]\
"TARGET\_68881"\
"\*\
{\
cc\_status.flags = CC\_IN\_68881;\
if (FP\_REG\_P (operands\[0]))\
return "ftst%.x %0";\
return "ftst%.d %0";\
}")\
;; compare instructions.

;; Put cmpsi first among compare insns so it matches two CONST\_INT operands.

;; A composite of the cmp, cmpa, & cmpi m68000 op codes.\
(define\_insn "cmpsi"\
\[(set (cc0)\
(compare (match\_operand:SI 0 "general\_operand" "rKs,mr,>")\
(match\_operand:SI 1 "general\_operand" "mr,Ksr,>")))]\
""\
"\*\
{\
if (GET\_CODE (operands\[0]) == MEM && GET\_CODE (operands\[1]) == MEM)\
return "cmpm%.l %1,%0";\
if (REG\_P (operands\[1])\
|| (!REG\_P (operands\[0]) && GET\_CODE (operands\[0]) != MEM))\
{ cc\_status.flags |= CC\_REVERSED;\
\#ifdef HPUX\_ASM\
return "cmp%.l %d1,%d0";\
\#else\
return "cmp%.l %d0,%d1";\
\#endif\
}\
\#ifdef HPUX\_ASM\
return "cmp%.l %d0,%d1";\
\#else\
return "cmp%.l %d1,%d0";\
\#endif\
}")

(define\_insn "cmphi"\
\[(set (cc0)\
(compare (match\_operand:HI 0 "general\_operand" "rnm,d,n,m")\
(match\_operand:HI 1 "general\_operand" "d,rnm,m,n")))]\
""\
"\*\
{\
if (GET\_CODE (operands\[0]) == MEM && GET\_CODE (operands\[1]) == MEM)\
return "cmpm%.w %1,%0";\
if ((REG\_P (operands\[1]) && !ADDRESS\_REG\_P (operands\[1]))\
|| (!REG\_P (operands\[0]) && GET\_CODE (operands\[0]) != MEM))\
{ cc\_status.flags |= CC\_REVERSED;\
\#ifdef HPUX\_ASM\
return "cmp%.w %d1,%d0";\
\#else\
return "cmp%.w %d0,%d1";\
\#endif\
}\
\#ifdef HPUX\_ASM\
return "cmp%.w %d0,%d1";\
\#else\
return "cmp%.w %d1,%d0";\
\#endif\
}")

(define\_insn "cmpqi"\
\[(set (cc0)\
(compare (match\_operand:QI 0 "general\_operand" "dn,md,>")\
(match\_operand:QI 1 "general\_operand" "dm,nd,>")))]\
""\
"\*\
{\
if (GET\_CODE (operands\[0]) == MEM && GET\_CODE (operands\[1]) == MEM)\
return "cmpm%.b %1,%0";\
if (REG\_P (operands\[1])\
|| (!REG\_P (operands\[0]) && GET\_CODE (operands\[0]) != MEM))\
{ cc\_status.flags |= CC\_REVERSED;\
\#ifdef HPUX\_ASM\
return "cmp%.b %d1,%d0";\
\#else\
return "cmp%.b %d0,%d1";\
\#endif\
}\
\#ifdef HPUX\_ASM\
return "cmp%.b %d0,%d1";\
\#else\
return "cmp%.b %d1,%d0";\
\#endif\
}")

(define\_expand "cmpdf"\
\[(set (cc0)\
(compare (match\_operand:DF 0 "general\_operand" "")\
(match\_operand:DF 1 "general\_operand" "")))]\
"TARGET\_68881 || TARGET\_FPA"\
"\
{\
if (TARGET\_FPA)\
{\
rtx set = gen\_rtx (SET, VOIDmode, cc0\_rtx,\
gen\_rtx (COMPARE, VOIDmode, operands\[0], operands\[1]));\
emit\_insn (gen\_rtx (PARALLEL, VOIDmode,\
gen\_rtvec (2, set,\
gen\_rtx (CLOBBER, VOIDmode,\
gen\_reg\_rtx (SImode)))));\
DONE;\
}\
}")

(define\_insn ""\
\[(set (cc0)\
(compare (match\_operand:DF 0 "general\_operand" "x,y")\
(match\_operand:DF 1 "general\_operand" "xH,rmF")))\
(clobber (match\_operand:SI 2 "general\_operand" "d,d"))]\
"TARGET\_FPA"\
"fpcmp%.d %y1,%0;fpmove fpastatus,%2;movw %2,cc")

(define\_insn ""\
\[(set (cc0)\
(compare (match\_operand:DF 0 "general\_operand" "f,mG")\
(match\_operand:DF 1 "general\_operand" "fmG,f")))]\
"TARGET\_68881"\
"\*\
{\
cc\_status.flags = CC\_IN\_68881;\
\#ifdef HPUX\_ASM\
if (REG\_P (operands\[0]))\
{\
if (REG\_P (operands\[1]))\
return "fcmp%.x %0,%1";\
else\
return "fcmp%.d %0,%f1";\
}\
cc\_status.flags |= CC\_REVERSED;\
return "fcmp%.d %1,%f0";\
\#else\
if (REG\_P (operands\[0]))\
{\
if (REG\_P (operands\[1]))\
return "fcmp%.x %1,%0";\
else\
return "fcmp%.d %f1,%0";\
}\
cc\_status.flags |= CC\_REVERSED;\
return "fcmp%.d %f0,%1";\
\#endif\
}")

(define\_expand "cmpsf"\
\[(set (cc0)\
(compare (match\_operand:SF 0 "general\_operand" "")\
(match\_operand:SF 1 "general\_operand" "")))]\
"TARGET\_68881 || TARGET\_FPA"\
"\
{\
if (TARGET\_FPA)\
{\
rtx set = gen\_rtx (SET, VOIDmode, cc0\_rtx,\
gen\_rtx (COMPARE, VOIDmode, operands\[0], operands\[1]));\
emit\_insn (gen\_rtx (PARALLEL, VOIDmode,\
gen\_rtvec (2, set,\
gen\_rtx (CLOBBER, VOIDmode,\
gen\_reg\_rtx(SImode)))));\
DONE;\
}\
}")

(define\_insn ""\
\[(set (cc0)\
(compare (match\_operand:SF 0 "general\_operand" "x,y")\
(match\_operand:SF 1 "general\_operand" "xH,rmF")))\
(clobber (match\_operand:SI 2 "general\_operand" "d,d"))]\
"TARGET\_FPA"\
"fpcmp%.s %w1,%x0;fpmove fpastatus,%2;movw %2,cc")

(define\_insn ""\
\[(set (cc0)\
(compare (match\_operand:SF 0 "general\_operand" "f,mdG")\
(match\_operand:SF 1 "general\_operand" "fmdG,f")))]\
"TARGET\_68881"\
"\*\
{\
cc\_status.flags = CC\_IN\_68881;\
\#ifdef HPUX\_ASM\
if (FP\_REG\_P (operands\[0]))\
{\
if (FP\_REG\_P (operands\[1]))\
return "fcmp%.x %0,%1";\
else\
return "fcmp%.s %0,%f1";\
}\
cc\_status.flags |= CC\_REVERSED;\
return "fcmp%.s %1,%f0";\
\#else\
if (FP\_REG\_P (operands\[0]))\
{\
if (FP\_REG\_P (operands\[1]))\
return "fcmp%.x %1,%0";\
else\
return "fcmp%.s %f1,%0";\
}\
cc\_status.flags |= CC\_REVERSED;\
return "fcmp%.s %f0,%1";\
\#endif\
}")\
;; Recognizers for btst instructions.

(define\_insn ""\
\[(set (cc0) (zero\_extract (match\_operand:QI 0 "nonimmediate\_operand" "do")\
(const\_int 1)\
(minus:SI (const\_int 7)\
(match\_operand:SI 1 "general\_operand" "di"))))]\
""\
"\* { return output\_btst (operands, operands\[1], operands\[0], insn, 7); }")

(define\_insn ""\
\[(set (cc0) (zero\_extract (match\_operand:SI 0 "nonimmediate\_operand" "d")\
(const\_int 1)\
(minus:SI (const\_int 31)\
(match\_operand:SI 1 "general\_operand" "di"))))]\
""\
"\* { return output\_btst (operands, operands\[1], operands\[0], insn, 31); }")

;; The following two patterns are like the previous two\
;; except that they use the fact that bit-number operands\
;; are automatically masked to 3 or 5 bits.

(define\_insn ""\
\[(set (cc0) (zero\_extract (match\_operand:QI 0 "nonimmediate\_operand" "do")\
(const\_int 1)\
(minus:SI (const\_int 7)\
(and:SI\
(match\_operand:SI 1 "general\_operand" "d")\
(const\_int 7)))))]\
""\
"\* { return output\_btst (operands, operands\[1], operands\[0], insn, 7); }")

(define\_insn ""\
\[(set (cc0) (zero\_extract (match\_operand:SI 0 "nonimmediate\_operand" "d")\
(const\_int 1)\
(minus:SI (const\_int 31)\
(and:SI\
(match\_operand:SI 1 "general\_operand" "d")\
(const\_int 31)))))]\
""\
"\* { return output\_btst (operands, operands\[1], operands\[0], insn, 31); }")

;; Nonoffsettable mem refs are ok in this one pattern\
;; since we don't try to adjust them.\
(define\_insn ""\
\[(set (cc0) (zero\_extract (match\_operand:QI 0 "nonimmediate\_operand" "md")\
(const\_int 1)\
(match\_operand:SI 1 "general\_operand" "i")))]\
"GET\_CODE (operands\[1]) == CONST\_INT\
&& (unsigned) INTVAL (operands\[1]) < 8"\
"\*\
{\
operands\[1] = gen\_rtx (CONST\_INT, VOIDmode, 7 - INTVAL (operands\[1]));\
return output\_btst (operands, operands\[1], operands\[0], insn, 7);\
}")

(define\_insn ""\
;; The constraint "o,d" here means that a nonoffsettable memref\
;; will match the first alternative, and its address will be reloaded.\
;; Copying the memory contents into a reg would be incorrect if the\
;; bit position is over 7.\
\[(set (cc0) (zero\_extract (match\_operand:HI 0 "nonimmediate\_operand" "o,d")\
(const\_int 1)\
(match\_operand:SI 1 "general\_operand" "i,i")))]\
"GET\_CODE (operands\[1]) == CONST\_INT"\
"\*\
{\
if (GET\_CODE (operands\[0]) == MEM)\
{\
operands\[0] = adj\_offsettable\_operand (operands\[0],\
INTVAL (operands\[1]) / 8);\
operands\[1] = gen\_rtx (CONST\_INT, VOIDmode,\
7 - INTVAL (operands\[1]) % 8);\
return output\_btst (operands, operands\[1], operands\[0], insn, 7);\
}\
operands\[1] = gen\_rtx (CONST\_INT, VOIDmode,\
15 - INTVAL (operands\[1]));\
return output\_btst (operands, operands\[1], operands\[0], insn, 15);\
}")

(define\_insn ""\
\[(set (cc0) (zero\_extract (match\_operand:SI 0 "nonimmediate\_operand" "do")\
(const\_int 1)\
(match\_operand:SI 1 "general\_operand" "i")))]\
"GET\_CODE (operands\[1]) == CONST\_INT"\
"\*\
{\
if (GET\_CODE (operands\[0]) == MEM)\
{\
operands\[0] = adj\_offsettable\_operand (operands\[0],\
INTVAL (operands\[1]) / 8);\
operands\[1] = gen\_rtx (CONST\_INT, VOIDmode,\
7 - INTVAL (operands\[1]) % 8);\
return output\_btst (operands, operands\[1], operands\[0], insn, 7);\
}\
operands\[1] = gen\_rtx (CONST\_INT, VOIDmode,\
31 - INTVAL (operands\[1]));\
return output\_btst (operands, operands\[1], operands\[0], insn, 31);\
}")

(define\_insn ""\
\[(set (cc0) (subreg:SI (lshiftrt:QI (match\_operand:QI 0 "nonimmediate\_operand" "dm")\
(const\_int 7))\
0\))]\
""\
"\*\
{\
cc\_status.flags = CC\_Z\_IN\_NOT\_N | CC\_NOT\_NEGATIVE;\
return "tst%.b %0";\
}")

(define\_insn ""\
\[(set (cc0) (and:SI (sign\_extend:SI (sign\_extend:HI (match\_operand:QI 0 "nonimmediate\_operand" "dm")))\
(match\_operand:SI 1 "general\_operand" "i")))]\
"(GET\_CODE (operands\[1]) == CONST\_INT\
&& (unsigned) INTVAL (operands\[1]) < 0x100\
&& exact\_log2 (INTVAL (operands\[1])) >= 0)"\
"\*\
{ register int log = exact\_log2 (INTVAL (operands\[1]));\
operands\[1] = gen\_rtx (CONST\_INT, VOIDmode, log);\
return output\_btst (operands, operands\[1], operands\[0], insn, 7);\
}")\
;; move instructions

;; A special case in which it is not desirable\
;; to reload the constant into a data register.\
(define\_insn ""\
\[(set (match\_operand:SI 0 "push\_operand" "=m")\
(match\_operand:SI 1 "general\_operand" "J"))]\
"GET\_CODE (operands\[1]) == CONST\_INT\
&& INTVAL (operands\[1]) >= -0x8000\
&& INTVAL (operands\[1]) < 0x8000"\
"\*\
{\
if (operands\[1] == const0\_rtx)\
return "clr%.l %0";\
return "pea %a1";\
}")

;This is never used.\
;(define\_insn "swapsi"\
; \[(set (match\_operand:SI 0 "general\_operand" "r")\
; (match\_operand:SI 1 "general\_operand" "r"))\
; (set (match\_dup 1) (match\_dup 0))]\
; ""\
; "exg %1,%0")

;; Special case of fullword move when source is zero.\
;; The reason this is special is to avoid loading a zero\
;; into a data reg with moveq in order to store it elsewhere.

(define\_insn ""\
\[(set (match\_operand:SI 0 "general\_operand" "=g")\
(const\_int 0))]\
""\
"\*\
{\
if (ADDRESS\_REG\_P (operands\[0]))\
return "sub%.l %0,%0";\
/\* moveq is faster on the 68000. \*/\
if (DATA\_REG\_P (operands\[0]) && !TARGET\_68020)\
\#ifdef MOTOROLA\
return "moveq%.l %#0,%0";\
\#else\
return "moveq %#0,%0";\
\#endif\
return "clr%.l %0";\
}")

;; General case of fullword move. The register constraints\
;; force integer constants in range for a moveq to be reloaded\
;; if they are headed for memory.\
(define\_insn "movsi"\
;; Notes: make sure no alternative allows g vs g.\
;; We don't allow f-regs since fixed point cannot go in them.\
;; We do allow y and x regs since fixed point is allowed in them.\
\[(set (match\_operand:SI 0 "general\_operand" "=g,da,y,!_&#x78;_&#x72;_m")_\
_(match\_operand:SI 1 "general\_operand" "daymKs,i,g,x&#x72;_&#x6D;"))]\
""\
"\*\
{\
if (which\_alternative == 3)\
return "fpmove%.l %x1,fpa0;fpmove%.l fpa0,%x0";\
if (FPA\_REG\_P (operands\[1]) || FPA\_REG\_P (operands\[0]))\
return "fpmove%.l %x1,%x0";\
if (GET\_CODE (operands\[1]) == CONST\_INT)\
{\
if (operands\[1] == const0\_rtx\
&& (DATA\_REG\_P (operands\[0])\
|| GET\_CODE (operands\[0]) == MEM))\
return "clr%.l %0";\
else if (DATA\_REG\_P (operands\[0])\
&& INTVAL (operands\[1]) < 128\
&& INTVAL (operands\[1]) >= -128)\
{\
\#ifdef MOTOROLA\
return "moveq%.l %1,%0";\
\#else\
return "moveq %1,%0";\
\#endif\
}\
else if (ADDRESS\_REG\_P (operands\[0])\
&& INTVAL (operands\[1]) < 0x8000\
&& INTVAL (operands\[1]) >= -0x8000)\
return "move%.w %1,%0";\
else if (push\_operand (operands\[0], SImode)\
&& INTVAL (operands\[1]) < 0x8000\
&& INTVAL (operands\[1]) >= -0x8000)\
return "pea %a1";\
}\
else if ((GET\_CODE (operands\[1]) == SYMBOL\_REF\
|| GET\_CODE (operands\[1]) == CONST)\
&& push\_operand (operands\[0], SImode))\
return "pea %a1";\
else if ((GET\_CODE (operands\[1]) == SYMBOL\_REF\
|| GET\_CODE (operands\[1]) == CONST)\
&& ADDRESS\_REG\_P (operands\[0]))\
return "lea %a1,%0";\
return "move%.l %1,%0";\
}")

(define\_insn "movhi"\
\[(set (match\_operand:HI 0 "general\_operand" "=g")\
(match\_operand:HI 1 "general\_operand" "g"))]\
""\
"\*\
{\
if (GET\_CODE (operands\[1]) == CONST\_INT)\
{\
if (operands\[1] == const0\_rtx\
&& (DATA\_REG\_P (operands\[0])\
|| GET\_CODE (operands\[0]) == MEM))\
return "clr%.w %0";\
else if (DATA\_REG\_P (operands\[0])\
&& INTVAL (operands\[1]) < 128\
&& INTVAL (operands\[1]) >= -128)\
{\
\#ifdef MOTOROLA\
return "moveq%.l %1,%0";\
\#else\
return "moveq %1,%0";\
\#endif\
}\
else if (INTVAL (operands\[1]) < 0x8000\
&& INTVAL (operands\[1]) >= -0x8000)\
return "move%.w %1,%0";\
}\
else if (CONSTANT\_P (operands\[1]))\
return "move%.l %1,%0";\
\#ifndef SONY\_ASM\
/\* Recognize the insn before a tablejump, one that refers\
to a table of offsets. Such an insn will need to refer\
to a label on the insn. So output one. Use the label-number\
of the table of offsets to generate this label. _/_\
_if (GET\_CODE (operands\[1]) == MEM_\
_&& GET\_CODE (XEXP (operands\[1], 0)) == PLUS_\
_&& (GET\_CODE (XEXP (XEXP (operands\[1], 0), 0)) == LABEL\_REF_\
_|| GET\_CODE (XEXP (XEXP (operands\[1], 0), 1)) == LABEL\_REF)_\
_&& GET\_CODE (XEXP (XEXP (operands\[1], 0), 0)) != PLUS_\
_&& GET\_CODE (XEXP (XEXP (operands\[1], 0), 1)) != PLUS)_\
_{_\
_rtx labelref;_\
_if (GET\_CODE (XEXP (XEXP (operands\[1], 0), 0)) == LABEL\_REF)_\
_labelref = XEXP (XEXP (operands\[1], 0), 0);_\
_else_\
_labelref = XEXP (XEXP (operands\[1], 0), 1);_\
_#if defined (MOTOROLA) && ! defined (SGS\_3B1)_\
_#ifdef SGS_\
_fprintf (asm\_out\_file, "\tset %s%d,.+2\n", "LI",_\
_CODE\_LABEL\_NUMBER (XEXP (labelref, 0)));_\
_#else /_ not SGS _/_\
_fprintf (asm\_out\_file, "\t.set %s%d,.+2\n", "LI",_\
_CODE\_LABEL\_NUMBER (XEXP (labelref, 0)));_\
_#endif /_ not SGS _/_\
_#else /_ SGS\_3B1 or not MOTOROLA _/_\
_ASM\_OUTPUT\_INTERNAL\_LABEL (asm\_out\_file, "LI",_\
_CODE\_LABEL\_NUMBER (XEXP (labelref, 0)));_\
_/_ For sake of 3b1, set flag saying we need to define the symbol\
LD%n (with value L%n-LI%n) at the end of the switch table. _/_\
_RTX\_INTEGRATED\_P (next\_real\_insn (XEXP (labelref, 0))) = 1;_\
_#endif /_ SGS\_3B1 or not MOTOROLA _/_\
_}_\
_#endif /_ SONY\_ASM \*/\
return "move%.w %1,%0";\
}")

(define\_insn "movstricthi"\
\[(set (strict\_low\_part (match\_operand:HI 0 "general\_operand" "+dm"))\
(match\_operand:HI 1 "general\_operand" "rmn"))]\
""\
"\*\
{\
if (GET\_CODE (operands\[1]) == CONST\_INT)\
{\
if (operands\[1] == const0\_rtx\
&& (DATA\_REG\_P (operands\[0])\
|| GET\_CODE (operands\[0]) == MEM))\
return "clr%.w %0";\
}\
return "move%.w %1,%0";\
}")

(define\_insn "movqi"\
\[(set (match\_operand:QI 0 "general\_operand" "=d,_a,m,m,?a")_\
_(match\_operand:QI 1 "general\_operand" "dmia,&#x64;_&#x61;,dmi,?_a,m"))]_\
_""_\
_"_\
{\
rtx xoperands\[4];\
if (ADDRESS\_REG\_P (operands\[0]) && GET\_CODE (operands\[1]) == MEM)\
{\
xoperands\[1] = operands\[1];\
xoperands\[2]\
\= gen\_rtx (MEM, QImode,\
gen\_rtx (PLUS, VOIDmode, stack\_pointer\_rtx, const1\_rtx));\
xoperands\[3] = stack\_pointer\_rtx;\
/\* Just pushing a byte puts it in the high byte of the halfword. _/_\
_/_ We must put it in the low half, the second byte. \*/\
output\_asm\_insn ("subq%.w %#2,%3;move%.b %1,%2", xoperands);\
return "move%.w %+,%0";\
}\
if (ADDRESS\_REG\_P (operands\[1]) && GET\_CODE (operands\[0]) == MEM)\
{\
xoperands\[0] = operands\[0];\
xoperands\[1] = operands\[1];\
xoperands\[2]\
\= gen\_rtx (MEM, QImode,\
gen\_rtx (PLUS, VOIDmode, stack\_pointer\_rtx, const1\_rtx));\
xoperands\[3] = stack\_pointer\_rtx;\
output\_asm\_insn ("move%.w %1,%-;move%.b %2,%0;addq%.w %#2,%3", xoperands);\
return "";\
}\
if (operands\[1] == const0\_rtx)\
return "clr%.b %0";\
if (GET\_CODE (operands\[1]) == CONST\_INT\
&& INTVAL (operands\[1]) == -1)\
return "st %0";\
if (GET\_CODE (operands\[1]) != CONST\_INT && CONSTANT\_P (operands\[1]))\
return "move%.l %1,%0";\
if (ADDRESS\_REG\_P (operands\[0]) || ADDRESS\_REG\_P (operands\[1]))\
return "move%.w %1,%0";\
return "move%.b %1,%0";\
}")

(define\_insn "movstrictqi"\
\[(set (strict\_low\_part (match\_operand:QI 0 "general\_operand" "+dm"))\
(match\_operand:QI 1 "general\_operand" "dmn"))]\
""\
"\*\
{\
if (operands\[1] == const0\_rtx)\
return "clr%.b %0";\
return "move%.b %1,%0";\
}")

(define\_insn "movsf"\
\[(set (match\_operand:SF 0 "general\_operand" "=rmf,x,y,rm,!x,!rm")\
(match\_operand:SF 1 "general\_operand" "rmfF,xH,rmF,y,rm,x"))]\
; \[(set (match\_operand:SF 0 "general\_operand" "=rmf")\
; (match\_operand:SF 1 "general\_operand" "rmfF"))]\
""\
"\*\
{\
if (which\_alternative >= 4)\
return "fpmove%.s %1,fpa0;fpmove%.s fpa0,%0";\
if (FPA\_REG\_P (operands\[0]))\
{\
if (FPA\_REG\_P (operands\[1]))\
return "fpmove%.s %x1,%x0";\
else if (GET\_CODE (operands\[1]) == CONST\_DOUBLE)\
return output\_move\_const\_single (operands);\
else if (FP\_REG\_P (operands\[1]))\
return "fmove%.s %1,sp@-;fpmove%.d sp@+, %0";\
return "fpmove%.s %x1,%x0";\
}\
if (FPA\_REG\_P (operands\[1]))\
{\
if (FP\_REG\_P (operands\[0]))\
return "fpmove%.s %x1,sp@-;fmove%.s sp@+,%0";\
else\
return "fpmove%.s %x1,%x0";\
}\
if (FP\_REG\_P (operands\[0]))\
{\
if (FP\_REG\_P (operands\[1]))\
return "fmove%.x %1,%0";\
else if (ADDRESS\_REG\_P (operands\[1]))\
return "move%.l %1,%-;fmove%.s %+,%0";\
else if (GET\_CODE (operands\[1]) == CONST\_DOUBLE)\
return output\_move\_const\_single (operands);\
return "fmove%.s %f1,%0";\
}\
if (FP\_REG\_P (operands\[1]))\
{\
if (ADDRESS\_REG\_P (operands\[0]))\
return "fmove%.s %1,%-;move%.l %+,%0";\
return "fmove%.s %f1,%0";\
}\
return "move%.l %1,%0";\
}")

(define\_insn "movdf"\
\[(set (match\_operand:DF 0 "general\_operand" "=rm,\&rf,\&rof<>,y,rm,x,!x,!rm")\
(match\_operand:DF 1 "general\_operand" "rf,m,rofF<>,rmF,y,xH,rm,x"))]\
; \[(set (match\_operand:DF 0 "general\_operand" "=rm,\&rf,\&rof<>")\
; (match\_operand:DF 1 "general\_operand" "rf,m,rofF<>"))]\
""\
"\*\
{\
if (which\_alternative == 6)\
return "fpmove%.d %x1,fpa0;fpmove%.d fpa0,%x0";\
if (FPA\_REG\_P (operands\[0]))\
{\
if (GET\_CODE (operands\[1]) == CONST\_DOUBLE)\
return output\_move\_const\_double (operands);\
if (FP\_REG\_P (operands\[1]))\
return "fmove%.d %1,sp@-;fpmove%.d sp@+,%x0";\
return "fpmove%.d %x1,%x0";\
}\
else if (FPA\_REG\_P (operands\[1]))\
{\
if (FP\_REG\_P(operands\[0]))\
return "fpmove%.d %x1,sp@-;fmoved sp@+,%0";\
else\
return "fpmove%.d %x1,%x0";\
}\
if (FP\_REG\_P (operands\[0]))\
{\
if (FP\_REG\_P (operands\[1]))\
return "fmove%.x %1,%0";\
if (REG\_P (operands\[1]))\
{\
rtx xoperands\[2];\
xoperands\[1] = gen\_rtx (REG, SImode, REGNO (operands\[1]) + 1);\
output\_asm\_insn ("move%.l %1,%-", xoperands);\
output\_asm\_insn ("move%.l %1,%-", operands);\
return "fmove%.d %+,%0";\
}\
if (GET\_CODE (operands\[1]) == CONST\_DOUBLE)\
return output\_move\_const\_double (operands);\
return "fmove%.d %f1,%0";\
}\
else if (FP\_REG\_P (operands\[1]))\
{\
if (REG\_P (operands\[0]))\
{\
output\_asm\_insn ("fmove%.d %f1,%-;move%.l %+,%0", operands);\
operands\[0] = gen\_rtx (REG, SImode, REGNO (operands\[0]) + 1);\
return "move%.l %+,%0";\
}\
else\
return "fmove%.d %f1,%0";\
}\
return output\_move\_double (operands);\
}\
")

;; movdi can apply to fp regs in some cases\
(define\_insn "movdi"\
;; Let's see if it really still needs to handle fp regs, and, if so, why.\
\[(set (match\_operand:DI 0 "general\_operand" "=rm,\&r,\&ro<>,y,rm,!\*x,!rm")\
(match\_operand:DI 1 "general\_operand" "rF,m,roi<>F,rmiF,y,rmF,_x"))]_\
_; \[(set (match\_operand:DI 0 "general\_operand" "=rm,\&r,\&ro<>,!\&rm,!\&f,y,rm,x,!x,!rm")_\
_; (match\_operand:DI 1 "general\_operand" "r,m,roi<>,fF,rfmF,rmi,y,rm,x"))]_\
_; \[(set (match\_operand:DI 0 "general\_operand" "=rm,\&rf,\&ro<>,!\&rm,!\&f")_\
_; (match\_operand:DI 1 "general\_operand" "r,m,roi<>,fF,rfF"))]_\
_""_\
_"_\
{\
if (which\_alternative == 8)\
return "fpmove%.d %x1,fpa0;fpmove%.d fpa0,%x0";\
if (FPA\_REG\_P (operands\[0]) || FPA\_REG\_P (operands\[1]))\
return "fpmove%.d %x1,%x0";\
if (FP\_REG\_P (operands\[0]))\
{\
if (FP\_REG\_P (operands\[1]))\
return "fmove%.x %1,%0";\
if (REG\_P (operands\[1]))\
{\
rtx xoperands\[2];\
xoperands\[1] = gen\_rtx (REG, SImode, REGNO (operands\[1]) + 1);\
output\_asm\_insn ("move%.l %1,%-", xoperands);\
output\_asm\_insn ("move%.l %1,%-", operands);\
return "fmove%.d %+,%0";\
}\
if (GET\_CODE (operands\[1]) == CONST\_DOUBLE)\
return output\_move\_const\_double (operands);\
return "fmove%.d %f1,%0";\
}\
else if (FP\_REG\_P (operands\[1]))\
{\
if (REG\_P (operands\[0]))\
{\
output\_asm\_insn ("fmove%.d %f1,%-;move%.l %+,%0", operands);\
operands\[0] = gen\_rtx (REG, SImode, REGNO (operands\[0]) + 1);\
return "move%.l %+,%0";\
}\
else\
return "fmove%.d %f1,%0";\
}\
return output\_move\_double (operands);\
}\
")

;; Thus goes after the move instructions\
;; because the move instructions are better (require no spilling)\
;; when they can apply. It goes before the add/sub insns\
;; so we will prefer it to them.

(define\_insn "pushasi"\
\[(set (match\_operand:SI 0 "push\_operand" "=m")\
(match\_operand:SI 1 "address\_operand" "p"))]\
""\
"pea %a1")\
;; truncation instructions\
(define\_insn "truncsiqi2"\
\[(set (match\_operand:QI 0 "general\_operand" "=dm,d")\
(truncate:QI\
(match\_operand:SI 1 "general\_operand" "doJ,i")))]\
""\
"\*\
{\
if (GET\_CODE (operands\[0]) == REG)\
return "move%.l %1,%0";\
if (GET\_CODE (operands\[1]) == MEM)\
operands\[1] = adj\_offsettable\_operand (operands\[1], 3);\
return "move%.b %1,%0";\
}")

(define\_insn "trunchiqi2"\
\[(set (match\_operand:QI 0 "general\_operand" "=dm,d")\
(truncate:QI\
(match\_operand:HI 1 "general\_operand" "doJ,i")))]\
""\
"\*\
{\
if (GET\_CODE (operands\[0]) == REG\
&& (GET\_CODE (operands\[1]) == MEM\
|| GET\_CODE (operands\[1]) == CONST\_INT))\
return "move%.w %1,%0";\
if (GET\_CODE (operands\[0]) == REG)\
return "move%.l %1,%0";\
if (GET\_CODE (operands\[1]) == MEM)\
operands\[1] = adj\_offsettable\_operand (operands\[1], 1);\
return "move%.b %1,%0";\
}")

(define\_insn "truncsihi2"\
\[(set (match\_operand:HI 0 "general\_operand" "=dm,d")\
(truncate:HI\
(match\_operand:SI 1 "general\_operand" "roJ,i")))]\
""\
"\*\
{\
if (GET\_CODE (operands\[0]) == REG)\
return "move%.l %1,%0";\
if (GET\_CODE (operands\[1]) == MEM)\
operands\[1] = adj\_offsettable\_operand (operands\[1], 2);\
return "move%.w %1,%0";\
}")\
;; zero extension instructions

(define\_expand "zero\_extendhisi2"\
\[(set (match\_operand:SI 0 "register\_operand" "")\
(const\_int 0))\
(set (strict\_low\_part (subreg:HI (match\_dup 0) 0))\
(match\_operand:HI 1 "general\_operand" ""))]\
""\
"operands\[1] = make\_safe\_from (operands\[1], operands\[0]);")

(define\_expand "zero\_extendqihi2"\
\[(set (match\_operand:HI 0 "register\_operand" "")\
(const\_int 0))\
(set (strict\_low\_part (subreg:QI (match\_dup 0) 0))\
(match\_operand:QI 1 "general\_operand" ""))]\
""\
"operands\[1] = make\_safe\_from (operands\[1], operands\[0]);")

(define\_expand "zero\_extendqisi2"\
\[(set (match\_operand:SI 0 "register\_operand" "")\
(const\_int 0))\
(set (strict\_low\_part (subreg:QI (match\_dup 0) 0))\
(match\_operand:QI 1 "general\_operand" ""))]\
""\
" operands\[1] = make\_safe\_from (operands\[1], operands\[0]); ")\
;; Patterns to recognize zero-extend insns produced by the combiner.

;; Note that the one starting from HImode comes before those for QImode\
;; so that a constant operand will match HImode, not QImode.\
(define\_insn ""\
\[(set (match\_operand:SI 0 "general\_operand" "=do<>")\
(zero\_extend:SI\
(match\_operand:HI 1 "general\_operand" "rmn")))]\
""\
"\*\
{\
if (DATA\_REG\_P (operands\[0]))\
{\
if (GET\_CODE (operands\[1]) == REG\
&& REGNO (operands\[0]) == REGNO (operands\[1]))\
return "and%.l %#0xFFFF,%0";\
if (reg\_mentioned\_p (operands\[0], operands\[1]))\
return "move%.w %1,%0;and%.l %#0xFFFF,%0";\
return "clr%.l %0;move%.w %1,%0";\
}\
else if (GET\_CODE (operands\[0]) == MEM\
&& GET\_CODE (XEXP (operands\[0], 0)) == PRE\_DEC)\
return "move%.w %1,%0;clr%.w %0";\
else if (GET\_CODE (operands\[0]) == MEM\
&& GET\_CODE (XEXP (operands\[0], 0)) == POST\_INC)\
return "clr%.w %0;move%.w %1,%0";\
else\
{\
output\_asm\_insn ("clr%.w %0", operands);\
operands\[0] = adj\_offsettable\_operand (operands\[0], 2);\
return "move%.w %1,%0";\
}\
}")

(define\_insn ""\
\[(set (match\_operand:HI 0 "general\_operand" "=do<>")\
(zero\_extend:HI\
(match\_operand:QI 1 "general\_operand" "dmn")))]\
""\
"\*\
{\
if (DATA\_REG\_P (operands\[0]))\
{\
if (GET\_CODE (operands\[1]) == REG\
&& REGNO (operands\[0]) == REGNO (operands\[1]))\
return "and%.w %#0xFF,%0";\
if (reg\_mentioned\_p (operands\[0], operands\[1]))\
return "move%.b %1,%0;and%.w %#0xFF,%0";\
return "clr%.w %0;move%.b %1,%0";\
}\
else if (GET\_CODE (operands\[0]) == MEM\
&& GET\_CODE (XEXP (operands\[0], 0)) == PRE\_DEC)\
{\
if (REGNO (XEXP (XEXP (operands\[0], 0), 0))\
\== STACK\_POINTER\_REGNUM)\
return "clr%.w %-;move%.b %1,%0";\
else\
return "move%.b %1,%0;clr%.b %0";\
}\
else if (GET\_CODE (operands\[0]) == MEM\
&& GET\_CODE (XEXP (operands\[0], 0)) == POST\_INC)\
return "clr%.b %0;move%.b %1,%0";\
else\
{\
output\_asm\_insn ("clr%.b %0", operands);\
operands\[0] = adj\_offsettable\_operand (operands\[0], 1);\
return "move%.b %1,%0";\
}\
}")

(define\_insn ""\
\[(set (match\_operand:SI 0 "general\_operand" "=do<>")\
(zero\_extend:SI\
(match\_operand:QI 1 "general\_operand" "dmn")))]\
""\
"\*\
{\
if (DATA\_REG\_P (operands\[0]))\
{\
if (GET\_CODE (operands\[1]) == REG\
&& REGNO (operands\[0]) == REGNO (operands\[1]))\
return "and%.l %#0xFF,%0";\
if (reg\_mentioned\_p (operands\[0], operands\[1]))\
return "move%.b %1,%0;and%.l %#0xFF,%0";\
return "clr%.l %0;move%.b %1,%0";\
}\
else if (GET\_CODE (operands\[0]) == MEM\
&& GET\_CODE (XEXP (operands\[0], 0)) == PRE\_DEC)\
{\
operands\[0] = XEXP (XEXP (operands\[0], 0), 0);\
\#ifdef MOTOROLA\
\#ifdef SGS\
return "clr.l -(%0);move%.b %1,3(%0)";\
\#else\
return "clr.l -(%0);move%.b %1,(3,%0)";\
\#endif\
\#else\
return "clrl %0@-;moveb %1,%0@(3)";\
\#endif\
}\
else if (GET\_CODE (operands\[0]) == MEM\
&& GET\_CODE (XEXP (operands\[0], 0)) == POST\_INC)\
{\
operands\[0] = XEXP (XEXP (operands\[0], 0), 0);\
\#ifdef MOTOROLA\
\#ifdef SGS\
return "clr.l (%0)+;move%.b %1,-1(%0)";\
\#else\
return "clr.l (%0)+;move%.b %1,(-1,%0)";\
\#endif\
\#else\
return "clrl %0@+;moveb %1,%0@(-1)";\
\#endif\
}\
else\
{\
output\_asm\_insn ("clr%.l %0", operands);\
operands\[0] = adj\_offsettable\_operand (operands\[0], 3);\
return "move%.b %1,%0";\
}\
}")\
;; sign extension instructions\
;; Note that the one starting from HImode comes before those for QImode\
;; so that a constant operand will match HImode, not QImode.

(define\_insn "extendhisi2"\
\[(set (match\_operand:SI 0 "general\_operand" "=_d,a")_\
_(sign\_extend:SI_\
_(match\_operand:HI 1 "general\_operand" "0,rmn")))]_\
_""_\
_"_\
{\
if (ADDRESS\_REG\_P (operands\[0]))\
return "move%.w %1,%0";\
return "ext%.l %0";\
}")

(define\_insn "extendqihi2"\
\[(set (match\_operand:HI 0 "general\_operand" "=d")\
(sign\_extend:HI\
(match\_operand:QI 1 "general\_operand" "0")))]\
""\
"ext%.w %0")

(define\_insn "extendqisi2"\
\[(set (match\_operand:SI 0 "general\_operand" "=d")\
(sign\_extend:SI\
(match\_operand:QI 1 "general\_operand" "0")))]\
"TARGET\_68020"\
"extb%.l %0")\
;; Conversions between float and double.

(define\_expand "extendsfdf2"\
\[(set (match\_operand:DF 0 "general\_operand" "")\
(float\_extend:DF\
(match\_operand:SF 1 "general\_operand" "")))]\
"TARGET\_68881 || TARGET\_FPA"\
"")

(define\_insn ""\
\[(set (match\_operand:DF 0 "general\_operand" "=x,y")\
(float\_extend:DF\
(match\_operand:SF 1 "general\_operand" "xH,rmF")))]\
"TARGET\_FPA"\
"fpstod %w1,%0")

(define\_insn ""\
\[(set (match\_operand:DF 0 "general\_operand" "=_fdm,f")_\
_(float\_extend:DF_\
_(match\_operand:SF 1 "general\_operand" "f,dmF")))]_\
_"TARGET\_68881"_\
_"_\
{\
if (FP\_REG\_P (operands\[0]) && FP\_REG\_P (operands\[1]))\
{\
if (REGNO (operands\[0]) == REGNO (operands\[1]))\
{\
/\* Extending float to double in an fp-reg is a no-op.\
NOTICE\_UPDATE\_CC has already assumed that the\
cc will be set. So cancel what it did. \*/\
cc\_status = cc\_prev\_status;\
return "";\
}\
return "fmove%.x %1,%0";\
}\
if (FP\_REG\_P (operands\[0]))\
return "fmove%.s %f1,%0";\
if (DATA\_REG\_P (operands\[0]) && FP\_REG\_P (operands\[1]))\
{\
output\_asm\_insn ("fmove%.d %f1,%-;move%.l %+,%0", operands);\
operands\[0] = gen\_rtx (REG, SImode, REGNO (operands\[0]) + 1);\
return "move%.l %+,%0";\
}\
return "fmove%.d %f1,%0";\
}")

;; This cannot output into an f-reg because there is no way to be\
;; sure of truncating in that case.\
;; But on the Sun FPA, we can be sure.\
(define\_expand "truncdfsf2"\
\[(set (match\_operand:SF 0 "general\_operand" "")\
(float\_truncate:SF\
(match\_operand:DF 1 "general\_operand" "")))]\
"TARGET\_68881 || TARGET\_FPA"\
"")

(define\_insn ""\
\[(set (match\_operand:SF 0 "general\_operand" "=x,y")\
(float\_truncate:SF\
(match\_operand:DF 1 "general\_operand" "xH,rmF")))]\
"TARGET\_FPA"\
"fpdtos %y1,%0")

(define\_insn ""\
\[(set (match\_operand:SF 0 "general\_operand" "=dm")\
(float\_truncate:SF\
(match\_operand:DF 1 "general\_operand" "f")))]\
"TARGET\_68881"\
"fmove%.s %f1,%0")\
;; Conversion between fixed point and floating point.\
;; Note that among the fix-to-float insns\
;; the ones that start with SImode come first.\
;; That is so that an operand that is a CONST\_INT\
;; (and therefore lacks a specific machine mode).\
;; will be recognized as SImode (which is always valid)\
;; rather than as QImode or HImode.

(define\_expand "floatsisf2"\
\[(set (match\_operand:SF 0 "general\_operand" "")\
(float:SF (match\_operand:SI 1 "general\_operand" "")))]\
"TARGET\_68881 || TARGET\_FPA"\
"")

(define\_insn ""\
\[(set (match\_operand:SF 0 "general\_operand" "=y,x")\
(float:SF (match\_operand:SI 1 "general\_operand" "rmi,x")))]\
"TARGET\_FPA"\
"fpltos %1,%0")

(define\_insn ""\
\[(set (match\_operand:SF 0 "general\_operand" "=f")\
(float:SF (match\_operand:SI 1 "general\_operand" "dmi")))]\
"TARGET\_68881"\
"fmove%.l %1,%0")

(define\_expand "floatsidf2"\
\[(set (match\_operand:DF 0 "general\_operand" "")\
(float:DF (match\_operand:SI 1 "general\_operand" "")))]\
"TARGET\_68881 || TARGET\_FPA"\
"")

(define\_insn ""\
\[(set (match\_operand:DF 0 "general\_operand" "=y,x")\
(float:DF (match\_operand:SI 1 "general\_operand" "rmi,x")))]\
"TARGET\_FPA"\
"fpltod %1,%0")

(define\_insn ""\
\[(set (match\_operand:DF 0 "general\_operand" "=f")\
(float:DF (match\_operand:SI 1 "general\_operand" "dmi")))]\
"TARGET\_68881"\
"fmove%.l %1,%0")

(define\_insn "floathisf2"\
\[(set (match\_operand:SF 0 "general\_operand" "=f")\
(float:SF (match\_operand:HI 1 "general\_operand" "dmn")))]\
"TARGET\_68881"\
"fmove%.w %1,%0")

(define\_insn "floathidf2"\
\[(set (match\_operand:DF 0 "general\_operand" "=f")\
(float:DF (match\_operand:HI 1 "general\_operand" "dmn")))]\
"TARGET\_68881"\
"fmove%.w %1,%0")

(define\_insn "floatqisf2"\
\[(set (match\_operand:SF 0 "general\_operand" "=f")\
(float:SF (match\_operand:QI 1 "general\_operand" "dmn")))]\
"TARGET\_68881"\
"fmove%.b %1,%0")

(define\_insn "floatqidf2"\
\[(set (match\_operand:DF 0 "general\_operand" "=f")\
(float:DF (match\_operand:QI 1 "general\_operand" "dmn")))]\
"TARGET\_68881"\
"fmove%.b %1,%0")

;; Convert a float to a float whose value is an integer.\
;; This is the first stage of converting it to an integer type.

(define\_insn "ftruncdf2"\
\[(set (match\_operand:DF 0 "general\_operand" "=f")\
(fix:DF (match\_operand:DF 1 "general\_operand" "fFm")))]\
"TARGET\_68881"\
"\*\
{\
if (FP\_REG\_P (operands\[1]))\
return "fintrz%.x %f1,%0";\
return "fintrz%.d %f1,%0";\
}")

(define\_insn "ftruncsf2"\
\[(set (match\_operand:SF 0 "general\_operand" "=f")\
(fix:SF (match\_operand:SF 1 "general\_operand" "dfFm")))]\
"TARGET\_68881"\
"\*\
{\
if (FP\_REG\_P (operands\[1]))\
return "fintrz%.x %f1,%0";\
return "fintrz%.s %f1,%0";\
}")

;; Convert a float whose value is an integer\
;; to an actual integer. Second stage of converting float to integer type.\
(define\_insn "fixsfqi2"\
\[(set (match\_operand:QI 0 "general\_operand" "=dm")\
(fix:QI (match\_operand:SF 1 "general\_operand" "f")))]\
"TARGET\_68881"\
"fmove%.b %1,%0")

(define\_insn "fixsfhi2"\
\[(set (match\_operand:HI 0 "general\_operand" "=dm")\
(fix:HI (match\_operand:SF 1 "general\_operand" "f")))]\
"TARGET\_68881"\
"fmove%.w %1,%0")

(define\_insn "fixsfsi2"\
\[(set (match\_operand:SI 0 "general\_operand" "=dm")\
(fix:SI (match\_operand:SF 1 "general\_operand" "f")))]\
"TARGET\_68881"\
"fmove%.l %1,%0")

(define\_insn "fixdfqi2"\
\[(set (match\_operand:QI 0 "general\_operand" "=dm")\
(fix:QI (match\_operand:DF 1 "general\_operand" "f")))]\
"TARGET\_68881"\
"fmove%.b %1,%0")

(define\_insn "fixdfhi2"\
\[(set (match\_operand:HI 0 "general\_operand" "=dm")\
(fix:HI (match\_operand:DF 1 "general\_operand" "f")))]\
"TARGET\_68881"\
"fmove%.w %1,%0")

(define\_insn "fixdfsi2"\
\[(set (match\_operand:SI 0 "general\_operand" "=dm")\
(fix:SI (match\_operand:DF 1 "general\_operand" "f")))]\
"TARGET\_68881"\
"fmove%.l %1,%0")

;; Convert a float to an integer.\
;; On the Sun FPA, this is done in one step.

(define\_insn "fix\_truncsfsi2"\
\[(set (match\_operand:SI 0 "general\_operand" "=x,y")\
(fix:SI (fix:SF (match\_operand:SF 1 "general\_operand" "xH,rmF"))))]\
"TARGET\_FPA"\
"fpstol %w1,%0")

(define\_insn "fix\_truncdfsi2"\
\[(set (match\_operand:SI 0 "general\_operand" "=x,y")\
(fix:SI (fix:DF (match\_operand:DF 1 "general\_operand" "xH,rmF"))))]\
"TARGET\_FPA"\
"fpdtol %y1,%0")\
;; add instructions

;; Note that the last two alternatives are near-duplicates\
;; in order to handle insns generated by reload.\
;; This is needed since they are not themselves reloaded,\
;; so commutativity won't apply to them.\
(define\_insn "addsi3"\
\[(set (match\_operand:SI 0 "general\_operand" "=m,r,!a,!a")\
(plus:SI (match\_operand:SI 1 "general\_operand" "%0,0,a,rJK")\
(match\_operand:SI 2 "general\_operand" "dIKLs,mrIKLs,rJK,a")))]\
""\
"\*\
{\
if (! operands\_match\_p (operands\[0], operands\[1]))\
{\
if (!ADDRESS\_REG\_P (operands\[1]))\
{\
rtx tmp = operands\[1];

```
  operands[1] = operands[2];
  operands[2] = tmp;
}

  /* These insns can result from reloads to access
 stack slots over 64k from the frame pointer.  */
  if (GET_CODE (operands[2]) == CONST_INT
  && INTVAL (operands[2]) + 0x8000 >= (unsigned) 0x10000)
    return \"move%.l %2,%0\;add%.l %1,%0\";
```

\#ifdef SGS\
if (GET\_CODE (operands\[2]) == REG)\
return "lea 0(%1,%2.l),%0";\
else\
return "lea %c2(%1),%0";\
\#else /\* not SGS _/_\
_#ifdef MOTOROLA_\
_if (GET\_CODE (operands\[2]) == REG)_\
_return "lea (%1,%2.l),%0";_\
_else_\
_return "lea (%c2,%1),%0";_\
_#else /_ not MOTOROLA (MIT syntax) _/_\
_if (GET\_CODE (operands\[2]) == REG)_\
_return "lea %1@(0,%2:l),%0";_\
_else_\
_return "lea %1@(%c2),%0";_\
_#endif /_ not MOTOROLA _/_\
_#endif /_ not SGS \*/\
}\
if (GET\_CODE (operands\[2]) == CONST\_INT)\
{\
\#ifndef NO\_ADDSUB\_Q\
if (INTVAL (operands\[2]) > 0\
&& INTVAL (operands\[2]) <= 8)\
return (ADDRESS\_REG\_P (operands\[0])\
? "addq%.w %2,%0"\
: "addq%.l %2,%0");\
if (INTVAL (operands\[2]) < 0\
&& INTVAL (operands\[2]) >= -8)\
{\
operands\[2] = gen\_rtx (CONST\_INT, VOIDmode,\
\- INTVAL (operands\[2]));\
return (ADDRESS\_REG\_P (operands\[0])\
? "subq%.w %2,%0"\
: "subq%.l %2,%0");\
}\
\#endif\
if (ADDRESS\_REG\_P (operands\[0])\
&& INTVAL (operands\[2]) >= -0x8000\
&& INTVAL (operands\[2]) < 0x8000)\
return "add%.w %2,%0";\
}\
return "add%.l %2,%0";\
}")

(define\_insn ""\
\[(set (match\_operand:SI 0 "general\_operand" "=a")\
(plus:SI (match\_operand:SI 1 "general\_operand" "0")\
(sign\_extend:SI (match\_operand:HI 2 "general\_operand" "rmn"))))]\
""\
"add%.w %2,%0")

(define\_insn "addhi3"\
\[(set (match\_operand:HI 0 "general\_operand" "=m,r")\
(plus:HI (match\_operand:HI 1 "general\_operand" "%0,0")\
(match\_operand:HI 2 "general\_operand" "dn,rmn")))]\
""\
"\*\
{\
\#ifndef NO\_ADDSUB\_Q\
if (GET\_CODE (operands\[2]) == CONST\_INT)\
{\
if (INTVAL (operands\[2]) > 0\
&& INTVAL (operands\[2]) <= 8)\
return "addq%.w %2,%0";\
}\
if (GET\_CODE (operands\[2]) == CONST\_INT)\
{\
if (INTVAL (operands\[2]) < 0\
&& INTVAL (operands\[2]) >= -8)\
{\
operands\[2] = gen\_rtx (CONST\_INT, VOIDmode,\
\- INTVAL (operands\[2]));\
return "subq%.w %2,%0";\
}\
}\
\#endif\
return "add%.w %2,%0";\
}")

(define\_insn ""\
\[(set (strict\_low\_part (match\_operand:HI 0 "general\_operand" "+m,d"))\
(plus:HI (match\_dup 0)\
(match\_operand:HI 1 "general\_operand" "dn,rmn")))]\
""\
"add%.w %1,%0")

(define\_insn "addqi3"\
\[(set (match\_operand:QI 0 "general\_operand" "=m,d")\
(plus:QI (match\_operand:QI 1 "general\_operand" "%0,0")\
(match\_operand:QI 2 "general\_operand" "dn,dmn")))]\
""\
"\*\
{\
\#ifndef NO\_ADDSUB\_Q\
if (GET\_CODE (operands\[2]) == CONST\_INT)\
{\
if (INTVAL (operands\[2]) > 0\
&& INTVAL (operands\[2]) <= 8)\
return "addq%.b %2,%0";\
}\
if (GET\_CODE (operands\[2]) == CONST\_INT)\
{\
if (INTVAL (operands\[2]) < 0 && INTVAL (operands\[2]) >= -8)\
{\
operands\[2] = gen\_rtx (CONST\_INT, VOIDmode, - INTVAL (operands\[2]));\
return "subq%.b %2,%0";\
}\
}\
\#endif\
return "add%.b %2,%0";\
}")

(define\_insn ""\
\[(set (strict\_low\_part (match\_operand:QI 0 "general\_operand" "+m,d"))\
(plus:QI (match\_dup 0)\
(match\_operand:QI 1 "general\_operand" "dn,dmn")))]\
""\
"add%.b %1,%0")

(define\_expand "adddf3"\
\[(set (match\_operand:DF 0 "general\_operand" "")\
(plus:DF (match\_operand:DF 1 "general\_operand" "")\
(match\_operand:DF 2 "general\_operand" "")))]\
"TARGET\_68881 || TARGET\_FPA"\
"")

(define\_insn ""\
\[(set (match\_operand:DF 0 "general\_operand" "=x,y")\
(plus:DF (match\_operand:DF 1 "general\_operand" "%xH,y")\
(match\_operand:DF 2 "general\_operand" "xH,dmF")))]\
"TARGET\_FPA"\
"\*\
{\
if (rtx\_equal\_p (operands\[0], operands\[1]))\
return "fpadd%.d %y2,%0";\
if (rtx\_equal\_p (operands\[0], operands\[2]))\
return "fpadd%.d %y1,%0";\
if (which\_alternative == 0)\
return "fpadd3%.d %w2,%w1,%0";\
return "fpadd3%.d %x2,%x1,%0";\
}")

(define\_insn ""\
\[(set (match\_operand:DF 0 "general\_operand" "=f")\
(plus:DF (match\_operand:DF 1 "general\_operand" "%0")\
(match\_operand:DF 2 "general\_operand" "fmG")))]\
"TARGET\_68881"\
"\*\
{\
if (REG\_P (operands\[2]))\
return "fadd%.x %2,%0";\
return "fadd%.d %f2,%0";\
}")

(define\_expand "addsf3"\
\[(set (match\_operand:SF 0 "general\_operand" "")\
(plus:SF (match\_operand:SF 1 "general\_operand" "")\
(match\_operand:SF 2 "general\_operand" "")))]\
"TARGET\_68881 || TARGET\_FPA"\
"")

(define\_insn ""\
\[(set (match\_operand:SF 0 "general\_operand" "=x,y")\
(plus:SF (match\_operand:SF 1 "general\_operand" "%xH,y")\
(match\_operand:SF 2 "general\_operand" "xH,rmF")))]\
"TARGET\_FPA"\
"\*\
{\
if (rtx\_equal\_p (operands\[0], operands\[1]))\
return "fpadd%.s %w2,%0";\
if (rtx\_equal\_p (operands\[0], operands\[2]))\
return "fpadd%.s %w1,%0";\
if (which\_alternative == 0)\
return "fpadd3%.s %w2,%w1,%0";\
return "fpadd3%.s %2,%1,%0";\
}")

(define\_insn ""\
\[(set (match\_operand:SF 0 "general\_operand" "=f")\
(plus:SF (match\_operand:SF 1 "general\_operand" "%0")\
(match\_operand:SF 2 "general\_operand" "fdmF")))]\
"TARGET\_68881"\
"\*\
{\
if (REG\_P (operands\[2]) && ! DATA\_REG\_P (operands\[2]))\
return "fadd%.x %2,%0";\
return "fadd%.s %f2,%0";\
}")\
;; subtract instructions

(define\_insn "subsi3"\
\[(set (match\_operand:SI 0 "general\_operand" "=m,r,!a,?d")\
(minus:SI (match\_operand:SI 1 "general\_operand" "0,0,a,mrIKs")\
(match\_operand:SI 2 "general\_operand" "dIKs,mrIKs,J,0")))]\
""\
"\*\
{\
if (! operands\_match\_p (operands\[0], operands\[1]))\
{\
if (operands\_match\_p (operands\[0], operands\[2]))\
{\
\#ifndef NO\_ADDSUB\_Q\
if (GET\_CODE (operands\[1]) == CONST\_INT)\
{\
if (INTVAL (operands\[1]) > 0\
&& INTVAL (operands\[1]) <= 8)\
return "subq%.l %1,%0;neg%.l %0";\
}\
\#endif\
return "sub%.l %1,%0;neg%.l %0";\
}\
/\* This case is matched by J, but negating -0x8000\
in an lea would give an invalid displacement.\
So do this specially. _/_\
_if (INTVAL (operands\[2]) == -0x8000)_\
_return "move%.l %1,%0;sub%.l %2,%0";_\
_#ifdef SGS_\
_return "lea %n2(%1),%0";_\
_#else_\
_#ifdef MOTOROLA_\
_return "lea (%n2,%1),%0";_\
_#else /_ not MOTOROLA (MIT syntax) _/_\
_return "lea %1@(%n2),%0";_\
_#endif /_ not MOTOROLA _/_\
_#endif /_ not SGS \*/\
}\
if (GET\_CODE (operands\[2]) == CONST\_INT)\
{\
\#ifndef NO\_ADDSUB\_Q\
if (INTVAL (operands\[2]) > 0\
&& INTVAL (operands\[2]) <= 8)\
return "subq%.l %2,%0";\
\#endif\
if (ADDRESS\_REG\_P (operands\[0])\
&& INTVAL (operands\[2]) >= -0x8000\
&& INTVAL (operands\[2]) < 0x8000)\
return "sub%.w %2,%0";\
}\
return "sub%.l %2,%0";\
}")

(define\_insn ""\
\[(set (match\_operand:SI 0 "general\_operand" "=a")\
(minus:SI (match\_operand:SI 1 "general\_operand" "0")\
(sign\_extend:SI (match\_operand:HI 2 "general\_operand" "rmn"))))]\
""\
"sub%.w %2,%0")

(define\_insn "subhi3"\
\[(set (match\_operand:HI 0 "general\_operand" "=m,r")\
(minus:HI (match\_operand:HI 1 "general\_operand" "0,0")\
(match\_operand:HI 2 "general\_operand" "dn,rmn")))]\
""\
"sub%.w %2,%0")

(define\_insn ""\
\[(set (strict\_low\_part (match\_operand:HI 0 "general\_operand" "+m,d"))\
(minus:HI (match\_dup 0)\
(match\_operand:HI 1 "general\_operand" "dn,rmn")))]\
""\
"sub%.w %1,%0")

(define\_insn "subqi3"\
\[(set (match\_operand:QI 0 "general\_operand" "=m,d")\
(minus:QI (match\_operand:QI 1 "general\_operand" "0,0")\
(match\_operand:QI 2 "general\_operand" "dn,dmn")))]\
""\
"sub%.b %2,%0")

(define\_insn ""\
\[(set (strict\_low\_part (match\_operand:QI 0 "general\_operand" "+m,d"))\
(minus:QI (match\_dup 0)\
(match\_operand:QI 1 "general\_operand" "dn,dmn")))]\
""\
"sub%.b %1,%0")

(define\_expand "subdf3"\
\[(set (match\_operand:DF 0 "general\_operand" "")\
(minus:DF (match\_operand:DF 1 "general\_operand" "")\
(match\_operand:DF 2 "general\_operand" "")))]\
"TARGET\_68881 || TARGET\_FPA"\
"")

(define\_insn ""\
\[(set (match\_operand:DF 0 "general\_operand" "=x,y,y")\
(minus:DF (match\_operand:DF 1 "general\_operand" "xH,y,dmF")\
(match\_operand:DF 2 "general\_operand" "xH,dmF,0")))]\
"TARGET\_FPA"\
"\*\
{\
if (rtx\_equal\_p (operands\[0], operands\[2]))\
return "fprsub%.d %y1,%0";\
if (rtx\_equal\_p (operands\[0], operands\[1]))\
return "fpsub%.d %y2,%0";\
if (which\_alternative == 0)\
return "fpsub3%.d %w2,%w1,%0";\
return "fpsub3%.d %x2,%x1,%0";\
}")

(define\_insn ""\
\[(set (match\_operand:DF 0 "general\_operand" "=f")\
(minus:DF (match\_operand:DF 1 "general\_operand" "0")\
(match\_operand:DF 2 "general\_operand" "fmG")))]\
"TARGET\_68881"\
"\*\
{\
if (REG\_P (operands\[2]))\
return "fsub%.x %2,%0";\
return "fsub%.d %f2,%0";\
}")

(define\_expand "subsf3"\
\[(set (match\_operand:SF 0 "general\_operand" "")\
(minus:SF (match\_operand:SF 1 "general\_operand" "")\
(match\_operand:SF 2 "general\_operand" "")))]\
"TARGET\_68881 || TARGET\_FPA"\
"")

(define\_insn ""\
\[(set (match\_operand:SF 0 "general\_operand" "=x,y,y")\
(minus:SF (match\_operand:SF 1 "general\_operand" "xH,y,rmF")\
(match\_operand:SF 2 "general\_operand" "xH,rmF,0")))]\
"TARGET\_FPA"\
"\*\
{\
if (rtx\_equal\_p (operands\[0], operands\[2]))\
return "fprsub%.s %w1,%0";\
if (rtx\_equal\_p (operands\[0], operands\[1]))\
return "fpsub%.s %w2,%0";\
if (which\_alternative == 0)\
return "fpsub3%.s %w2,%w1,%0";\
return "fpsub3%.s %2,%1,%0";\
}")

(define\_insn ""\
\[(set (match\_operand:SF 0 "general\_operand" "=f")\
(minus:SF (match\_operand:SF 1 "general\_operand" "0")\
(match\_operand:SF 2 "general\_operand" "fdmF")))]\
"TARGET\_68881"\
"\*\
{\
if (REG\_P (operands\[2]) && ! DATA\_REG\_P (operands\[2]))\
return "fsub%.x %2,%0";\
return "fsub%.s %f2,%0";\
}")\
;; multiply instructions

(define\_insn "mulhi3"\
\[(set (match\_operand:HI 0 "general\_operand" "=d")\
(mult:HI (match\_operand:HI 1 "general\_operand" "%0")\
(match\_operand:HI 2 "general\_operand" "dmn")))]\
""\
"\*\
{\
\#ifdef MOTOROLA\
return "muls.w %2,%0";\
\#else\
return "muls %2,%0";\
\#endif\
}")

(define\_insn "mulhisi3"\
\[(set (match\_operand:SI 0 "general\_operand" "=d")\
(mult:SI (match\_operand:HI 1 "general\_operand" "%0")\
(match\_operand:HI 2 "general\_operand" "dmn")))]\
""\
"\*\
{\
\#ifdef MOTOROLA\
return "muls.w %2,%0";\
\#else\
return "muls %2,%0";\
\#endif\
}")

(define\_insn "mulsi3"\
\[(set (match\_operand:SI 0 "general\_operand" "=d")\
(mult:SI (match\_operand:SI 1 "general\_operand" "%0")\
(match\_operand:SI 2 "general\_operand" "dmsK")))]\
"TARGET\_68020"\
"muls%.l %2,%0")

(define\_insn "umulhi3"\
\[(set (match\_operand:HI 0 "general\_operand" "=d")\
(umult:HI (match\_operand:HI 1 "general\_operand" "%0")\
(match\_operand:HI 2 "general\_operand" "dmn")))]\
""\
"\*\
{\
\#ifdef MOTOROLA\
return "mulu.w %2,%0";\
\#else\
return "mulu %2,%0";\
\#endif\
}")

(define\_insn "umulhisi3"\
\[(set (match\_operand:SI 0 "general\_operand" "=d")\
(umult:SI (match\_operand:HI 1 "general\_operand" "%0")\
(match\_operand:HI 2 "general\_operand" "dmn")))]\
""\
"\*\
{\
\#ifdef MOTOROLA\
return "mulu.w %2,%0";\
\#else\
return "mulu %2,%0";\
\#endif\
}")

(define\_insn "umulsi3"\
\[(set (match\_operand:SI 0 "general\_operand" "=d")\
(umult:SI (match\_operand:SI 1 "general\_operand" "%0")\
(match\_operand:SI 2 "general\_operand" "dmsK")))]\
"TARGET\_68020"\
"mulu%.l %2,%0")

(define\_expand "muldf3"\
\[(set (match\_operand:DF 0 "general\_operand" "")\
(mult:DF (match\_operand:DF 1 "general\_operand" "")\
(match\_operand:DF 2 "general\_operand" "")))]\
"TARGET\_68881 || TARGET\_FPA"\
"")

(define\_insn ""\
\[(set (match\_operand:DF 0 "general\_operand" "=x,y")\
(mult:DF (match\_operand:DF 1 "general\_operand" "%xH,y")\
(match\_operand:DF 2 "general\_operand" "xH,rmF")))]\
"TARGET\_FPA"\
"\*\
{\
if (rtx\_equal\_p (operands\[1], operands\[2]))\
return "fpsqr%.d %y1,%0";\
if (rtx\_equal\_p (operands\[0], operands\[1]))\
return "fpmul%.d %y2,%0";\
if (rtx\_equal\_p (operands\[0], operands\[2]))\
return "fpmul%.d %y1,%0";\
if (which\_alternative == 0)\
return "fpmul3%.d %w2,%w1,%0";\
return "fpmul3%.d %x2,%x1,%0";\
}")

(define\_insn ""\
\[(set (match\_operand:DF 0 "general\_operand" "=f")\
(mult:DF (match\_operand:DF 1 "general\_operand" "%0")\
(match\_operand:DF 2 "general\_operand" "fmG")))]\
"TARGET\_68881"\
"\*\
{\
if (REG\_P (operands\[2]))\
return "fmul%.x %2,%0";\
return "fmul%.d %f2,%0";\
}")

(define\_expand "mulsf3"\
\[(set (match\_operand:SF 0 "general\_operand" "")\
(mult:SF (match\_operand:SF 1 "general\_operand" "")\
(match\_operand:SF 2 "general\_operand" "")))]\
"TARGET\_68881 || TARGET\_FPA"\
"")

(define\_insn ""\
\[(set (match\_operand:SF 0 "general\_operand" "=x,y")\
(mult:SF (match\_operand:SF 1 "general\_operand" "%xH,y")\
(match\_operand:SF 2 "general\_operand" "xH,rmF")))]\
"TARGET\_FPA"\
"\*\
{\
if (rtx\_equal\_p (operands\[1], operands\[2]))\
return "fpsqr%.s %w1,%0";\
if (rtx\_equal\_p (operands\[0], operands\[1]))\
return "fpmul%.s %w2,%0";\
if (rtx\_equal\_p (operands\[0], operands\[2]))\
return "fpmul%.s %w1,%0";\
if (which\_alternative == 0)\
return "fpmul3%.s %w2,%w1,%0";\
return "fpmul3%.s %2,%1,%0";\
}")

(define\_insn ""\
\[(set (match\_operand:SF 0 "general\_operand" "=f")\
(mult:SF (match\_operand:SF 1 "general\_operand" "%0")\
(match\_operand:SF 2 "general\_operand" "fdmF")))]\
"TARGET\_68881"\
"\*\
{\
if (REG\_P (operands\[2]) && ! DATA\_REG\_P (operands\[2]))\
return "fsglmul%.x %2,%0";\
return "fsglmul%.s %f2,%0";\
}")\
;; divide instructions

(define\_insn "divhi3"\
\[(set (match\_operand:HI 0 "general\_operand" "=d")\
(div:HI (match\_operand:HI 1 "general\_operand" "0")\
(match\_operand:HI 2 "general\_operand" "dmn")))]\
""\
"\*\
{\
\#ifdef MOTOROLA\
return "ext.l %0;divs.w %2,%0";\
\#else\
return "extl %0;divs %2,%0";\
\#endif\
}")

(define\_insn "divhisi3"\
\[(set (match\_operand:HI 0 "general\_operand" "=d")\
(div:HI (match\_operand:SI 1 "general\_operand" "0")\
(match\_operand:HI 2 "general\_operand" "dmn")))]\
""\
"\*\
{\
\#ifdef MOTOROLA\
return "divs.w %2,%0";\
\#else\
return "divs %2,%0";\
\#endif\
}")

(define\_insn "divsi3"\
\[(set (match\_operand:SI 0 "general\_operand" "=d")\
(div:SI (match\_operand:SI 1 "general\_operand" "0")\
(match\_operand:SI 2 "general\_operand" "dmsK")))]\
"TARGET\_68020"\
"divs%.l %2,%0")

(define\_insn "udivhi3"\
\[(set (match\_operand:HI 0 "general\_operand" "=d")\
(udiv:HI (match\_operand:HI 1 "general\_operand" "0")\
(match\_operand:HI 2 "general\_operand" "dmn")))]\
""\
"\*\
{\
\#ifdef MOTOROLA\
return "and.l %#0xFFFF,%0;divu.w %2,%0";\
\#else\
return "andl %#0xFFFF,%0;divu %2,%0";\
\#endif\
}")

(define\_insn "udivhisi3"\
\[(set (match\_operand:HI 0 "general\_operand" "=d")\
(udiv:HI (match\_operand:SI 1 "general\_operand" "0")\
(match\_operand:HI 2 "general\_operand" "dmn")))]\
""\
"\*\
{\
\#ifdef MOTOROLA\
return "divu.w %2,%0";\
\#else\
return "divu %2,%0";\
\#endif\
}")

(define\_insn "udivsi3"\
\[(set (match\_operand:SI 0 "general\_operand" "=d")\
(udiv:SI (match\_operand:SI 1 "general\_operand" "0")\
(match\_operand:SI 2 "general\_operand" "dmsK")))]\
"TARGET\_68020"\
"divu%.l %2,%0")

(define\_expand "divdf3"\
\[(set (match\_operand:DF 0 "general\_operand" "")\
(div:DF (match\_operand:DF 1 "general\_operand" "")\
(match\_operand:DF 2 "general\_operand" "")))]\
"TARGET\_68881 || TARGET\_FPA"\
"")

(define\_insn ""\
\[(set (match\_operand:DF 0 "general\_operand" "=x,y,y")\
(div:DF (match\_operand:DF 1 "general\_operand" "xH,y,rmF")\
(match\_operand:DF 2 "general\_operand" "xH,rmF,0")))]\
"TARGET\_FPA"\
"\*\
{\
if (rtx\_equal\_p (operands\[0], operands\[2]))\
return "fprdiv%.d %y1,%0";\
if (rtx\_equal\_p (operands\[0], operands\[1]))\
return "fpdiv%.d %y2,%0";\
if (which\_alternative == 0)\
return "fpdiv3%.d %w2,%w1,%0";\
return "fpdiv3%.d %x2,%x1,%x0";\
}")

(define\_insn ""\
\[(set (match\_operand:DF 0 "general\_operand" "=f")\
(div:DF (match\_operand:DF 1 "general\_operand" "0")\
(match\_operand:DF 2 "general\_operand" "fmG")))]\
"TARGET\_68881"\
"\*\
{\
if (REG\_P (operands\[2]))\
return "fdiv%.x %2,%0";\
return "fdiv%.d %f2,%0";\
}")

(define\_expand "divsf3"\
\[(set (match\_operand:SF 0 "general\_operand" "")\
(div:SF (match\_operand:SF 1 "general\_operand" "")\
(match\_operand:SF 2 "general\_operand" "")))]\
"TARGET\_68881 || TARGET\_FPA"\
"")

(define\_insn ""\
\[(set (match\_operand:SF 0 "general\_operand" "=x,y,y")\
(div:SF (match\_operand:SF 1 "general\_operand" "xH,y,rmF")\
(match\_operand:SF 2 "general\_operand" "xH,rmF,0")))]\
"TARGET\_FPA"\
"\*\
{\
if (rtx\_equal\_p (operands\[0], operands\[1]))\
return "fpdiv%.s %w2,%0";\
if (rtx\_equal\_p (operands\[0], operands\[2]))\
return "fprdiv%.s %w1,%0";\
if (which\_alternative == 0)\
return "fpdiv3%.s %w2,%w1,%0";\
return "fpdiv3%.s %2,%1,%0";\
}")

(define\_insn ""\
\[(set (match\_operand:SF 0 "general\_operand" "=f")\
(div:SF (match\_operand:SF 1 "general\_operand" "0")\
(match\_operand:SF 2 "general\_operand" "fdmF")))]\
"TARGET\_68881"\
"\*\
{\
if (REG\_P (operands\[2]) && ! DATA\_REG\_P (operands\[2]))\
return "fsgldiv%.x %2,%0";\
return "fsgldiv%.s %f2,%0";\
}")\
;; Remainder instructions.

(define\_insn "modhi3"\
\[(set (match\_operand:HI 0 "general\_operand" "=d")\
(mod:HI (match\_operand:HI 1 "general\_operand" "0")\
(match\_operand:HI 2 "general\_operand" "dmn")))]\
""\
"\*\
{\
/\* The swap insn produces cc's that don't correspond to the result. \*/\
CC\_STATUS\_INIT;\
\#ifdef MOTOROLA\
\#ifdef SGS\_3B1\
return "ext.l %0;divs.w %2,%0;swap.w %0";\
\#else\
return "ext.l %0;divs.w %2,%0;swap %0";\
\#endif\
\#else\
return "extl %0;divs %2,%0;swap %0";\
\#endif\
}")

(define\_insn "modhisi3"\
\[(set (match\_operand:HI 0 "general\_operand" "=d")\
(mod:HI (match\_operand:SI 1 "general\_operand" "0")\
(match\_operand:HI 2 "general\_operand" "dmn")))]\
""\
"\*\
{\
/\* The swap insn produces cc's that don't correspond to the result. \*/\
CC\_STATUS\_INIT;\
\#ifdef MOTOROLA\
\#ifdef SGS\_3B1\
return "divs.w %2,%0;swap.w %0";\
\#else\
return "divs.w %2,%0;swap %0";\
\#endif\
\#else\
return "divs %2,%0;swap %0";\
\#endif\
}")

(define\_insn "umodhi3"\
\[(set (match\_operand:HI 0 "general\_operand" "=d")\
(umod:HI (match\_operand:HI 1 "general\_operand" "0")\
(match\_operand:HI 2 "general\_operand" "dmn")))]\
""\
"\*\
{\
/\* The swap insn produces cc's that don't correspond to the result. \*/\
CC\_STATUS\_INIT;\
\#ifdef MOTOROLA\
\#ifdef SGS\_3B1\
return "and.l %#0xFFFF,%0;divu.w %2,%0;swap.w %0";\
\#else\
return "and.l %#0xFFFF,%0;divu.w %2,%0;swap %0";\
\#endif\
\#else\
return "andl %#0xFFFF,%0;divu %2,%0;swap %0";\
\#endif\
}")

(define\_insn "umodhisi3"\
\[(set (match\_operand:HI 0 "general\_operand" "=d")\
(umod:HI (match\_operand:SI 1 "general\_operand" "0")\
(match\_operand:HI 2 "general\_operand" "dmn")))]\
""\
"\*\
{\
/\* The swap insn produces cc's that don't correspond to the result. \*/\
CC\_STATUS\_INIT;\
\#ifdef MOTOROLA\
\#ifdef SGS\_3B1\
return "divu.w %2,%0;swap.w %0";\
\#else\
return "divu.w %2,%0;swap %0";\
\#endif\
\#else\
return "divu %2,%0;swap %0";\
\#endif\
}")

(define\_insn "divmodsi4"\
\[(set (match\_operand:SI 0 "general\_operand" "=d")\
(div:SI (match\_operand:SI 1 "general\_operand" "0")\
(match\_operand:SI 2 "general\_operand" "dmsK")))\
(set (match\_operand:SI 3 "general\_operand" "=d")\
(mod:SI (match\_dup 1) (match\_dup 2)))]\
"TARGET\_68020"\
"divsl%.l %2,%3:%0")

(define\_insn "udivmodsi4"\
\[(set (match\_operand:SI 0 "general\_operand" "=d")\
(udiv:SI (match\_operand:SI 1 "general\_operand" "0")\
(match\_operand:SI 2 "general\_operand" "dmsK")))\
(set (match\_operand:SI 3 "general\_operand" "=d")\
(umod:SI (match\_dup 1) (match\_dup 2)))]\
"TARGET\_68020"\
"divul%.l %2,%3:%0")\
;; logical-and instructions

(define\_insn "andsi3"\
\[(set (match\_operand:SI 0 "general\_operand" "=m,d")\
(and:SI (match\_operand:SI 1 "general\_operand" "%0,0")\
(match\_operand:SI 2 "general\_operand" "dKs,dmKs")))]\
""\
"\*\
{\
if (GET\_CODE (operands\[2]) == CONST\_INT\
&& (INTVAL (operands\[2]) | 0xffff) == 0xffffffff\
&& (DATA\_REG\_P (operands\[0])\
|| offsettable\_memref\_p (operands\[0])))\
{\
if (GET\_CODE (operands\[0]) != REG)\
operands\[0] = adj\_offsettable\_operand (operands\[0], 2);\
operands\[2] = gen\_rtx (CONST\_INT, VOIDmode,\
INTVAL (operands\[2]) & 0xffff);\
/\* Do not delete a following tstl %0 insn; that would be incorrect. \*/\
CC\_STATUS\_INIT;\
if (operands\[2] == const0\_rtx)\
return "clr%.w %0";\
return "and%.w %2,%0";\
}\
return "and%.l %2,%0";\
}")

(define\_insn "andhi3"\
\[(set (match\_operand:HI 0 "general\_operand" "=m,d")\
(and:HI (match\_operand:HI 1 "general\_operand" "%0,0")\
(match\_operand:HI 2 "general\_operand" "dn,dmn")))]\
""\
"and%.w %2,%0")

(define\_insn "andqi3"\
\[(set (match\_operand:QI 0 "general\_operand" "=m,d")\
(and:QI (match\_operand:QI 1 "general\_operand" "%0,0")\
(match\_operand:QI 2 "general\_operand" "dn,dmn")))]\
""\
"and%.b %2,%0")

(define\_insn ""\
\[(set (match\_operand:SI 0 "general\_operand" "=d")\
(and:SI (zero\_extend:SI (match\_operand:HI 1 "general\_operand" "dm"))\
(match\_operand:SI 2 "general\_operand" "0")))]\
"GET\_CODE (operands\[2]) == CONST\_INT\
&& (unsigned int) INTVAL (operands\[2]) < (1 << GET\_MODE\_BITSIZE (HImode))"\
"and%.w %1,%0")

(define\_insn ""\
\[(set (match\_operand:SI 0 "general\_operand" "=d")\
(and:SI (zero\_extend:SI (match\_operand:QI 1 "general\_operand" "dm"))\
(match\_operand:SI 2 "general\_operand" "0")))]\
"GET\_CODE (operands\[2]) == CONST\_INT\
&& (unsigned int) INTVAL (operands\[2]) < (1 << GET\_MODE\_BITSIZE (QImode))"\
"and%.b %1,%0")\
;; inclusive-or instructions

(define\_insn "iorsi3"\
\[(set (match\_operand:SI 0 "general\_operand" "=m,d")\
(ior:SI (match\_operand:SI 1 "general\_operand" "%0,0")\
(match\_operand:SI 2 "general\_operand" "dKs,dmKs")))]\
""\
"\*\
{\
register int logval;\
if (GET\_CODE (operands\[2]) == CONST\_INT\
&& INTVAL (operands\[2]) >> 16 == 0\
&& (DATA\_REG\_P (operands\[0])\
|| offsettable\_memref\_p (operands\[0])))\
{\
if (GET\_CODE (operands\[0]) != REG)\
operands\[0] = adj\_offsettable\_operand (operands\[0], 2);\
/\* Do not delete a following tstl %0 insn; that would be incorrect. \*/\
CC\_STATUS\_INIT;\
return "or%.w %2,%0";\
}\
if (GET\_CODE (operands\[2]) == CONST\_INT\
&& (logval = exact\_log2 (INTVAL (operands\[2]))) >= 0\
&& (DATA\_REG\_P (operands\[0])\
|| offsettable\_memref\_p (operands\[0])))\
{\
if (DATA\_REG\_P (operands\[0]))\
{\
operands\[1] = gen\_rtx (CONST\_INT, VOIDmode, logval);\
}\
else\
{\
operands\[0] = adj\_offsettable\_operand (operands\[0], 3 - (logval / 8));\
operands\[1] = gen\_rtx (CONST\_INT, VOIDmode, logval % 8);\
}\
return "bset %1,%0";\
}\
return "or%.l %2,%0";\
}")

(define\_insn "iorhi3"\
\[(set (match\_operand:HI 0 "general\_operand" "=m,d")\
(ior:HI (match\_operand:HI 1 "general\_operand" "%0,0")\
(match\_operand:HI 2 "general\_operand" "dn,dmn")))]\
""\
"or%.w %2,%0")

(define\_insn "iorqi3"\
\[(set (match\_operand:QI 0 "general\_operand" "=m,d")\
(ior:QI (match\_operand:QI 1 "general\_operand" "%0,0")\
(match\_operand:QI 2 "general\_operand" "dn,dmn")))]\
""\
"or%.b %2,%0")\
;; xor instructions

(define\_insn "xorsi3"\
\[(set (match\_operand:SI 0 "general\_operand" "=do,m")\
(xor:SI (match\_operand:SI 1 "general\_operand" "%0,0")\
(match\_operand:SI 2 "general\_operand" "di,dKs")))]\
""\
"\*\
{\
if (GET\_CODE (operands\[2]) == CONST\_INT\
&& INTVAL (operands\[2]) >> 16 == 0\
&& (offsettable\_memref\_p (operands\[0]) || DATA\_REG\_P (operands\[0])))\
{\
if (! DATA\_REG\_P (operands\[0]))\
operands\[0] = adj\_offsettable\_operand (operands\[0], 2);\
/\* Do not delete a following tstl %0 insn; that would be incorrect. \*/\
CC\_STATUS\_INIT;\
return "eor%.w %2,%0";\
}\
return "eor%.l %2,%0";\
}")

(define\_insn "xorhi3"\
\[(set (match\_operand:HI 0 "general\_operand" "=dm")\
(xor:HI (match\_operand:HI 1 "general\_operand" "%0")\
(match\_operand:HI 2 "general\_operand" "dn")))]\
""\
"eor%.w %2,%0")

(define\_insn "xorqi3"\
\[(set (match\_operand:QI 0 "general\_operand" "=dm")\
(xor:QI (match\_operand:QI 1 "general\_operand" "%0")\
(match\_operand:QI 2 "general\_operand" "dn")))]\
""\
"eor%.b %2,%0")\
;; negation instructions

(define\_insn "negsi2"\
\[(set (match\_operand:SI 0 "general\_operand" "=dm")\
(neg:SI (match\_operand:SI 1 "general\_operand" "0")))]\
""\
"neg%.l %0")

(define\_insn "neghi2"\
\[(set (match\_operand:HI 0 "general\_operand" "=dm")\
(neg:HI (match\_operand:HI 1 "general\_operand" "0")))]\
""\
"neg%.w %0")

(define\_insn "negqi2"\
\[(set (match\_operand:QI 0 "general\_operand" "=dm")\
(neg:QI (match\_operand:QI 1 "general\_operand" "0")))]\
""\
"neg%.b %0")

(define\_expand "negsf2"\
\[(set (match\_operand:SF 0 "general\_operand" "")\
(neg:SF (match\_operand:SF 1 "general\_operand" "")))]\
"TARGET\_68881 || TARGET\_FPA"\
"")

(define\_insn ""\
\[(set (match\_operand:SF 0 "general\_operand" "=x,y")\
(neg:SF (match\_operand:SF 1 "general\_operand" "xH,rmF")))]\
"TARGET\_FPA"\
"fpneg%.s %w1,%0")

(define\_insn ""\
\[(set (match\_operand:SF 0 "general\_operand" "=f")\
(neg:SF (match\_operand:SF 1 "general\_operand" "fdmF")))]\
"TARGET\_68881"\
"\*\
{\
if (REG\_P (operands\[1]) && ! DATA\_REG\_P (operands\[1]))\
return "fneg%.x %1,%0";\
return "fneg%.s %f1,%0";\
}")

(define\_expand "negdf2"\
\[(set (match\_operand:DF 0 "general\_operand" "")\
(neg:DF (match\_operand:DF 1 "general\_operand" "")))]\
"TARGET\_68881 || TARGET\_FPA"\
"")

(define\_insn ""\
\[(set (match\_operand:DF 0 "general\_operand" "=x,y")\
(neg:DF (match\_operand:DF 1 "general\_operand" "xH,rmF")))]\
"TARGET\_FPA"\
"fpneg%.d %y1, %0")

(define\_insn ""\
\[(set (match\_operand:DF 0 "general\_operand" "=f")\
(neg:DF (match\_operand:DF 1 "general\_operand" "fmF")))]\
"TARGET\_68881"\
"\*\
{\
if (REG\_P (operands\[1]) && ! DATA\_REG\_P (operands\[1]))\
return "fneg%.x %1,%0";\
return "fneg%.d %f1,%0";\
}")\
;; Absolute value instructions

(define\_expand "abssf2"\
\[(set (match\_operand:SF 0 "general\_operand" "")\
(abs:SF (match\_operand:SF 1 "general\_operand" "")))]\
"TARGET\_68881 || TARGET\_FPA"\
"")

(define\_insn ""\
\[(set (match\_operand:SF 0 "general\_operand" "=x,y")\
(abs:SF (match\_operand:SF 1 "general\_operand" "xH,rmF")))]\
"TARGET\_FPA"\
"fpabs%.s %y1,%0")

(define\_insn ""\
\[(set (match\_operand:SF 0 "general\_operand" "=f")\
(abs:SF (match\_operand:SF 1 "general\_operand" "fdmF")))]\
"TARGET\_68881"\
"\*\
{\
if (REG\_P (operands\[1]) && ! DATA\_REG\_P (operands\[1]))\
return "fabs%.x %1,%0";\
return "fabs%.s %f1,%0";\
}")

(define\_expand "absdf2"\
\[(set (match\_operand:DF 0 "general\_operand" "")\
(abs:DF (match\_operand:DF 1 "general\_operand" "")))]\
"TARGET\_68881 || TARGET\_FPA"\
"")

(define\_insn ""\
\[(set (match\_operand:DF 0 "general\_operand" "=x,y")\
(abs:DF (match\_operand:DF 1 "general\_operand" "xH,rmF")))]\
"TARGET\_FPA"\
"fpabs%.d %y1,%0")

(define\_insn ""\
\[(set (match\_operand:DF 0 "general\_operand" "=f")\
(abs:DF (match\_operand:DF 1 "general\_operand" "fmF")))]\
"TARGET\_68881"\
"\*\
{\
if (REG\_P (operands\[1]) && ! DATA\_REG\_P (operands\[1]))\
return "fabs%.x %1,%0";\
return "fabs%.d %f1,%0";\
}")\
;; one complement instructions

(define\_insn "one\_cmplsi2"\
\[(set (match\_operand:SI 0 "general\_operand" "=dm")\
(not:SI (match\_operand:SI 1 "general\_operand" "0")))]\
""\
"not%.l %0")

(define\_insn "one\_cmplhi2"\
\[(set (match\_operand:HI 0 "general\_operand" "=dm")\
(not:HI (match\_operand:HI 1 "general\_operand" "0")))]\
""\
"not%.w %0")

(define\_insn "one\_cmplqi2"\
\[(set (match\_operand:QI 0 "general\_operand" "=dm")\
(not:QI (match\_operand:QI 1 "general\_operand" "0")))]\
""\
"not%.b %0")\
;; Optimized special case of shifting.\
;; Must precede the general case.

(define\_insn ""\
\[(set (match\_operand:SI 0 "general\_operand" "=d")\
(ashiftrt:SI (match\_operand:SI 1 "memory\_operand" "m")\
(const\_int 24)))]\
"GET\_CODE (XEXP (operands\[1], 0)) != POST\_INC\
&& GET\_CODE (XEXP (operands\[1], 0)) != PRE\_DEC"\
"\*\
{\
if (TARGET\_68020)\
return "move%.b %1,%0;extb%.l %0";\
return "move%.b %1,%0;ext%.w %0;ext%.l %0";\
}")

(define\_insn ""\
\[(set (match\_operand:SI 0 "general\_operand" "=d")\
(lshiftrt:SI (match\_operand:SI 1 "memory\_operand" "m")\
(const\_int 24)))]\
"GET\_CODE (XEXP (operands\[1], 0)) != POST\_INC\
&& GET\_CODE (XEXP (operands\[1], 0)) != PRE\_DEC"\
"\*\
{\
if (reg\_mentioned\_p (operands\[0], operands\[1]))\
return "move%.b %1,%0;and%.l %#0xFF,%0";\
return "clr%.l %0;move%.b %1,%0";\
}")

(define\_insn ""\
\[(set (cc0) (compare (match\_operand:QI 0 "general\_operand" "i")\
(lshiftrt:SI (match\_operand:SI 1 "memory\_operand" "m")\
(const\_int 24))))]\
"(GET\_CODE (operands\[0]) == CONST\_INT\
&& (INTVAL (operands\[0]) & \~0xff) == 0)"\
"\* cc\_status.flags |= CC\_REVERSED;\
\#ifdef HPUX\_ASM\
return "cmp%.b %1,%0";\
\#else\
return "cmp%.b %0,%1";\
\#endif\
")

(define\_insn ""\
\[(set (cc0) (compare (lshiftrt:SI (match\_operand:SI 0 "memory\_operand" "m")\
(const\_int 24))\
(match\_operand:QI 1 "general\_operand" "i")))]\
"(GET\_CODE (operands\[1]) == CONST\_INT\
&& (INTVAL (operands\[1]) & \~0xff) == 0)"\
"\*\
\#ifdef HPUX\_ASM\
return "cmp%.b %0,%1";\
\#else\
return "cmp%.b %1,%0";\
\#endif\
")

(define\_insn ""\
\[(set (cc0) (compare (match\_operand:QI 0 "general\_operand" "i")\
(ashiftrt:SI (match\_operand:SI 1 "memory\_operand" "m")\
(const\_int 24))))]\
"(GET\_CODE (operands\[0]) == CONST\_INT\
&& ((INTVAL (operands\[0]) + 0x80) & \~0xff) == 0)"\
"\* cc\_status.flags |= CC\_REVERSED;\
\#ifdef HPUX\_ASM\
return "cmp%.b %1,%0";\
\#else\
return "cmp%.b %0,%1";\
\#endif\
")

(define\_insn ""\
\[(set (cc0) (compare (ashiftrt:SI (match\_operand:SI 0 "memory\_operand" "m")\
(const\_int 24))\
(match\_operand:QI 1 "general\_operand" "i")))]\
"(GET\_CODE (operands\[1]) == CONST\_INT\
&& ((INTVAL (operands\[1]) + 0x80) & \~0xff) == 0)"\
"\*\
\#ifdef HPUX\_ASM\
return "cmp%.b %0,%1";\
\#else\
return "cmp%.b %1,%0";\
\#endif\
")\
;; arithmetic shift instructions\
;; We don't need the shift memory by 1 bit instruction

(define\_insn "ashlsi3"\
\[(set (match\_operand:SI 0 "general\_operand" "=d")\
(ashift:SI (match\_operand:SI 1 "general\_operand" "0")\
(match\_operand:SI 2 "general\_operand" "dI")))]\
""\
"asl%.l %2,%0")

(define\_insn "ashlhi3"\
\[(set (match\_operand:HI 0 "general\_operand" "=d")\
(ashift:HI (match\_operand:HI 1 "general\_operand" "0")\
(match\_operand:HI 2 "general\_operand" "dI")))]\
""\
"asl%.w %2,%0")

(define\_insn "ashlqi3"\
\[(set (match\_operand:QI 0 "general\_operand" "=d")\
(ashift:QI (match\_operand:QI 1 "general\_operand" "0")\
(match\_operand:QI 2 "general\_operand" "dI")))]\
""\
"asl%.b %2,%0")

(define\_insn "ashrsi3"\
\[(set (match\_operand:SI 0 "general\_operand" "=d")\
(ashiftrt:SI (match\_operand:SI 1 "general\_operand" "0")\
(match\_operand:SI 2 "general\_operand" "dI")))]\
""\
"asr%.l %2,%0")

(define\_insn "ashrhi3"\
\[(set (match\_operand:HI 0 "general\_operand" "=d")\
(ashiftrt:HI (match\_operand:HI 1 "general\_operand" "0")\
(match\_operand:HI 2 "general\_operand" "dI")))]\
""\
"asr%.w %2,%0")

(define\_insn "ashrqi3"\
\[(set (match\_operand:QI 0 "general\_operand" "=d")\
(ashiftrt:QI (match\_operand:QI 1 "general\_operand" "0")\
(match\_operand:QI 2 "general\_operand" "dI")))]\
""\
"asr%.b %2,%0")\
;; logical shift instructions

(define\_insn "lshlsi3"\
\[(set (match\_operand:SI 0 "general\_operand" "=d")\
(lshift:SI (match\_operand:SI 1 "general\_operand" "0")\
(match\_operand:SI 2 "general\_operand" "dI")))]\
""\
"lsl%.l %2,%0")

(define\_insn "lshlhi3"\
\[(set (match\_operand:HI 0 "general\_operand" "=d")\
(lshift:HI (match\_operand:HI 1 "general\_operand" "0")\
(match\_operand:HI 2 "general\_operand" "dI")))]\
""\
"lsl%.w %2,%0")

(define\_insn "lshlqi3"\
\[(set (match\_operand:QI 0 "general\_operand" "=d")\
(lshift:QI (match\_operand:QI 1 "general\_operand" "0")\
(match\_operand:QI 2 "general\_operand" "dI")))]\
""\
"lsl%.b %2,%0")

(define\_insn "lshrsi3"\
\[(set (match\_operand:SI 0 "general\_operand" "=d")\
(lshiftrt:SI (match\_operand:SI 1 "general\_operand" "0")\
(match\_operand:SI 2 "general\_operand" "dI")))]\
""\
"lsr%.l %2,%0")

(define\_insn "lshrhi3"\
\[(set (match\_operand:HI 0 "general\_operand" "=d")\
(lshiftrt:HI (match\_operand:HI 1 "general\_operand" "0")\
(match\_operand:HI 2 "general\_operand" "dI")))]\
""\
"lsr%.w %2,%0")

(define\_insn "lshrqi3"\
\[(set (match\_operand:QI 0 "general\_operand" "=d")\
(lshiftrt:QI (match\_operand:QI 1 "general\_operand" "0")\
(match\_operand:QI 2 "general\_operand" "dI")))]\
""\
"lsr%.b %2,%0")\
;; rotate instructions

(define\_insn "rotlsi3"\
\[(set (match\_operand:SI 0 "general\_operand" "=d")\
(rotate:SI (match\_operand:SI 1 "general\_operand" "0")\
(match\_operand:SI 2 "general\_operand" "dI")))]\
""\
"rol%.l %2,%0")

(define\_insn "rotlhi3"\
\[(set (match\_operand:HI 0 "general\_operand" "=d")\
(rotate:HI (match\_operand:HI 1 "general\_operand" "0")\
(match\_operand:HI 2 "general\_operand" "dI")))]\
""\
"rol%.w %2,%0")

(define\_insn "rotlqi3"\
\[(set (match\_operand:QI 0 "general\_operand" "=d")\
(rotate:QI (match\_operand:QI 1 "general\_operand" "0")\
(match\_operand:QI 2 "general\_operand" "dI")))]\
""\
"rol%.b %2,%0")

(define\_insn "rotrsi3"\
\[(set (match\_operand:SI 0 "general\_operand" "=d")\
(rotatert:SI (match\_operand:SI 1 "general\_operand" "0")\
(match\_operand:SI 2 "general\_operand" "dI")))]\
""\
"ror%.l %2,%0")

(define\_insn "rotrhi3"\
\[(set (match\_operand:HI 0 "general\_operand" "=d")\
(rotatert:HI (match\_operand:HI 1 "general\_operand" "0")\
(match\_operand:HI 2 "general\_operand" "dI")))]\
""\
"ror%.w %2,%0")

(define\_insn "rotrqi3"\
\[(set (match\_operand:QI 0 "general\_operand" "=d")\
(rotatert:QI (match\_operand:QI 1 "general\_operand" "0")\
(match\_operand:QI 2 "general\_operand" "dI")))]\
""\
"ror%.b %2,%0")\
;; Special cases of bit-field insns which we should\
;; recognize in preference to the general case.\
;; These handle aligned 8-bit and 16-bit fields,\
;; which can usually be done with move instructions.

(define\_insn ""\
\[(set (zero\_extract:SI (match\_operand:SI 0 "nonimmediate\_operand" "+do")\
(match\_operand:SI 1 "immediate\_operand" "i")\
(match\_operand:SI 2 "immediate\_operand" "i"))\
(match\_operand:SI 3 "general\_operand" "d"))]\
"TARGET\_68020 && TARGET\_BITFIELD\
&& GET\_CODE (operands\[1]) == CONST\_INT\
&& (INTVAL (operands\[1]) == 8 || INTVAL (operands\[1]) == 16)\
&& GET\_CODE (operands\[2]) == CONST\_INT\
&& INTVAL (operands\[2]) % INTVAL (operands\[1]) == 0\
&& (GET\_CODE (operands\[0]) == REG\
|| ! mode\_dependent\_address\_p (XEXP (operands\[0], 0)))"\
"\*\
{\
if (REG\_P (operands\[0]))\
{\
if (INTVAL (operands\[1]) + INTVAL (operands\[2]) != 32)\
return "bfins %3,%0\{%b2:%b1}";\
}\
else\
operands\[0]\
\= adj\_offsettable\_operand (operands\[0], INTVAL (operands\[2]) / 8);

if (GET\_CODE (operands\[3]) == MEM)\
operands\[3] = adj\_offsettable\_operand (operands\[3],\
(32 - INTVAL (operands\[1])) / 8);\
if (INTVAL (operands\[1]) == 8)\
return "move%.b %3,%0";\
return "move%.w %3,%0";\
}")

(define\_insn ""\
\[(set (match\_operand:SI 0 "general\_operand" "=\&d")\
(zero\_extract:SI (match\_operand:SI 1 "nonimmediate\_operand" "do")\
(match\_operand:SI 2 "immediate\_operand" "i")\
(match\_operand:SI 3 "immediate\_operand" "i")))]\
"TARGET\_68020 && TARGET\_BITFIELD\
&& GET\_CODE (operands\[2]) == CONST\_INT\
&& (INTVAL (operands\[2]) == 8 || INTVAL (operands\[2]) == 16)\
&& GET\_CODE (operands\[3]) == CONST\_INT\
&& INTVAL (operands\[3]) % INTVAL (operands\[2]) == 0\
&& (GET\_CODE (operands\[1]) == REG\
|| ! mode\_dependent\_address\_p (XEXP (operands\[1], 0)))"\
"\*\
{\
if (REG\_P (operands\[1]))\
{\
if (INTVAL (operands\[2]) + INTVAL (operands\[3]) != 32)\
return "bfextu %1\{%b3:%b2},%0";\
}\
else\
operands\[1]\
\= adj\_offsettable\_operand (operands\[1], INTVAL (operands\[3]) / 8);

output\_asm\_insn ("clr%.l %0", operands);\
if (GET\_CODE (operands\[0]) == MEM)\
operands\[0] = adj\_offsettable\_operand (operands\[0],\
(32 - INTVAL (operands\[1])) / 8);\
if (INTVAL (operands\[2]) == 8)\
return "move%.b %1,%0";\
return "move%.w %1,%0";\
}")

(define\_insn ""\
\[(set (match\_operand:SI 0 "general\_operand" "=d")\
(sign\_extract:SI (match\_operand:SI 1 "nonimmediate\_operand" "do")\
(match\_operand:SI 2 "immediate\_operand" "i")\
(match\_operand:SI 3 "immediate\_operand" "i")))]\
"TARGET\_68020 && TARGET\_BITFIELD\
&& GET\_CODE (operands\[2]) == CONST\_INT\
&& (INTVAL (operands\[2]) == 8 || INTVAL (operands\[2]) == 16)\
&& GET\_CODE (operands\[3]) == CONST\_INT\
&& INTVAL (operands\[3]) % INTVAL (operands\[2]) == 0\
&& (GET\_CODE (operands\[1]) == REG\
|| ! mode\_dependent\_address\_p (XEXP (operands\[1], 0)))"\
"\*\
{\
if (REG\_P (operands\[1]))\
{\
if (INTVAL (operands\[2]) + INTVAL (operands\[3]) != 32)\
return "bfexts %1\{%b3:%b2},%0";\
}\
else\
operands\[1]\
\= adj\_offsettable\_operand (operands\[1], INTVAL (operands\[3]) / 8);

if (INTVAL (operands\[2]) == 8)\
return "move%.b %1,%0;extb%.l %0";\
return "move%.w %1,%0;ext%.l %0";\
}")\
;; Bit field instructions, general cases.\
;; "o,d" constraint causes a nonoffsettable memref to match the "o"\
;; so that its address is reloaded.

(define\_insn "extv"\
\[(set (match\_operand:SI 0 "general\_operand" "=d,d")\
(sign\_extract:SI (match\_operand:QI 1 "nonimmediate\_operand" "o,d")\
(match\_operand:SI 2 "general\_operand" "di,di")\
(match\_operand:SI 3 "general\_operand" "di,di")))]\
"TARGET\_68020 && TARGET\_BITFIELD"\
"bfexts %1\{%b3:%b2},%0")

(define\_insn "extzv"\
\[(set (match\_operand:SI 0 "general\_operand" "=d,d")\
(zero\_extract:SI (match\_operand:QI 1 "nonimmediate\_operand" "o,d")\
(match\_operand:SI 2 "general\_operand" "di,di")\
(match\_operand:SI 3 "general\_operand" "di,di")))]\
"TARGET\_68020 && TARGET\_BITFIELD"\
"bfextu %1\{%b3:%b2},%0")

(define\_insn ""\
\[(set (zero\_extract:SI (match\_operand:QI 0 "nonimmediate\_operand" "+o,d")\
(match\_operand:SI 1 "general\_operand" "di,di")\
(match\_operand:SI 2 "general\_operand" "di,di"))\
(xor:SI (zero\_extract:SI (match\_dup 0) (match\_dup 1) (match\_dup 2))\
(match\_operand 3 "immediate\_operand" "i,i")))]\
"TARGET\_68020 && TARGET\_BITFIELD\
&& GET\_CODE (operands\[3]) == CONST\_INT\
&& (INTVAL (operands\[3]) == -1\
|| (GET\_CODE (operands\[1]) == CONST\_INT\
&& (\~ INTVAL (operands\[3]) & ((1 << INTVAL (operands\[1]))- 1)) == 0))"\
"\*\
{\
CC\_STATUS\_INIT;\
return "bfchg %0\{%b2:%b1}";\
}")

(define\_insn ""\
\[(set (zero\_extract:SI (match\_operand:QI 0 "nonimmediate\_operand" "+o,d")\
(match\_operand:SI 1 "general\_operand" "di,di")\
(match\_operand:SI 2 "general\_operand" "di,di"))\
(const\_int 0))]\
"TARGET\_68020 && TARGET\_BITFIELD"\
"\*\
{\
CC\_STATUS\_INIT;\
return "bfclr %0\{%b2:%b1}";\
}")

(define\_insn ""\
\[(set (zero\_extract:SI (match\_operand:QI 0 "nonimmediate\_operand" "+o,d")\
(match\_operand:SI 1 "general\_operand" "di,di")\
(match\_operand:SI 2 "general\_operand" "di,di"))\
(const\_int -1))]\
"TARGET\_68020 && TARGET\_BITFIELD"\
"\*\
{\
CC\_STATUS\_INIT;\
return "bfset %0\{%b2:%b1}";\
}")

(define\_insn "insv"\
\[(set (zero\_extract:SI (match\_operand:QI 0 "nonimmediate\_operand" "+o,d")\
(match\_operand:SI 1 "general\_operand" "di,di")\
(match\_operand:SI 2 "general\_operand" "di,di"))\
(match\_operand:SI 3 "general\_operand" "d,d"))]\
"TARGET\_68020 && TARGET\_BITFIELD"\
"bfins %3,%0\{%b2:%b1}")

;; Now recognize bit field insns that operate on registers\
;; (or at least were intended to do so).

(define\_insn ""\
\[(set (match\_operand:SI 0 "general\_operand" "=d")\
(sign\_extract:SI (match\_operand:SI 1 "nonimmediate\_operand" "d")\
(match\_operand:SI 2 "general\_operand" "di")\
(match\_operand:SI 3 "general\_operand" "di")))]\
"TARGET\_68020 && TARGET\_BITFIELD"\
"bfexts %1\{%b3:%b2},%0")

(define\_insn ""\
\[(set (match\_operand:SI 0 "general\_operand" "=d")\
(zero\_extract:SI (match\_operand:SI 1 "nonimmediate\_operand" "d")\
(match\_operand:SI 2 "general\_operand" "di")\
(match\_operand:SI 3 "general\_operand" "di")))]\
"TARGET\_68020 && TARGET\_BITFIELD"\
"bfextu %1\{%b3:%b2},%0")

(define\_insn ""\
\[(set (zero\_extract:SI (match\_operand:SI 0 "nonimmediate\_operand" "+d")\
(match\_operand:SI 1 "general\_operand" "di")\
(match\_operand:SI 2 "general\_operand" "di"))\
(const\_int 0))]\
"TARGET\_68020 && TARGET\_BITFIELD"\
"\*\
{\
CC\_STATUS\_INIT;\
return "bfclr %0\{%b2:%b1}";\
}")

(define\_insn ""\
\[(set (zero\_extract:SI (match\_operand:SI 0 "nonimmediate\_operand" "+d")\
(match\_operand:SI 1 "general\_operand" "di")\
(match\_operand:SI 2 "general\_operand" "di"))\
(const\_int -1))]\
"TARGET\_68020 && TARGET\_BITFIELD"\
"\*\
{\
CC\_STATUS\_INIT;\
return "bfset %0\{%b2:%b1}";\
}")

(define\_insn ""\
\[(set (zero\_extract:SI (match\_operand:SI 0 "nonimmediate\_operand" "+d")\
(match\_operand:SI 1 "general\_operand" "di")\
(match\_operand:SI 2 "general\_operand" "di"))\
(match\_operand:SI 3 "general\_operand" "d"))]\
"TARGET\_68020 && TARGET\_BITFIELD"\
"\*\
{\
\#if 0\
/\* These special cases are now recognized by a specific pattern. \*/\
if (GET\_CODE (operands\[1]) == CONST\_INT && GET\_CODE (operands\[2]) == CONST\_INT\
&& INTVAL (operands\[1]) == 16 && INTVAL (operands\[2]) == 16)\
return "move%.w %3,%0";\
if (GET\_CODE (operands\[1]) == CONST\_INT && GET\_CODE (operands\[2]) == CONST\_INT\
&& INTVAL (operands\[1]) == 24 && INTVAL (operands\[2]) == 8)\
return "move%.b %3,%0";\
\#endif\
return "bfins %3,%0\{%b2:%b1}";\
}")\
;; Special patterns for optimizing bit-field instructions.

(define\_insn ""\
\[(set (cc0)\
(zero\_extract:SI (match\_operand:QI 0 "memory\_operand" "o")\
(match\_operand:SI 1 "general\_operand" "di")\
(match\_operand:SI 2 "general\_operand" "di")))]\
"TARGET\_68020 && TARGET\_BITFIELD\
&& GET\_CODE (operands\[1]) == CONST\_INT"\
"\*\
{\
if (operands\[1] == const1\_rtx\
&& GET\_CODE (operands\[2]) == CONST\_INT)\
{\
int width = GET\_CODE (operands\[0]) == REG ? 31 : 7;\
return output\_btst (operands,\
gen\_rtx (CONST\_INT, VOIDmode,\
width - INTVAL (operands\[2])),\
operands\[0],\
insn, 1000);\
/\* Pass 1000 as SIGNPOS argument so that btst will\
not think we are testing the sign bit for an \`and'\
and assume that nonzero implies a negative result. \*/\
}\
if (INTVAL (operands\[1]) != 32)\
cc\_status.flags = CC\_NOT\_NEGATIVE;\
return "bftst %0\{%b2:%b1}";\
}")

(define\_insn ""\
\[(set (cc0)\
(subreg:QI\
(zero\_extract:SI (match\_operand:QI 0 "memory\_operand" "o")\
(match\_operand:SI 1 "general\_operand" "di")\
(match\_operand:SI 2 "general\_operand" "di"))\
0\))]\
"TARGET\_68020 && TARGET\_BITFIELD\
&& GET\_CODE (operands\[1]) == CONST\_INT"\
"\*\
{\
if (operands\[1] == const1\_rtx\
&& GET\_CODE (operands\[2]) == CONST\_INT)\
{\
int width = GET\_CODE (operands\[0]) == REG ? 31 : 7;\
return output\_btst (operands,\
gen\_rtx (CONST\_INT, VOIDmode,\
width - INTVAL (operands\[2])),\
operands\[0],\
insn, 1000);\
/\* Pass 1000 as SIGNPOS argument so that btst will\
not think we are testing the sign bit for an \`and'\
and assume that nonzero implies a negative result. \*/\
}\
if (INTVAL (operands\[1]) != 32)\
cc\_status.flags = CC\_NOT\_NEGATIVE;\
return "bftst %0\{%b2:%b1}";\
}")

(define\_insn ""\
\[(set (cc0)\
(subreg:HI\
(zero\_extract:SI (match\_operand:QI 0 "memory\_operand" "o")\
(match\_operand:SI 1 "general\_operand" "di")\
(match\_operand:SI 2 "general\_operand" "di"))\
0\))]\
"TARGET\_68020 && TARGET\_BITFIELD\
&& GET\_CODE (operands\[1]) == CONST\_INT"\
"\*\
{\
if (operands\[1] == const1\_rtx\
&& GET\_CODE (operands\[2]) == CONST\_INT)\
{\
int width = GET\_CODE (operands\[0]) == REG ? 31 : 7;\
return output\_btst (operands,\
gen\_rtx (CONST\_INT, VOIDmode,\
width - INTVAL (operands\[2])),\
operands\[0],\
insn, 1000);\
/\* Pass 1000 as SIGNPOS argument so that btst will\
not think we are testing the sign bit for an \`and'\
and assume that nonzero implies a negative result. \*/\
}\
if (INTVAL (operands\[1]) != 32)\
cc\_status.flags = CC\_NOT\_NEGATIVE;\
return "bftst %0\{%b2:%b1}";\
}")

;;; now handle the register cases\
(define\_insn ""\
\[(set (cc0)\
(zero\_extract:SI (match\_operand:SI 0 "nonimmediate\_operand" "d")\
(match\_operand:SI 1 "general\_operand" "di")\
(match\_operand:SI 2 "general\_operand" "di")))]\
"TARGET\_68020 && TARGET\_BITFIELD\
&& GET\_CODE (operands\[1]) == CONST\_INT"\
"\*\
{\
if (operands\[1] == const1\_rtx\
&& GET\_CODE (operands\[2]) == CONST\_INT)\
{\
int width = GET\_CODE (operands\[0]) == REG ? 31 : 7;\
return output\_btst (operands,\
gen\_rtx (CONST\_INT, VOIDmode,\
width - INTVAL (operands\[2])),\
operands\[0],\
insn, 1000);\
/\* Pass 1000 as SIGNPOS argument so that btst will\
not think we are testing the sign bit for an \`and'\
and assume that nonzero implies a negative result. \*/\
}\
if (INTVAL (operands\[1]) != 32)\
cc\_status.flags = CC\_NOT\_NEGATIVE;\
return "bftst %0\{%b2:%b1}";\
}")

(define\_insn ""\
\[(set (cc0)\
(subreg:QI\
(zero\_extract:SI (match\_operand:SI 0 "nonimmediate\_operand" "d")\
(match\_operand:SI 1 "general\_operand" "di")\
(match\_operand:SI 2 "general\_operand" "di"))\
0\))]\
"TARGET\_68020 && TARGET\_BITFIELD\
&& GET\_CODE (operands\[1]) == CONST\_INT"\
"\*\
{\
if (operands\[1] == const1\_rtx\
&& GET\_CODE (operands\[2]) == CONST\_INT)\
{\
int width = GET\_CODE (operands\[0]) == REG ? 31 : 7;\
return output\_btst (operands,\
gen\_rtx (CONST\_INT, VOIDmode,\
width - INTVAL (operands\[2])),\
operands\[0],\
insn, 1000);\
/\* Pass 1000 as SIGNPOS argument so that btst will\
not think we are testing the sign bit for an \`and'\
and assume that nonzero implies a negative result. \*/\
}\
if (INTVAL (operands\[1]) != 32)\
cc\_status.flags = CC\_NOT\_NEGATIVE;\
return "bftst %0\{%b2:%b1}";\
}")

(define\_insn ""\
\[(set (cc0)\
(subreg:HI\
(zero\_extract:SI (match\_operand:SI 0 "nonimmediate\_operand" "d")\
(match\_operand:SI 1 "general\_operand" "di")\
(match\_operand:SI 2 "general\_operand" "di"))\
0\))]\
"TARGET\_68020 && TARGET\_BITFIELD\
&& GET\_CODE (operands\[1]) == CONST\_INT"\
"\*\
{\
if (operands\[1] == const1\_rtx\
&& GET\_CODE (operands\[2]) == CONST\_INT)\
{\
int width = GET\_CODE (operands\[0]) == REG ? 31 : 7;\
return output\_btst (operands,\
gen\_rtx (CONST\_INT, VOIDmode,\
width - INTVAL (operands\[2])),\
operands\[0],\
insn, 1000);\
/\* Pass 1000 as SIGNPOS argument so that btst will\
not think we are testing the sign bit for an \`and'\
and assume that nonzero implies a negative result. _/_\
_}_\
_if (INTVAL (operands\[1]) != 32)_\
_cc\_status.flags = CC\_NOT\_NEGATIVE;_\
_return "bftst %0\{%b2:%b1}";_\
_}")_\
_(define\_insn "seq"_\
_\[(set (match\_operand:QI 0 "general\_operand" "=d")_\
_(eq (cc0) (const\_int 0)))]_\
_""_\
_"_\
cc\_status = cc\_prev\_status;\
OUTPUT\_JUMP ("seq %0", "fseq %0", "seq %0");\
")

(define\_insn "sne"\
\[(set (match\_operand:QI 0 "general\_operand" "=d")\
(ne (cc0) (const\_int 0)))]\
""\
"\*\
cc\_status = cc\_prev\_status;\
OUTPUT\_JUMP ("sne %0", "fsne %0", "sne %0");\
")

(define\_insn "sgt"\
\[(set (match\_operand:QI 0 "general\_operand" "=d")\
(gt (cc0) (const\_int 0)))]\
""\
"\*\
cc\_status = cc\_prev\_status;\
OUTPUT\_JUMP ("sgt %0", "fsgt %0", 0);\
")

(define\_insn "sgtu"\
\[(set (match\_operand:QI 0 "general\_operand" "=d")\
(gtu (cc0) (const\_int 0)))]\
""\
"\* cc\_status = cc\_prev\_status;\
return "shi %0"; ")

(define\_insn "slt"\
\[(set (match\_operand:QI 0 "general\_operand" "=d")\
(lt (cc0) (const\_int 0)))]\
""\
"\* cc\_status = cc\_prev\_status;\
OUTPUT\_JUMP ("slt %0", "fslt %0", "smi %0"); ")

(define\_insn "sltu"\
\[(set (match\_operand:QI 0 "general\_operand" "=d")\
(ltu (cc0) (const\_int 0)))]\
""\
"\* cc\_status = cc\_prev\_status;\
return "scs %0"; ")

(define\_insn "sge"\
\[(set (match\_operand:QI 0 "general\_operand" "=d")\
(ge (cc0) (const\_int 0)))]\
""\
"\* cc\_status = cc\_prev\_status;\
OUTPUT\_JUMP ("sge %0", "fsge %0", "spl %0"); ")

(define\_insn "sgeu"\
\[(set (match\_operand:QI 0 "general\_operand" "=d")\
(geu (cc0) (const\_int 0)))]\
""\
"\* cc\_status = cc\_prev\_status;\
return "scc %0"; ")

(define\_insn "sle"\
\[(set (match\_operand:QI 0 "general\_operand" "=d")\
(le (cc0) (const\_int 0)))]\
""\
"\*\
cc\_status = cc\_prev\_status;\
OUTPUT\_JUMP ("sle %0", "fsle %0", 0);\
")

(define\_insn "sleu"\
\[(set (match\_operand:QI 0 "general\_operand" "=d")\
(leu (cc0) (const\_int 0)))]\
""\
"\* cc\_status = cc\_prev\_status;\
return "sls %0"; ")\
;; Basic conditional jump instructions.

(define\_insn "beq"\
\[(set (pc)\
(if\_then\_else (eq (cc0)\
(const\_int 0))\
(label\_ref (match\_operand 0 "" ""))\
(pc)))]\
""\
"\*\
{\
\#ifdef MOTOROLA\
OUTPUT\_JUMP ("jbeq %l0", "fbeq %l0", "jbeq %l0");\
\#else\
OUTPUT\_JUMP ("jeq %l0", "fjeq %l0", "jeq %l0");\
\#endif\
}")

(define\_insn "bne"\
\[(set (pc)\
(if\_then\_else (ne (cc0)\
(const\_int 0))\
(label\_ref (match\_operand 0 "" ""))\
(pc)))]\
""\
"\*\
{\
\#ifdef MOTOROLA\
OUTPUT\_JUMP ("jbne %l0", "fbne %l0", "jbne %l0");\
\#else\
OUTPUT\_JUMP ("jne %l0", "fjne %l0", "jne %l0");\
\#endif\
}")

(define\_insn "bgt"\
\[(set (pc)\
(if\_then\_else (gt (cc0)\
(const\_int 0))\
(label\_ref (match\_operand 0 "" ""))\
(pc)))]\
""\
"\*\
\#ifdef MOTOROLA\
OUTPUT\_JUMP ("jbgt %l0", "fbgt %l0", 0);\
\#else\
OUTPUT\_JUMP ("jgt %l0", "fjgt %l0", 0);\
\#endif\
")

(define\_insn "bgtu"\
\[(set (pc)\
(if\_then\_else (gtu (cc0)\
(const\_int 0))\
(label\_ref (match\_operand 0 "" ""))\
(pc)))]\
""\
"\*\
\#ifdef MOTOROLA\
return "jbhi %l0";\
\#else\
return "jhi %l0";\
\#endif\
")

(define\_insn "blt"\
\[(set (pc)\
(if\_then\_else (lt (cc0)\
(const\_int 0))\
(label\_ref (match\_operand 0 "" ""))\
(pc)))]\
""\
"\*\
\#ifdef MOTOROLA\
OUTPUT\_JUMP ("jblt %l0", "fblt %l0", "jbmi %l0");\
\#else\
OUTPUT\_JUMP ("jlt %l0", "fjlt %l0", "jmi %l0");\
\#endif\
")

(define\_insn "bltu"\
\[(set (pc)\
(if\_then\_else (ltu (cc0)\
(const\_int 0))\
(label\_ref (match\_operand 0 "" ""))\
(pc)))]\
""\
"\*\
\#ifdef MOTOROLA\
return "jbcs %l0";\
\#else\
return "jcs %l0";\
\#endif\
")

(define\_insn "bge"\
\[(set (pc)\
(if\_then\_else (ge (cc0)\
(const\_int 0))\
(label\_ref (match\_operand 0 "" ""))\
(pc)))]\
""\
"\*\
\#ifdef MOTOROLA\
OUTPUT\_JUMP ("jbge %l0", "fbge %l0", "jbpl %l0");\
\#else\
OUTPUT\_JUMP ("jge %l0", "fjge %l0", "jpl %l0");\
\#endif\
")

(define\_insn "bgeu"\
\[(set (pc)\
(if\_then\_else (geu (cc0)\
(const\_int 0))\
(label\_ref (match\_operand 0 "" ""))\
(pc)))]\
""\
"\*\
\#ifdef MOTOROLA\
return "jbcc %l0";\
\#else\
return "jcc %l0";\
\#endif\
")

(define\_insn "ble"\
\[(set (pc)\
(if\_then\_else (le (cc0)\
(const\_int 0))\
(label\_ref (match\_operand 0 "" ""))\
(pc)))]\
""\
"\*\
\#ifdef MOTOROLA\
OUTPUT\_JUMP ("jble %l0", "fble %l0", 0);\
\#else\
OUTPUT\_JUMP ("jle %l0", "fjle %l0", 0);\
\#endif\
")

(define\_insn "bleu"\
\[(set (pc)\
(if\_then\_else (leu (cc0)\
(const\_int 0))\
(label\_ref (match\_operand 0 "" ""))\
(pc)))]\
""\
"\*\
\#ifdef MOTOROLA\
return "jbls %l0";\
\#else\
return "jls %l0";\
\#endif\
")\
;; Negated conditional jump instructions.

(define\_insn ""\
\[(set (pc)\
(if\_then\_else (eq (cc0)\
(const\_int 0))\
(pc)\
(label\_ref (match\_operand 0 "" ""))))]\
""\
"\*\
{\
\#ifdef MOTOROLA\
OUTPUT\_JUMP ("jbne %l0", "fbne %l0", "jbne %l0");\
\#else\
OUTPUT\_JUMP ("jne %l0", "fjne %l0", "jne %l0");\
\#endif\
}")

(define\_insn ""\
\[(set (pc)\
(if\_then\_else (ne (cc0)\
(const\_int 0))\
(pc)\
(label\_ref (match\_operand 0 "" ""))))]\
""\
"\*\
{\
\#ifdef MOTOROLA\
OUTPUT\_JUMP ("jbeq %l0", "fbeq %l0", "jbeq %l0");\
\#else\
OUTPUT\_JUMP ("jeq %l0", "fjeq %l0", "jeq %l0");\
\#endif\
}")

(define\_insn ""\
\[(set (pc)\
(if\_then\_else (gt (cc0)\
(const\_int 0))\
(pc)\
(label\_ref (match\_operand 0 "" ""))))]\
""\
"\*\
\#ifdef MOTOROLA\
OUTPUT\_JUMP ("jble %l0", "fbngt %l0", 0);\
\#else\
OUTPUT\_JUMP ("jle %l0", "fjngt %l0", 0);\
\#endif\
")

(define\_insn ""\
\[(set (pc)\
(if\_then\_else (gtu (cc0)\
(const\_int 0))\
(pc)\
(label\_ref (match\_operand 0 "" ""))))]\
""\
"\*\
\#ifdef MOTOROLA\
return "jbls %l0";\
\#else\
return "jls %l0";\
\#endif\
")

(define\_insn ""\
\[(set (pc)\
(if\_then\_else (lt (cc0)\
(const\_int 0))\
(pc)\
(label\_ref (match\_operand 0 "" ""))))]\
""\
"\*\
\#ifdef MOTOROLA\
OUTPUT\_JUMP ("jbge %l0", "fbnlt %l0", "jbpl %l0");\
\#else\
OUTPUT\_JUMP ("jge %l0", "fjnlt %l0", "jpl %l0");\
\#endif\
")

(define\_insn ""\
\[(set (pc)\
(if\_then\_else (ltu (cc0)\
(const\_int 0))\
(pc)\
(label\_ref (match\_operand 0 "" ""))))]\
""\
"\*\
\#ifdef MOTOROLA\
return "jbcc %l0";\
\#else\
return "jcc %l0";\
\#endif\
")

(define\_insn ""\
\[(set (pc)\
(if\_then\_else (ge (cc0)\
(const\_int 0))\
(pc)\
(label\_ref (match\_operand 0 "" ""))))]\
""\
"\*\
\#ifdef MOTOROLA\
OUTPUT\_JUMP ("jblt %l0", "fbnge %l0", "jbmi %l0");\
\#else\
OUTPUT\_JUMP ("jlt %l0", "fjnge %l0", "jmi %l0");\
\#endif\
")

(define\_insn ""\
\[(set (pc)\
(if\_then\_else (geu (cc0)\
(const\_int 0))\
(pc)\
(label\_ref (match\_operand 0 "" ""))))]\
""\
"\*\
\#ifdef MOTOROLA\
return "jbcs %l0";\
\#else\
return "jcs %l0";\
\#endif\
")

(define\_insn ""\
\[(set (pc)\
(if\_then\_else (le (cc0)\
(const\_int 0))\
(pc)\
(label\_ref (match\_operand 0 "" ""))))]\
""\
"\*\
\#ifdef MOTOROLA\
OUTPUT\_JUMP ("jbgt %l0", "fbnle %l0", 0);\
\#else\
OUTPUT\_JUMP ("jgt %l0", "fjnle %l0", 0);\
\#endif\
")

(define\_insn ""\
\[(set (pc)\
(if\_then\_else (leu (cc0)\
(const\_int 0))\
(pc)\
(label\_ref (match\_operand 0 "" ""))))]\
""\
"\*\
\#ifdef MOTOROLA\
return "jbhi %l0";\
\#else\
return "jhi %l0";\
\#endif\
")\
;; Subroutines of "casesi".

(define\_expand "casesi\_1"\
\[(set (match\_operand:SI 3 "general\_operand" "")\
(plus:SI (match\_operand:SI 0 "general\_operand" "")\
;; Note operand 1 has been negated!\
(match\_operand:SI 1 "immediate\_operand" "")))\
(set (cc0) (compare (match\_operand:SI 2 "general\_operand" "")\
(match\_dup 3)))\
(set (pc) (if\_then\_else (ltu (cc0) (const\_int 0))\
(label\_ref (match\_operand 4 "" "")) (pc)))]\
""\
"")

(define\_expand "casesi\_2"\
\[(set (match\_operand:SI 0 "" "") (mem:HI (match\_operand:SI 1 "" "")))\
;; The USE here is so that at least one jump-insn will refer to the label,\
;; to keep it alive in jump\_optimize.\
(parallel \[(set (pc)\
(plus:SI (pc) (match\_dup 0)))\
(use (label\_ref (match\_operand 2 "" "")))])]\
""\
"")

;; Operand 0 is index (in bytes); operand 1 is minimum, operand 2 themaximum;\
;; operand 3 is CODE\_LABEL for the table;\
;; operand 4 is the CODE\_LABEL to go to if index out of range.\
(define\_expand "casesi"\
;; We don't use these for generating the RTL, but we must describe\
;; the operands here.\
\[(match\_operand:SI 0 "general\_operand" "")\
(match\_operand:SI 1 "immediate\_operand" "")\
(match\_operand:SI 2 "general\_operand" "")\
(match\_operand 3 "" "")\
(match\_operand 4 "" "")]\
""\
"\
{\
rtx table\_elt\_addr;\
rtx index\_diff;

operands\[1] = negate\_rtx (SImode, operands\[1]);\
index\_diff = gen\_reg\_rtx (SImode);\
/\* Emit the first few insns. _/_\
_emit\_insn (gen\_casesi\_1 (operands\[0], operands\[1], operands\[2],_\
_index\_diff, operands\[4]));_\
_/_ Construct a memory address. This may emit some insns. _/_\
_table\_elt\_addr_\
_= memory\_address\_noforce_\
_(HImode,_\
_gen\_rtx (PLUS, Pmode,_\
_gen\_rtx (MULT, Pmode, index\_diff,_\
_gen\_rtx (CONST\_INT, VOIDmode, 2)),_\
_gen\_rtx (LABEL\_REF, VOIDmode, operands\[3])));_\
_/_ Emit the last few insns. \*/\
emit\_insn (gen\_casesi\_2 (gen\_reg\_rtx (HImode), table\_elt\_addr, operands\[3]));\
DONE;\
}")

;; Recognize one of the insns resulting from casesi\_2.\
(define\_insn ""\
\[(set (pc)\
(plus:SI (pc) (match\_operand:HI 0 "general\_operand" "r")))\
(use (label\_ref (match\_operand 1 "" "")))]\
""\
"\*\
\#ifdef SGS\
\#ifdef ASM\_OUTPUT\_CASE\_LABEL\
return "jmp 6(%%pc,%0.w)";\
\#else\
return "jmp 2(%%pc,%0.w)";\
\#endif\
\#else /\* not SGS _/_\
_#ifdef MOTOROLA_\
_return "jmp (2,pc,%0.w)";_\
_#else_\
_return "jmp pc@(2,%0:w)";_\
_#endif_\
_#endif_\
_")_\
_;; Unconditional and other jump instructions_\
_(define\_insn "jump"_\
_\[(set (pc)_\
_(label\_ref (match\_operand 0 "" "")))]_\
_""_\
_"_\
\#ifdef MOTOROLA\
return "jbra %l0";\
\#else\
return "jra %l0";\
\#endif\
")

(define\_insn ""\
\[(set (pc)\
(if\_then\_else\
(ne (compare (plus:HI (match\_operand:HI 0 "general\_operand" "g")\
(const\_int -1))\
(const\_int -1))\
(const\_int 0))\
(label\_ref (match\_operand 1 "" ""))\
(pc)))\
(set (match\_dup 0)\
(plus:HI (match\_dup 0)\
(const\_int -1)))]\
""\
"\*\
{\
CC\_STATUS\_INIT;\
if (DATA\_REG\_P (operands\[0]))\
return "dbra %0,%l1";\
if (GET\_CODE (operands\[0]) == MEM)\
{\
\#ifdef MOTOROLA\
\#ifdef NO\_ADDSUB\_Q\
return "sub%.w %#1,%0;jbcc %l1";\
\#else\
return "subq%.w %#1,%0;jbcc %l1";\
\#endif\
\#else /\* not MOTOROLA _/_\
_return "subqw %#1,%0;jcc %l1";_\
_#endif_\
_}_\
_#ifdef MOTOROLA_\
_#ifdef HPUX\_ASM_\
_#ifndef NO\_ADDSUB\_Q_\
_return "sub%.w %#1,%0;cmp%.w %0,%#-1;jbne %l1";_\
_#else_\
_return "subq%.w %#1,%0;cmp%.w %0,%#-1;jbne %l1";_\
_#endif_\
_#else /_ not HPUX\_ASM _/_\
_return "subq%.w %#1,%0;cmp%.w %#-1,%0;jbne %l1";_\
_#endif_\
_#else /_ not MOTOROLA \*/\
return "subqw %#1,%0;cmpw %#-1,%0;jne %l1";\
\#endif\
}")

(define\_insn ""\
\[(set (pc)\
(if\_then\_else\
(ne (compare (plus:SI (match\_operand:SI 0 "general\_operand" "g")\
(const\_int -1))\
(const\_int -1))\
(const\_int 0))\
(label\_ref (match\_operand 1 "" ""))\
(pc)))\
(set (match\_dup 0)\
(plus:SI (match\_dup 0)\
(const\_int -1)))]\
""\
"\*\
{\
CC\_STATUS\_INIT;\
\#ifdef MOTOROLA\
\#ifndef NO\_ADDSUB\_Q\
if (DATA\_REG\_P (operands\[0]))\
return "dbra %0,%l1;clr.w %0;sub.l %#1,%0;jbcc %l1";\
if (GET\_CODE (operands\[0]) == MEM)\
return "sub.l %#1,%0;jbcc %l1";\
\#else\
if (DATA\_REG\_P (operands\[0]))\
return "dbra %0,%l1;clr.w %0;subq.l %#1,%0;jbcc %l1";\
if (GET\_CODE (operands\[0]) == MEM)\
return "subq.l %#1,%0;jbcc %l1";\
\#endif /\* not NO\_ADDSUB\_Q \*/\
\#ifdef HPUX\_ASM\
\#ifndef NO\_ADDSUB\_Q\
return "sub.l %#1,%0;cmp.l %0,%#-1;jbne %l1";\
\#else\
return "subq.l %#1,%0;cmp.l %0,%#-1;jbne %l1";\
\#endif\
\#else\
return "subq.l %#1,%0;cmp.l %#-1,%0;jbne %l1";\
\#endif\
\#else\
if (DATA\_REG\_P (operands\[0]))\
return "dbra %0,%l1;clrw %0;subql %#1,%0;jcc %l1";\
if (GET\_CODE (operands\[0]) == MEM)\
return "subql %#1,%0;jcc %l1";\
return "subql %#1,%0;cmpl %#-1,%0;jne %l1";\
\#endif\
}")

;; dbra patterns that use REG\_NOTES info generated by strength\_reduce.

(define\_insn ""\
\[(set (pc)\
(if\_then\_else\
(ge (plus:SI (match\_operand:SI 0 "general\_operand" "g")\
(const\_int -1))\
(const\_int 0))\
(label\_ref (match\_operand 1 "" ""))\
(pc)))\
(set (match\_dup 0)\
(plus:SI (match\_dup 0)\
(const\_int -1)))]\
"find\_reg\_note (insn, REG\_NONNEG, 0)"\
"\*\
{\
CC\_STATUS\_INIT;\
\#ifdef MOTOROLA\
\#ifndef NO\_ADDSUB\_Q\
if (DATA\_REG\_P (operands\[0]))\
return "dbra %0,%l1;clr.w %0;sub.l %#1,%0;jbcc %l1";\
if (GET\_CODE (operands\[0]) == MEM)\
return "sub.l %#1,%0;jbcc %l1";\
\#else\
if (DATA\_REG\_P (operands\[0]))\
return "dbra %0,%l1;clr.w %0;subq.l %#1,%0;jbcc %l1";\
if (GET\_CODE (operands\[0]) == MEM)\
return "subq.l %#1,%0;jbcc %l1";\
\#endif\
\#ifdef HPUX\_ASM\
\#ifndef NO\_ADDSUB\_Q\
return "sub.l %#1,%0;cmp.l %0,%#-1;jbne %l1";\
\#else\
return "subq.l %#1,%0;cmp.l %0,%#-1;jbne %l1";\
\#endif\
\#else\
return "subq.l %#1,%0;cmp.l %#-1,%0;jbne %l1";\
\#endif\
\#else\
if (DATA\_REG\_P (operands\[0]))\
return "dbra %0,%l1;clrw %0;subql %#1,%0;jcc %l1";\
if (GET\_CODE (operands\[0]) == MEM)\
return "subql %#1,%0;jcc %l1";\
return "subql %#1,%0;cmpl %#-1,%0;jne %l1";\
\#endif\
}")

;; Call subroutine with no return value.\
(define\_insn "call"\
\[(call (match\_operand:QI 0 "general\_operand" "o")\
(match\_operand:SI 1 "general\_operand" "g"))]\
;; Operand 1 not really used on the m68000.

""\
"\*\
\#ifdef MOTOROLA\
return "jsr %0";\
\#else\
return "jbsr %0";\
\#endif\
")

;; Call subroutine, returning value in operand 0\
;; (which must be a hard register).\
(define\_insn "call\_value"\
\[(set (match\_operand 0 "" "=rf")\
(call (match\_operand:QI 1 "general\_operand" "o")\
(match\_operand:SI 2 "general\_operand" "g")))]\
;; Operand 2 not really used on the m68000.\
""\
"\*\
\#ifdef MOTOROLA\
return "jsr %1";\
\#else\
return "jbsr %1";\
\#endif\
")

(define\_insn "nop"\
\[(const\_int 0)]\
""\
"nop")\
;; This should not be used unless the add/sub insns can't be.

(define\_insn ""\
\[(set (match\_operand:SI 0 "general\_operand" "=a")\
(match\_operand:QI 1 "address\_operand" "p"))]\
""\
"lea %a1,%0")\
;; This is the first machine-dependent peephole optimization.\
;; It is useful when a floating value is returned from a function call\
;; and then is moved into an FP register.\
;; But it is mainly intended to test the support for these optimizations.

(define\_peephole\
\[(set (reg:SI 15) (plus:SI (reg:SI 15) (const\_int 4)))\
(set (match\_operand:DF 0 "register\_operand" "f")\
(match\_operand:DF 1 "register\_operand" "ad"))]\
"FP\_REG\_P (operands\[0]) && ! FP\_REG\_P (operands\[1])"\
"\*\
{\
rtx xoperands\[2];\
xoperands\[1] = gen\_rtx (REG, SImode, REGNO (operands\[1]) + 1);\
output\_asm\_insn ("move%.l %1,%@", xoperands);\
output\_asm\_insn ("move%.l %1,%-", operands);\
return "fmove%.d %+,%0";\
}\
")\
;; FPA multiply and add.\
(define\_insn ""\
\[(set (match\_operand:DF 0 "register\_operand" "=x,y,y")\
(plus:DF (mult:DF (match\_operand:DF 1 "general\_operand" "%x,dmF,y")\
(match\_operand:DF 2 "general\_operand" "xH,y,y"))\
(match\_operand:DF 3 "general\_operand" "xH,y,dmF")))]\
"TARGET\_FPA"\
"\*\
{\
if (which\_alternative == 0)\
return "fpma%.d %1,%w2,%w3,%0";\
return "fpma%.d %x1,%x2,%x3,%0";\
}")

(define\_insn ""\
\[(set (match\_operand:DF 0 "register\_operand" "=x,y,y")\
(plus:DF (match\_operand:DF 1 "general\_operand" "xH,y,dmF")\
(mult:DF (match\_operand:DF 2 "general\_operand" "%x,dmF,y")\
(match\_operand:DF 3 "general\_operand" "xH,y,y"))))]\
"TARGET\_FPA"\
"\*\
{\
if (which\_alternative == 0)\
return "fpma%.d %2,%w3,%w1,%0";\
return "fpma%.d %x2,%x3,%x1,%0";\
}")

(define\_insn ""\
\[(set (match\_operand:SF 0 "register\_operand" "=x,y,y")\
(plus:SF (mult:SF (match\_operand:SF 1 "general\_operand" "%x,ydmF,y")\
(match\_operand:SF 2 "general\_operand" "xH,y,ydmF"))\
(match\_operand:SF 3 "general\_operand" "xH,ydmF,ydmF")))]\
"TARGET\_FPA"\
"\*\
{\
if (which\_alternative == 0)\
return "fpma%.s %1,%w2,%w3,%0";\
return "fpma%.s %1,%2,%3,%0";\
}")

(define\_insn ""\
\[(set (match\_operand:SF 0 "register\_operand" "=x,y,y")\
(plus:SF (match\_operand:SF 1 "general\_operand" "xH,ydmF,ydmF")\
(mult:SF (match\_operand:SF 2 "general\_operand" "%x,ydmF,y")\
(match\_operand:SF 3 "general\_operand" "xH,y,ydmF"))))]\
"TARGET\_FPA"\
"\*\
{\
if (which\_alternative == 0)\
return "fpma%.s %2,%w3,%w1,%0";\
return "fpma%.s %2,%3,%1,%0";\
}")

;; FPA Multiply and subtract\
(define\_insn ""\
\[(set (match\_operand:DF 0 "register\_operand" "=x,y,y")\
(minus:DF (match\_operand:DF 1 "general\_operand" "xH,rmF,y")\
(mult:DF (match\_operand:DF 2 "register\_operand" "%xH,y,y")\
(match\_operand:DF 3 "general\_operand" "x,y,rmF"))))]\
"TARGET\_FPA"\
"\*\
{\
if (which\_alternative == 0)\
return "fpms%.d %3,%w2,%w1,%0";\
return "fpms%.d %x3,%2,%x1,%0";\
}")

(define\_insn ""\
\[(set (match\_operand:SF 0 "register\_operand" "=x,y,y")\
(minus:SF (match\_operand:SF 1 "general\_operand" "xH,rmF,yrmF")\
(mult:SF (match\_operand:SF 2 "register\_operand" "%xH,rmF,y")\
(match\_operand:SF 3 "general\_operand" "x,y,yrmF"))))]\
"TARGET\_FPA"\
"\*\
{\
if (which\_alternative == 0)\
return "fpms%.s %3,%w2,%w1,%0";\
return "fpms%.s %3,%2,%1,%0";\
}")

(define\_insn ""\
\[(set (match\_operand:DF 0 "register\_operand" "=x,y,y")\
(minus:DF (mult:DF (match\_operand:DF 1 "register\_operand" "%xH,y,y")\
(match\_operand:DF 2 "general\_operand" "x,y,rmF"))\
(match\_operand:DF 3 "general\_operand" "xH,rmF,y")))]\
"TARGET\_FPA"\
"\*\
{\
if (which\_alternative == 0)\
return "fpmr%.d %2,%w1,%w3,%0";\
return "fpmr%.d %x2,%1,%x3,%0";\
}")

(define\_insn ""\
\[(set (match\_operand:SF 0 "register\_operand" "=x,y,y")\
(minus:SF (mult:SF (match\_operand:SF 1 "register\_operand" "%xH,rmF,y")\
(match\_operand:SF 2 "general\_operand" "x,y,yrmF"))\
(match\_operand:SF 3 "general\_operand" "xH,rmF,yrmF")))]\
"TARGET\_FPA"\
"\*\
{\
if (which\_alternative == 0)\
return "fpmr%.s %2,%w1,%w3,%0";\
return "fpmr%.s %x2,%1,%x3,%0";\
}")

;; FPA Add and multiply\
(define\_insn ""\
\[(set (match\_operand:DF 0 "register\_operand" "=x,y,y")\
(mult:DF (plus:DF (match\_operand:DF 1 "register\_operand" "%xH,y,y")\
(match\_operand:DF 2 "general\_operand" "x,y,rmF"))\
(match\_operand:DF 3 "general\_operand" "xH,rmF,y")))]\
"TARGET\_FPA"\
"\*\
{\
if (which\_alternative == 0)\
return "fpam%.d %2,%w1,%w3,%0";\
return "fpam%.d %x2,%1,%x3,%0";\
}")

(define\_insn ""\
\[(set (match\_operand:DF 0 "register\_operand" "=x,y,y")\
(mult:DF (match\_operand:DF 1 "general\_operand" "xH,rmF,y")\
(plus:DF (match\_operand:DF 2 "register\_operand" "%xH,y,y")\
(match\_operand:DF 3 "general\_operand" "x,y,rmF"))))]\
"TARGET\_FPA"\
"\*\
{\
if (which\_alternative == 0)\
return "fpam%.d %3,%w2,%w1,%0";\
return "fpam%.d %x3,%2,%x1,%0";\
}")

(define\_insn ""\
\[(set (match\_operand:SF 0 "register\_operand" "=x,y,y")\
(mult:SF (plus:SF (match\_operand:SF 1 "register\_operand" "%xH,rmF,y")\
(match\_operand:SF 2 "general\_operand" "x,y,yrmF"))\
(match\_operand:SF 3 "general\_operand" "xH,rmF,yrmF")))]\
"TARGET\_FPA"\
"\*\
{\
if (which\_alternative == 0)\
return "fpam%.s %2,%w1,%w3,%0";\
return "fpam%.s %x2,%1,%x3,%0";\
}")

(define\_insn ""\
\[(set (match\_operand:SF 0 "register\_operand" "=x,y,y")\
(mult:SF (match\_operand:SF 1 "general\_operand" "xH,rmF,yrmF")\
(plus:SF (match\_operand:SF 2 "register\_operand" "%xH,rmF,y")\
(match\_operand:SF 3 "general\_operand" "x,y,yrmF"))))]\
"TARGET\_FPA"\
"\*\
{\
if (which\_alternative == 0)\
return "fpam%.s %3,%w2,%w1,%0";\
return "fpam%.s %x3,%2,%x1,%0";\
}")

;;FPA Subtract and multiply\
(define\_insn ""\
\[(set (match\_operand:DF 0 "register\_operand" "=x,y,y")\
(mult:DF (minus:DF (match\_operand:DF 1 "register\_operand" "xH,y,y")\
(match\_operand:DF 2 "general\_operand" "x,y,rmF"))\
(match\_operand:DF 3 "general\_operand" "xH,rmF,y")))]\
"TARGET\_FPA"\
"\*\
{\
if (which\_alternative == 0)\
return "fpsm%.d %2,%w1,%w3,%0";\
return "fpsm%.d %x2,%1,%x3,%0";\
}")

(define\_insn ""\
\[(set (match\_operand:DF 0 "register\_operand" "=x,y,y")\
(mult:DF (match\_operand:DF 1 "general\_operand" "xH,rmF,y")\
(minus:DF (match\_operand:DF 2 "register\_operand" "xH,y,y")\
(match\_operand:DF 3 "general\_operand" "x,y,rmF"))))]\
"TARGET\_FPA"\
"\*\
{\
if (which\_alternative == 0)\
return "fpsm%.d %3,%w2,%w1,%0";\
return "fpsm%.d %x3,%2,%x1,%0";\
}")

(define\_insn ""\
\[(set (match\_operand:SF 0 "register\_operand" "=x,y,y")\
(mult:SF (minus:SF (match\_operand:SF 1 "register\_operand" "xH,rmF,y")\
(match\_operand:SF 2 "general\_operand" "x,y,yrmF"))\
(match\_operand:SF 3 "general\_operand" "xH,rmF,yrmF")))]\
"TARGET\_FPA"\
"\*\
{\
if (which\_alternative == 0)\
return "fpsm%.s %2,%w1,%w3,%0";\
return "fpsm%.s %x2,%1,%x3,%0";\
}")

(define\_insn ""\
\[(set (match\_operand:SF 0 "register\_operand" "=x,y,y")\
(mult:SF (match\_operand:SF 1 "general\_operand" "xH,rmF,yrmF")\
(minus:SF (match\_operand:SF 2 "register\_operand" "xH,rmF,y")\
(match\_operand:SF 3 "general\_operand" "x,y,yrmF"))))]\
"TARGET\_FPA"\
"\*\
{\
if (which\_alternative == 0)\
return "fpsm%.s %3,%w2,%w1,%0";\
return "fpsm%.s %x3,%2,%x1,%0";\
}")

;;- Local variables:\
;;- mode:emacs-lisp\
;;- comment-start: ";;- "\
;;- comment-start-skip: ";+- \*"\
;;- eval: (set-syntax-table (copy-sequence (syntax-table)))\
;;- eval: (modify-syntax-entry ?\[ "(]")\
;;- eval: (modify-syntax-entry ?] ")\[")\
;;- eval: (modify-syntax-entry ?{ "(}")\
;;- eval: (modify-syntax-entry ?} "){")\
;;- End:
